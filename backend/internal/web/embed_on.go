//go:build embed

package web

import (
	"bytes"
	"context"
	"embed"
	"encoding/json"
	"io"
	"io/fs"
	"net/http"
	"strings"
	"time"

	"github.com/Wei-Shaw/sub2api/internal/server/middleware"
	"github.com/gin-gonic/gin"
)

const (
	// NonceHTMLPlaceholder is the placeholder for nonce in HTML script tags
	NonceHTMLPlaceholder = "__CSP_NONCE_VALUE__"

	// SEO placeholders
	SEOTitlePlaceholder       = "__SEO_TITLE__"
	SEODescriptionPlaceholder = "__SEO_DESCRIPTION__"
	SEOImagePlaceholder       = "__SEO_IMAGE__"

	// Default SEO values
	DefaultSEOTitle       = "Sub2API - AI Coding Relay"
	DefaultSEODescription = "One API key for Claude Code, Codex CLI, Gemini CLI, and Cursor â€” transparent billing, real-time usage, and safety limits."
	DefaultSEOImage       = "/logo.png"
)

//go:embed all:dist
var frontendFS embed.FS

// PublicSettingsProvider is an interface to fetch public settings
type PublicSettingsProvider interface {
	GetPublicSettingsForInjection(ctx context.Context) (any, error)
}

// FrontendServer serves the embedded frontend with settings injection
type FrontendServer struct {
	distFS     fs.FS
	fileServer http.Handler
	baseHTML   []byte
	cache      *HTMLCache
	settings   PublicSettingsProvider
}

// NewFrontendServer creates a new frontend server with settings injection
func NewFrontendServer(settingsProvider PublicSettingsProvider) (*FrontendServer, error) {
	distFS, err := fs.Sub(frontendFS, "dist")
	if err != nil {
		return nil, err
	}

	// Read base HTML once
	file, err := distFS.Open("index.html")
	if err != nil {
		return nil, err
	}
	defer func() { _ = file.Close() }()

	baseHTML, err := io.ReadAll(file)
	if err != nil {
		return nil, err
	}

	cache := NewHTMLCache()
	cache.SetBaseHTML(baseHTML)

	return &FrontendServer{
		distFS:     distFS,
		fileServer: http.FileServer(http.FS(distFS)),
		baseHTML:   baseHTML,
		cache:      cache,
		settings:   settingsProvider,
	}, nil
}

// InvalidateCache invalidates the HTML cache (call when settings change)
func (s *FrontendServer) InvalidateCache() {
	if s != nil && s.cache != nil {
		s.cache.Invalidate()
	}
}

// InvalidateDomainCache invalidates cache for a specific reseller domain
func (s *FrontendServer) InvalidateDomainCache(domain string) {
	if s != nil && s.cache != nil {
		s.cache.InvalidateDomain(domain)
	}
}

// Middleware returns the Gin middleware handler
func (s *FrontendServer) Middleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		path := c.Request.URL.Path

		// Skip API routes
		if strings.HasPrefix(path, "/api/") ||
			strings.HasPrefix(path, "/v1/") ||
			strings.HasPrefix(path, "/v1beta/") ||
			strings.HasPrefix(path, "/antigravity/") ||
			strings.HasPrefix(path, "/setup/") ||
			path == "/health" ||
			path == "/responses" {
			c.Next()
			return
		}

		cleanPath := strings.TrimPrefix(path, "/")
		if cleanPath == "" {
			cleanPath = "index.html"
		}

		// For index.html or SPA routes, serve with injected settings
		if cleanPath == "index.html" || !s.fileExists(cleanPath) {
			s.serveIndexHTML(c)
			return
		}

		// Serve static files normally
		s.fileServer.ServeHTTP(c.Writer, c.Request)
		c.Abort()
	}
}

func (s *FrontendServer) fileExists(path string) bool {
	file, err := s.distFS.Open(path)
	if err != nil {
		return false
	}
	_ = file.Close()
	return true
}

func (s *FrontendServer) serveIndexHTML(c *gin.Context) {
	// Get nonce from context (generated by SecurityHeaders middleware)
	nonce := middleware.GetNonceFromContext(c)

	// Determine cache key from reseller domain context
	cacheKey := "" // default site
	resellerDomain := middleware.GetResellerDomainFromContext(c)
	if resellerDomain != nil {
		cacheKey = resellerDomain.Domain
	}

	// Check cache first
	cached := s.cache.Get(cacheKey)
	if cached != nil {
		// Check If-None-Match for 304 response
		if match := c.GetHeader("If-None-Match"); match == cached.ETag {
			c.Status(http.StatusNotModified)
			c.Abort()
			return
		}

		// Replace nonce placeholder with actual nonce before serving
		content := replaceNoncePlaceholder(cached.Content, nonce)

		c.Header("ETag", cached.ETag)
		c.Header("Cache-Control", "no-cache") // Must revalidate
		c.Data(http.StatusOK, "text/html; charset=utf-8", content)
		c.Abort()
		return
	}

	// Cache miss - fetch settings and render
	ctx, cancel := context.WithTimeout(c.Request.Context(), 2*time.Second)
	defer cancel()

	settings, err := s.settings.GetPublicSettingsForInjection(ctx)
	if err != nil {
		// Fallback: serve without injection
		c.Data(http.StatusOK, "text/html; charset=utf-8", s.baseHTML)
		c.Abort()
		return
	}

	settingsJSON, err := json.Marshal(settings)
	if err != nil {
		// Fallback: serve without injection
		c.Data(http.StatusOK, "text/html; charset=utf-8", s.baseHTML)
		c.Abort()
		return
	}

	// If this is a reseller domain, merge reseller branding into settings
	if resellerDomain != nil {
		settingsJSON = mergeResellerBranding(settingsJSON, resellerDomain)
	}

	rendered := s.injectSettings(settingsJSON)
	s.cache.Set(cacheKey, rendered, settingsJSON)

	// Replace nonce placeholder with actual nonce before serving
	content := replaceNoncePlaceholder(rendered, nonce)

	cached = s.cache.Get(cacheKey)
	if cached != nil {
		c.Header("ETag", cached.ETag)
	}
	c.Header("Cache-Control", "no-cache")
	c.Data(http.StatusOK, "text/html; charset=utf-8", content)
	c.Abort()
}

// mergeResellerBranding overlays reseller branding onto the base public settings JSON.
// It overrides site_name, site_logo, etc. and adds reseller_id for frontend auto-registration.
func mergeResellerBranding(baseJSON []byte, info *middleware.ResellerDomainContext) []byte {
	var m map[string]any
	if err := json.Unmarshal(baseJSON, &m); err != nil {
		return baseJSON
	}

	// Add reseller-specific fields
	m["reseller_id"] = info.ResellerID
	m["reseller_domain"] = info.Domain

	// Override branding from domain-level settings (per-domain)
	if info.SiteName != "" {
		m["site_name"] = info.SiteName
	}
	if info.SiteLogo != "" {
		m["site_logo"] = info.SiteLogo
	}
	if info.BrandColor != "" {
		m["brand_color"] = info.BrandColor
	}
	if info.CustomCSS != "" {
		m["custom_css"] = info.CustomCSS
	}
	if info.Subtitle != "" {
		m["site_subtitle"] = info.Subtitle
	}
	if info.HomeContent != "" {
		m["home_content"] = info.HomeContent
	}
	// For reseller domains: only show doc_url and purchase if the reseller explicitly set them.
	// Clear system defaults so the frontend can hide links the reseller didn't configure.
	if info.DocURL != "" {
		m["doc_url"] = info.DocURL
	} else {
		delete(m, "doc_url")
	}
	if info.HomeTemplate != "" {
		m["home_template"] = info.HomeTemplate
	}
	if info.PurchaseEnabled {
		m["purchase_enabled"] = true
		if info.PurchaseURL != "" {
			m["purchase_url"] = info.PurchaseURL
		}
	} else {
		delete(m, "purchase_enabled")
		delete(m, "purchase_url")
	}
	// Also clear system-wide purchase settings on reseller domains
	delete(m, "purchase_subscription_enabled")
	delete(m, "purchase_subscription_url")
	if info.SEOTitle != "" {
		m["seo_title"] = info.SEOTitle
	}
	if info.SEODescription != "" {
		m["seo_description"] = info.SEODescription
	}
	if info.SEOKeywords != "" {
		m["seo_keywords"] = info.SEOKeywords
	}
	if info.LoginRedirect != "" {
		m["login_redirect"] = info.LoginRedirect
	}

	// Override from reseller-global settings (contact_info, crypto_addresses, default_locale, etc.)
	if rs := info.ResellerSettings; rs != nil {
		if v := rs["contact_info"]; v != "" {
			m["contact_info"] = v
		}
		if v := rs["crypto_addresses"]; v != "" {
			m["crypto_addresses"] = v
		}
		if v := rs["default_locale"]; v != "" {
			m["default_locale"] = v
		}
		if v := rs["contact_wechat"]; v != "" {
			m["contact_wechat"] = v
		}
		if v := rs["contact_telegram"]; v != "" {
			m["contact_telegram"] = v
		}
	}

	// Domain-level default_locale overrides reseller-global default_locale
	if info.DefaultLocale != "" {
		m["default_locale"] = info.DefaultLocale
	}

	// Replace system announcements with reseller's own SimpleAnnouncements (if any).
	delete(m, "announcements")
	if rs := info.ResellerSettings; rs != nil {
		if v := rs["announcements"]; v != "" {
			var arr []any
			if json.Unmarshal([]byte(v), &arr) == nil && len(arr) > 0 {
				m["announcements"] = arr
			}
		}
	}

	result, err := json.Marshal(m)
	if err != nil {
		return baseJSON
	}
	return result
}

// seoSettings is used to extract SEO-related fields from settings JSON
type seoSettings struct {
	SiteName       string `json:"site_name"`
	SiteSubtitle   string `json:"site_subtitle"`
	SiteLogo       string `json:"site_logo"`
	SEOTitle       string `json:"seo_title"`
	SEODescription string `json:"seo_description"`
}

func (s *FrontendServer) injectSettings(settingsJSON []byte) []byte {
	// Create the script tag to inject with nonce placeholder
	// The placeholder will be replaced with actual nonce at request time
	script := []byte(`<script nonce="` + NonceHTMLPlaceholder + `">window.__APP_CONFIG__=` + string(settingsJSON) + `;</script>`)

	// Start with base HTML
	result := s.baseHTML

	// Extract SEO values from settings
	var seo seoSettings
	if err := json.Unmarshal(settingsJSON, &seo); err == nil {
		// Build SEO title: prefer explicit seo_title, then "SiteName - SiteSubtitle", then default
		seoTitle := DefaultSEOTitle
		if seo.SEOTitle != "" {
			seoTitle = seo.SEOTitle
		} else if seo.SiteName != "" {
			if seo.SiteSubtitle != "" {
				seoTitle = seo.SiteName + " - " + seo.SiteSubtitle
			} else {
				seoTitle = seo.SiteName
			}
		}

		// SEO description: prefer explicit seo_description, then subtitle, then default
		seoDesc := DefaultSEODescription
		if seo.SEODescription != "" {
			seoDesc = seo.SEODescription
		} else if seo.SiteSubtitle != "" {
			seoDesc = seo.SiteSubtitle
		}

		// SEO image: use logo or default
		seoImage := DefaultSEOImage
		if seo.SiteLogo != "" {
			seoImage = seo.SiteLogo
		}

		// Replace SEO placeholders
		result = bytes.ReplaceAll(result, []byte(SEOTitlePlaceholder), []byte(seoTitle))
		result = bytes.ReplaceAll(result, []byte(SEODescriptionPlaceholder), []byte(seoDesc))
		result = bytes.ReplaceAll(result, []byte(SEOImagePlaceholder), []byte(seoImage))
	}

	// Inject script before </head>
	headClose := []byte("</head>")
	return bytes.Replace(result, headClose, append(script, headClose...), 1)
}

// replaceNoncePlaceholder replaces the nonce placeholder with actual nonce value
func replaceNoncePlaceholder(html []byte, nonce string) []byte {
	return bytes.ReplaceAll(html, []byte(NonceHTMLPlaceholder), []byte(nonce))
}

// ServeEmbeddedFrontend returns a middleware for serving embedded frontend
// This is the legacy function for backward compatibility when no settings provider is available
func ServeEmbeddedFrontend() gin.HandlerFunc {
	distFS, err := fs.Sub(frontendFS, "dist")
	if err != nil {
		panic("failed to get dist subdirectory: " + err.Error())
	}
	fileServer := http.FileServer(http.FS(distFS))

	return func(c *gin.Context) {
		path := c.Request.URL.Path

		if strings.HasPrefix(path, "/api/") ||
			strings.HasPrefix(path, "/v1/") ||
			strings.HasPrefix(path, "/v1beta/") ||
			strings.HasPrefix(path, "/antigravity/") ||
			strings.HasPrefix(path, "/setup/") ||
			path == "/health" ||
			path == "/responses" {
			c.Next()
			return
		}

		cleanPath := strings.TrimPrefix(path, "/")
		if cleanPath == "" {
			cleanPath = "index.html"
		}

		if file, err := distFS.Open(cleanPath); err == nil {
			_ = file.Close()
			fileServer.ServeHTTP(c.Writer, c.Request)
			c.Abort()
			return
		}

		serveIndexHTML(c, distFS)
	}
}

func serveIndexHTML(c *gin.Context, fsys fs.FS) {
	file, err := fsys.Open("index.html")
	if err != nil {
		c.String(http.StatusNotFound, "Frontend not found")
		c.Abort()
		return
	}
	defer func() { _ = file.Close() }()

	content, err := io.ReadAll(file)
	if err != nil {
		c.String(http.StatusInternalServerError, "Failed to read index.html")
		c.Abort()
		return
	}

	c.Data(http.StatusOK, "text/html; charset=utf-8", content)
	c.Abort()
}

func HasEmbeddedFrontend() bool {
	_, err := frontendFS.ReadFile("dist/index.html")
	return err == nil
}
