// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/Wei-Shaw/sub2api/ent/account"
	"github.com/Wei-Shaw/sub2api/ent/accountgroup"
	"github.com/Wei-Shaw/sub2api/ent/announcement"
	"github.com/Wei-Shaw/sub2api/ent/announcementread"
	"github.com/Wei-Shaw/sub2api/ent/apikey"
	"github.com/Wei-Shaw/sub2api/ent/channel"
	"github.com/Wei-Shaw/sub2api/ent/errorpassthroughrule"
	"github.com/Wei-Shaw/sub2api/ent/group"
	"github.com/Wei-Shaw/sub2api/ent/order"
	"github.com/Wei-Shaw/sub2api/ent/predicate"
	"github.com/Wei-Shaw/sub2api/ent/promocode"
	"github.com/Wei-Shaw/sub2api/ent/promocodeusage"
	"github.com/Wei-Shaw/sub2api/ent/proxy"
	"github.com/Wei-Shaw/sub2api/ent/rechargeorder"
	"github.com/Wei-Shaw/sub2api/ent/redeemcode"
	"github.com/Wei-Shaw/sub2api/ent/referralreward"
	"github.com/Wei-Shaw/sub2api/ent/resellerdomain"
	"github.com/Wei-Shaw/sub2api/ent/resellersetting"
	"github.com/Wei-Shaw/sub2api/ent/setting"
	"github.com/Wei-Shaw/sub2api/ent/usagecleanuptask"
	"github.com/Wei-Shaw/sub2api/ent/usagelog"
	"github.com/Wei-Shaw/sub2api/ent/user"
	"github.com/Wei-Shaw/sub2api/ent/userallowedgroup"
	"github.com/Wei-Shaw/sub2api/ent/userattributedefinition"
	"github.com/Wei-Shaw/sub2api/ent/userattributevalue"
	"github.com/Wei-Shaw/sub2api/ent/usersubscription"
	"github.com/Wei-Shaw/sub2api/internal/domain"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAPIKey                  = "APIKey"
	TypeAccount                 = "Account"
	TypeAccountGroup            = "AccountGroup"
	TypeAnnouncement            = "Announcement"
	TypeAnnouncementRead        = "AnnouncementRead"
	TypeChannel                 = "Channel"
	TypeErrorPassthroughRule    = "ErrorPassthroughRule"
	TypeGroup                   = "Group"
	TypeOrder                   = "Order"
	TypePromoCode               = "PromoCode"
	TypePromoCodeUsage          = "PromoCodeUsage"
	TypeProxy                   = "Proxy"
	TypeRechargeOrder           = "RechargeOrder"
	TypeRedeemCode              = "RedeemCode"
	TypeReferralReward          = "ReferralReward"
	TypeResellerDomain          = "ResellerDomain"
	TypeResellerSetting         = "ResellerSetting"
	TypeSetting                 = "Setting"
	TypeUsageCleanupTask        = "UsageCleanupTask"
	TypeUsageLog                = "UsageLog"
	TypeUser                    = "User"
	TypeUserAllowedGroup        = "UserAllowedGroup"
	TypeUserAttributeDefinition = "UserAttributeDefinition"
	TypeUserAttributeValue      = "UserAttributeValue"
	TypeUserSubscription        = "UserSubscription"
)

// APIKeyMutation represents an operation that mutates the APIKey nodes in the graph.
type APIKeyMutation struct {
	config
	op                 Op
	typ                string
	id                 *int64
	created_at         *time.Time
	updated_at         *time.Time
	deleted_at         *time.Time
	key                *string
	name               *string
	notes              *string
	status             *string
	ip_whitelist       *[]string
	appendip_whitelist []string
	ip_blacklist       *[]string
	appendip_blacklist []string
	quota              *float64
	addquota           *float64
	quota_used         *float64
	addquota_used      *float64
	expires_at         *time.Time
	tg_chat_id         *int64
	addtg_chat_id      *int64
	clearedFields      map[string]struct{}
	user               *int64
	cleareduser        bool
	group              *int64
	clearedgroup       bool
	usage_logs         map[int64]struct{}
	removedusage_logs  map[int64]struct{}
	clearedusage_logs  bool
	done               bool
	oldValue           func(context.Context) (*APIKey, error)
	predicates         []predicate.APIKey
}

var _ ent.Mutation = (*APIKeyMutation)(nil)

// apikeyOption allows management of the mutation configuration using functional options.
type apikeyOption func(*APIKeyMutation)

// newAPIKeyMutation creates new mutation for the APIKey entity.
func newAPIKeyMutation(c config, op Op, opts ...apikeyOption) *APIKeyMutation {
	m := &APIKeyMutation{
		config:        c,
		op:            op,
		typ:           TypeAPIKey,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAPIKeyID sets the ID field of the mutation.
func withAPIKeyID(id int64) apikeyOption {
	return func(m *APIKeyMutation) {
		var (
			err   error
			once  sync.Once
			value *APIKey
		)
		m.oldValue = func(ctx context.Context) (*APIKey, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().APIKey.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAPIKey sets the old APIKey of the mutation.
func withAPIKey(node *APIKey) apikeyOption {
	return func(m *APIKeyMutation) {
		m.oldValue = func(context.Context) (*APIKey, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m APIKeyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m APIKeyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *APIKeyMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *APIKeyMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().APIKey.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *APIKeyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *APIKeyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *APIKeyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *APIKeyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *APIKeyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *APIKeyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *APIKeyMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *APIKeyMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *APIKeyMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[apikey.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *APIKeyMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[apikey.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *APIKeyMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, apikey.FieldDeletedAt)
}

// SetUserID sets the "user_id" field.
func (m *APIKeyMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *APIKeyMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *APIKeyMutation) ResetUserID() {
	m.user = nil
}

// SetKey sets the "key" field.
func (m *APIKeyMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *APIKeyMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *APIKeyMutation) ResetKey() {
	m.key = nil
}

// SetName sets the "name" field.
func (m *APIKeyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *APIKeyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *APIKeyMutation) ResetName() {
	m.name = nil
}

// SetNotes sets the "notes" field.
func (m *APIKeyMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *APIKeyMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ResetNotes resets all changes to the "notes" field.
func (m *APIKeyMutation) ResetNotes() {
	m.notes = nil
}

// SetGroupID sets the "group_id" field.
func (m *APIKeyMutation) SetGroupID(i int64) {
	m.group = &i
}

// GroupID returns the value of the "group_id" field in the mutation.
func (m *APIKeyMutation) GroupID() (r int64, exists bool) {
	v := m.group
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupID returns the old "group_id" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldGroupID(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupID: %w", err)
	}
	return oldValue.GroupID, nil
}

// ClearGroupID clears the value of the "group_id" field.
func (m *APIKeyMutation) ClearGroupID() {
	m.group = nil
	m.clearedFields[apikey.FieldGroupID] = struct{}{}
}

// GroupIDCleared returns if the "group_id" field was cleared in this mutation.
func (m *APIKeyMutation) GroupIDCleared() bool {
	_, ok := m.clearedFields[apikey.FieldGroupID]
	return ok
}

// ResetGroupID resets all changes to the "group_id" field.
func (m *APIKeyMutation) ResetGroupID() {
	m.group = nil
	delete(m.clearedFields, apikey.FieldGroupID)
}

// SetStatus sets the "status" field.
func (m *APIKeyMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *APIKeyMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *APIKeyMutation) ResetStatus() {
	m.status = nil
}

// SetIPWhitelist sets the "ip_whitelist" field.
func (m *APIKeyMutation) SetIPWhitelist(s []string) {
	m.ip_whitelist = &s
	m.appendip_whitelist = nil
}

// IPWhitelist returns the value of the "ip_whitelist" field in the mutation.
func (m *APIKeyMutation) IPWhitelist() (r []string, exists bool) {
	v := m.ip_whitelist
	if v == nil {
		return
	}
	return *v, true
}

// OldIPWhitelist returns the old "ip_whitelist" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldIPWhitelist(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPWhitelist is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPWhitelist requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPWhitelist: %w", err)
	}
	return oldValue.IPWhitelist, nil
}

// AppendIPWhitelist adds s to the "ip_whitelist" field.
func (m *APIKeyMutation) AppendIPWhitelist(s []string) {
	m.appendip_whitelist = append(m.appendip_whitelist, s...)
}

// AppendedIPWhitelist returns the list of values that were appended to the "ip_whitelist" field in this mutation.
func (m *APIKeyMutation) AppendedIPWhitelist() ([]string, bool) {
	if len(m.appendip_whitelist) == 0 {
		return nil, false
	}
	return m.appendip_whitelist, true
}

// ClearIPWhitelist clears the value of the "ip_whitelist" field.
func (m *APIKeyMutation) ClearIPWhitelist() {
	m.ip_whitelist = nil
	m.appendip_whitelist = nil
	m.clearedFields[apikey.FieldIPWhitelist] = struct{}{}
}

// IPWhitelistCleared returns if the "ip_whitelist" field was cleared in this mutation.
func (m *APIKeyMutation) IPWhitelistCleared() bool {
	_, ok := m.clearedFields[apikey.FieldIPWhitelist]
	return ok
}

// ResetIPWhitelist resets all changes to the "ip_whitelist" field.
func (m *APIKeyMutation) ResetIPWhitelist() {
	m.ip_whitelist = nil
	m.appendip_whitelist = nil
	delete(m.clearedFields, apikey.FieldIPWhitelist)
}

// SetIPBlacklist sets the "ip_blacklist" field.
func (m *APIKeyMutation) SetIPBlacklist(s []string) {
	m.ip_blacklist = &s
	m.appendip_blacklist = nil
}

// IPBlacklist returns the value of the "ip_blacklist" field in the mutation.
func (m *APIKeyMutation) IPBlacklist() (r []string, exists bool) {
	v := m.ip_blacklist
	if v == nil {
		return
	}
	return *v, true
}

// OldIPBlacklist returns the old "ip_blacklist" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldIPBlacklist(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPBlacklist is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPBlacklist requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPBlacklist: %w", err)
	}
	return oldValue.IPBlacklist, nil
}

// AppendIPBlacklist adds s to the "ip_blacklist" field.
func (m *APIKeyMutation) AppendIPBlacklist(s []string) {
	m.appendip_blacklist = append(m.appendip_blacklist, s...)
}

// AppendedIPBlacklist returns the list of values that were appended to the "ip_blacklist" field in this mutation.
func (m *APIKeyMutation) AppendedIPBlacklist() ([]string, bool) {
	if len(m.appendip_blacklist) == 0 {
		return nil, false
	}
	return m.appendip_blacklist, true
}

// ClearIPBlacklist clears the value of the "ip_blacklist" field.
func (m *APIKeyMutation) ClearIPBlacklist() {
	m.ip_blacklist = nil
	m.appendip_blacklist = nil
	m.clearedFields[apikey.FieldIPBlacklist] = struct{}{}
}

// IPBlacklistCleared returns if the "ip_blacklist" field was cleared in this mutation.
func (m *APIKeyMutation) IPBlacklistCleared() bool {
	_, ok := m.clearedFields[apikey.FieldIPBlacklist]
	return ok
}

// ResetIPBlacklist resets all changes to the "ip_blacklist" field.
func (m *APIKeyMutation) ResetIPBlacklist() {
	m.ip_blacklist = nil
	m.appendip_blacklist = nil
	delete(m.clearedFields, apikey.FieldIPBlacklist)
}

// SetQuota sets the "quota" field.
func (m *APIKeyMutation) SetQuota(f float64) {
	m.quota = &f
	m.addquota = nil
}

// Quota returns the value of the "quota" field in the mutation.
func (m *APIKeyMutation) Quota() (r float64, exists bool) {
	v := m.quota
	if v == nil {
		return
	}
	return *v, true
}

// OldQuota returns the old "quota" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldQuota(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuota is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuota requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuota: %w", err)
	}
	return oldValue.Quota, nil
}

// AddQuota adds f to the "quota" field.
func (m *APIKeyMutation) AddQuota(f float64) {
	if m.addquota != nil {
		*m.addquota += f
	} else {
		m.addquota = &f
	}
}

// AddedQuota returns the value that was added to the "quota" field in this mutation.
func (m *APIKeyMutation) AddedQuota() (r float64, exists bool) {
	v := m.addquota
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuota resets all changes to the "quota" field.
func (m *APIKeyMutation) ResetQuota() {
	m.quota = nil
	m.addquota = nil
}

// SetQuotaUsed sets the "quota_used" field.
func (m *APIKeyMutation) SetQuotaUsed(f float64) {
	m.quota_used = &f
	m.addquota_used = nil
}

// QuotaUsed returns the value of the "quota_used" field in the mutation.
func (m *APIKeyMutation) QuotaUsed() (r float64, exists bool) {
	v := m.quota_used
	if v == nil {
		return
	}
	return *v, true
}

// OldQuotaUsed returns the old "quota_used" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldQuotaUsed(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQuotaUsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQuotaUsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQuotaUsed: %w", err)
	}
	return oldValue.QuotaUsed, nil
}

// AddQuotaUsed adds f to the "quota_used" field.
func (m *APIKeyMutation) AddQuotaUsed(f float64) {
	if m.addquota_used != nil {
		*m.addquota_used += f
	} else {
		m.addquota_used = &f
	}
}

// AddedQuotaUsed returns the value that was added to the "quota_used" field in this mutation.
func (m *APIKeyMutation) AddedQuotaUsed() (r float64, exists bool) {
	v := m.addquota_used
	if v == nil {
		return
	}
	return *v, true
}

// ResetQuotaUsed resets all changes to the "quota_used" field.
func (m *APIKeyMutation) ResetQuotaUsed() {
	m.quota_used = nil
	m.addquota_used = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *APIKeyMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *APIKeyMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldExpiresAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *APIKeyMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[apikey.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *APIKeyMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[apikey.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *APIKeyMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, apikey.FieldExpiresAt)
}

// SetTgChatID sets the "tg_chat_id" field.
func (m *APIKeyMutation) SetTgChatID(i int64) {
	m.tg_chat_id = &i
	m.addtg_chat_id = nil
}

// TgChatID returns the value of the "tg_chat_id" field in the mutation.
func (m *APIKeyMutation) TgChatID() (r int64, exists bool) {
	v := m.tg_chat_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTgChatID returns the old "tg_chat_id" field's value of the APIKey entity.
// If the APIKey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APIKeyMutation) OldTgChatID(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTgChatID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTgChatID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTgChatID: %w", err)
	}
	return oldValue.TgChatID, nil
}

// AddTgChatID adds i to the "tg_chat_id" field.
func (m *APIKeyMutation) AddTgChatID(i int64) {
	if m.addtg_chat_id != nil {
		*m.addtg_chat_id += i
	} else {
		m.addtg_chat_id = &i
	}
}

// AddedTgChatID returns the value that was added to the "tg_chat_id" field in this mutation.
func (m *APIKeyMutation) AddedTgChatID() (r int64, exists bool) {
	v := m.addtg_chat_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearTgChatID clears the value of the "tg_chat_id" field.
func (m *APIKeyMutation) ClearTgChatID() {
	m.tg_chat_id = nil
	m.addtg_chat_id = nil
	m.clearedFields[apikey.FieldTgChatID] = struct{}{}
}

// TgChatIDCleared returns if the "tg_chat_id" field was cleared in this mutation.
func (m *APIKeyMutation) TgChatIDCleared() bool {
	_, ok := m.clearedFields[apikey.FieldTgChatID]
	return ok
}

// ResetTgChatID resets all changes to the "tg_chat_id" field.
func (m *APIKeyMutation) ResetTgChatID() {
	m.tg_chat_id = nil
	m.addtg_chat_id = nil
	delete(m.clearedFields, apikey.FieldTgChatID)
}

// ClearUser clears the "user" edge to the User entity.
func (m *APIKeyMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[apikey.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *APIKeyMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *APIKeyMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *APIKeyMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearGroup clears the "group" edge to the Group entity.
func (m *APIKeyMutation) ClearGroup() {
	m.clearedgroup = true
	m.clearedFields[apikey.FieldGroupID] = struct{}{}
}

// GroupCleared reports if the "group" edge to the Group entity was cleared.
func (m *APIKeyMutation) GroupCleared() bool {
	return m.GroupIDCleared() || m.clearedgroup
}

// GroupIDs returns the "group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupID instead. It exists only for internal usage by the builders.
func (m *APIKeyMutation) GroupIDs() (ids []int64) {
	if id := m.group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroup resets all changes to the "group" edge.
func (m *APIKeyMutation) ResetGroup() {
	m.group = nil
	m.clearedgroup = false
}

// AddUsageLogIDs adds the "usage_logs" edge to the UsageLog entity by ids.
func (m *APIKeyMutation) AddUsageLogIDs(ids ...int64) {
	if m.usage_logs == nil {
		m.usage_logs = make(map[int64]struct{})
	}
	for i := range ids {
		m.usage_logs[ids[i]] = struct{}{}
	}
}

// ClearUsageLogs clears the "usage_logs" edge to the UsageLog entity.
func (m *APIKeyMutation) ClearUsageLogs() {
	m.clearedusage_logs = true
}

// UsageLogsCleared reports if the "usage_logs" edge to the UsageLog entity was cleared.
func (m *APIKeyMutation) UsageLogsCleared() bool {
	return m.clearedusage_logs
}

// RemoveUsageLogIDs removes the "usage_logs" edge to the UsageLog entity by IDs.
func (m *APIKeyMutation) RemoveUsageLogIDs(ids ...int64) {
	if m.removedusage_logs == nil {
		m.removedusage_logs = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.usage_logs, ids[i])
		m.removedusage_logs[ids[i]] = struct{}{}
	}
}

// RemovedUsageLogs returns the removed IDs of the "usage_logs" edge to the UsageLog entity.
func (m *APIKeyMutation) RemovedUsageLogsIDs() (ids []int64) {
	for id := range m.removedusage_logs {
		ids = append(ids, id)
	}
	return
}

// UsageLogsIDs returns the "usage_logs" edge IDs in the mutation.
func (m *APIKeyMutation) UsageLogsIDs() (ids []int64) {
	for id := range m.usage_logs {
		ids = append(ids, id)
	}
	return
}

// ResetUsageLogs resets all changes to the "usage_logs" edge.
func (m *APIKeyMutation) ResetUsageLogs() {
	m.usage_logs = nil
	m.clearedusage_logs = false
	m.removedusage_logs = nil
}

// Where appends a list predicates to the APIKeyMutation builder.
func (m *APIKeyMutation) Where(ps ...predicate.APIKey) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the APIKeyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *APIKeyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.APIKey, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *APIKeyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *APIKeyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (APIKey).
func (m *APIKeyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *APIKeyMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_at != nil {
		fields = append(fields, apikey.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, apikey.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, apikey.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, apikey.FieldUserID)
	}
	if m.key != nil {
		fields = append(fields, apikey.FieldKey)
	}
	if m.name != nil {
		fields = append(fields, apikey.FieldName)
	}
	if m.notes != nil {
		fields = append(fields, apikey.FieldNotes)
	}
	if m.group != nil {
		fields = append(fields, apikey.FieldGroupID)
	}
	if m.status != nil {
		fields = append(fields, apikey.FieldStatus)
	}
	if m.ip_whitelist != nil {
		fields = append(fields, apikey.FieldIPWhitelist)
	}
	if m.ip_blacklist != nil {
		fields = append(fields, apikey.FieldIPBlacklist)
	}
	if m.quota != nil {
		fields = append(fields, apikey.FieldQuota)
	}
	if m.quota_used != nil {
		fields = append(fields, apikey.FieldQuotaUsed)
	}
	if m.expires_at != nil {
		fields = append(fields, apikey.FieldExpiresAt)
	}
	if m.tg_chat_id != nil {
		fields = append(fields, apikey.FieldTgChatID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *APIKeyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case apikey.FieldCreatedAt:
		return m.CreatedAt()
	case apikey.FieldUpdatedAt:
		return m.UpdatedAt()
	case apikey.FieldDeletedAt:
		return m.DeletedAt()
	case apikey.FieldUserID:
		return m.UserID()
	case apikey.FieldKey:
		return m.Key()
	case apikey.FieldName:
		return m.Name()
	case apikey.FieldNotes:
		return m.Notes()
	case apikey.FieldGroupID:
		return m.GroupID()
	case apikey.FieldStatus:
		return m.Status()
	case apikey.FieldIPWhitelist:
		return m.IPWhitelist()
	case apikey.FieldIPBlacklist:
		return m.IPBlacklist()
	case apikey.FieldQuota:
		return m.Quota()
	case apikey.FieldQuotaUsed:
		return m.QuotaUsed()
	case apikey.FieldExpiresAt:
		return m.ExpiresAt()
	case apikey.FieldTgChatID:
		return m.TgChatID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *APIKeyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case apikey.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case apikey.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case apikey.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case apikey.FieldUserID:
		return m.OldUserID(ctx)
	case apikey.FieldKey:
		return m.OldKey(ctx)
	case apikey.FieldName:
		return m.OldName(ctx)
	case apikey.FieldNotes:
		return m.OldNotes(ctx)
	case apikey.FieldGroupID:
		return m.OldGroupID(ctx)
	case apikey.FieldStatus:
		return m.OldStatus(ctx)
	case apikey.FieldIPWhitelist:
		return m.OldIPWhitelist(ctx)
	case apikey.FieldIPBlacklist:
		return m.OldIPBlacklist(ctx)
	case apikey.FieldQuota:
		return m.OldQuota(ctx)
	case apikey.FieldQuotaUsed:
		return m.OldQuotaUsed(ctx)
	case apikey.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case apikey.FieldTgChatID:
		return m.OldTgChatID(ctx)
	}
	return nil, fmt.Errorf("unknown APIKey field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *APIKeyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case apikey.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case apikey.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case apikey.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case apikey.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case apikey.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case apikey.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case apikey.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	case apikey.FieldGroupID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupID(v)
		return nil
	case apikey.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case apikey.FieldIPWhitelist:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPWhitelist(v)
		return nil
	case apikey.FieldIPBlacklist:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPBlacklist(v)
		return nil
	case apikey.FieldQuota:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuota(v)
		return nil
	case apikey.FieldQuotaUsed:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQuotaUsed(v)
		return nil
	case apikey.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case apikey.FieldTgChatID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTgChatID(v)
		return nil
	}
	return fmt.Errorf("unknown APIKey field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *APIKeyMutation) AddedFields() []string {
	var fields []string
	if m.addquota != nil {
		fields = append(fields, apikey.FieldQuota)
	}
	if m.addquota_used != nil {
		fields = append(fields, apikey.FieldQuotaUsed)
	}
	if m.addtg_chat_id != nil {
		fields = append(fields, apikey.FieldTgChatID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *APIKeyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case apikey.FieldQuota:
		return m.AddedQuota()
	case apikey.FieldQuotaUsed:
		return m.AddedQuotaUsed()
	case apikey.FieldTgChatID:
		return m.AddedTgChatID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *APIKeyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case apikey.FieldQuota:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuota(v)
		return nil
	case apikey.FieldQuotaUsed:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddQuotaUsed(v)
		return nil
	case apikey.FieldTgChatID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTgChatID(v)
		return nil
	}
	return fmt.Errorf("unknown APIKey numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *APIKeyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(apikey.FieldDeletedAt) {
		fields = append(fields, apikey.FieldDeletedAt)
	}
	if m.FieldCleared(apikey.FieldGroupID) {
		fields = append(fields, apikey.FieldGroupID)
	}
	if m.FieldCleared(apikey.FieldIPWhitelist) {
		fields = append(fields, apikey.FieldIPWhitelist)
	}
	if m.FieldCleared(apikey.FieldIPBlacklist) {
		fields = append(fields, apikey.FieldIPBlacklist)
	}
	if m.FieldCleared(apikey.FieldExpiresAt) {
		fields = append(fields, apikey.FieldExpiresAt)
	}
	if m.FieldCleared(apikey.FieldTgChatID) {
		fields = append(fields, apikey.FieldTgChatID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *APIKeyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *APIKeyMutation) ClearField(name string) error {
	switch name {
	case apikey.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case apikey.FieldGroupID:
		m.ClearGroupID()
		return nil
	case apikey.FieldIPWhitelist:
		m.ClearIPWhitelist()
		return nil
	case apikey.FieldIPBlacklist:
		m.ClearIPBlacklist()
		return nil
	case apikey.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	case apikey.FieldTgChatID:
		m.ClearTgChatID()
		return nil
	}
	return fmt.Errorf("unknown APIKey nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *APIKeyMutation) ResetField(name string) error {
	switch name {
	case apikey.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case apikey.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case apikey.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case apikey.FieldUserID:
		m.ResetUserID()
		return nil
	case apikey.FieldKey:
		m.ResetKey()
		return nil
	case apikey.FieldName:
		m.ResetName()
		return nil
	case apikey.FieldNotes:
		m.ResetNotes()
		return nil
	case apikey.FieldGroupID:
		m.ResetGroupID()
		return nil
	case apikey.FieldStatus:
		m.ResetStatus()
		return nil
	case apikey.FieldIPWhitelist:
		m.ResetIPWhitelist()
		return nil
	case apikey.FieldIPBlacklist:
		m.ResetIPBlacklist()
		return nil
	case apikey.FieldQuota:
		m.ResetQuota()
		return nil
	case apikey.FieldQuotaUsed:
		m.ResetQuotaUsed()
		return nil
	case apikey.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case apikey.FieldTgChatID:
		m.ResetTgChatID()
		return nil
	}
	return fmt.Errorf("unknown APIKey field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *APIKeyMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user != nil {
		edges = append(edges, apikey.EdgeUser)
	}
	if m.group != nil {
		edges = append(edges, apikey.EdgeGroup)
	}
	if m.usage_logs != nil {
		edges = append(edges, apikey.EdgeUsageLogs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *APIKeyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case apikey.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case apikey.EdgeGroup:
		if id := m.group; id != nil {
			return []ent.Value{*id}
		}
	case apikey.EdgeUsageLogs:
		ids := make([]ent.Value, 0, len(m.usage_logs))
		for id := range m.usage_logs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *APIKeyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedusage_logs != nil {
		edges = append(edges, apikey.EdgeUsageLogs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *APIKeyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case apikey.EdgeUsageLogs:
		ids := make([]ent.Value, 0, len(m.removedusage_logs))
		for id := range m.removedusage_logs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *APIKeyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, apikey.EdgeUser)
	}
	if m.clearedgroup {
		edges = append(edges, apikey.EdgeGroup)
	}
	if m.clearedusage_logs {
		edges = append(edges, apikey.EdgeUsageLogs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *APIKeyMutation) EdgeCleared(name string) bool {
	switch name {
	case apikey.EdgeUser:
		return m.cleareduser
	case apikey.EdgeGroup:
		return m.clearedgroup
	case apikey.EdgeUsageLogs:
		return m.clearedusage_logs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *APIKeyMutation) ClearEdge(name string) error {
	switch name {
	case apikey.EdgeUser:
		m.ClearUser()
		return nil
	case apikey.EdgeGroup:
		m.ClearGroup()
		return nil
	}
	return fmt.Errorf("unknown APIKey unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *APIKeyMutation) ResetEdge(name string) error {
	switch name {
	case apikey.EdgeUser:
		m.ResetUser()
		return nil
	case apikey.EdgeGroup:
		m.ResetGroup()
		return nil
	case apikey.EdgeUsageLogs:
		m.ResetUsageLogs()
		return nil
	}
	return fmt.Errorf("unknown APIKey edge %s", name)
}

// AccountMutation represents an operation that mutates the Account nodes in the graph.
type AccountMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int64
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *time.Time
	name                  *string
	notes                 *string
	platform              *string
	_type                 *string
	credentials           *map[string]interface{}
	extra                 *map[string]interface{}
	concurrency           *int
	addconcurrency        *int
	priority              *int
	addpriority           *int
	rate_multiplier       *float64
	addrate_multiplier    *float64
	status                *string
	error_message         *string
	last_used_at          *time.Time
	expires_at            *time.Time
	auto_pause_on_expired *bool
	schedulable           *bool
	rate_limited_at       *time.Time
	rate_limit_reset_at   *time.Time
	overload_until        *time.Time
	session_window_start  *time.Time
	session_window_end    *time.Time
	session_window_status *string
	clearedFields         map[string]struct{}
	groups                map[int64]struct{}
	removedgroups         map[int64]struct{}
	clearedgroups         bool
	proxy                 *int64
	clearedproxy          bool
	usage_logs            map[int64]struct{}
	removedusage_logs     map[int64]struct{}
	clearedusage_logs     bool
	done                  bool
	oldValue              func(context.Context) (*Account, error)
	predicates            []predicate.Account
}

var _ ent.Mutation = (*AccountMutation)(nil)

// accountOption allows management of the mutation configuration using functional options.
type accountOption func(*AccountMutation)

// newAccountMutation creates new mutation for the Account entity.
func newAccountMutation(c config, op Op, opts ...accountOption) *AccountMutation {
	m := &AccountMutation{
		config:        c,
		op:            op,
		typ:           TypeAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountID sets the ID field of the mutation.
func withAccountID(id int64) accountOption {
	return func(m *AccountMutation) {
		var (
			err   error
			once  sync.Once
			value *Account
		)
		m.oldValue = func(ctx context.Context) (*Account, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Account.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccount sets the old Account of the mutation.
func withAccount(node *Account) accountOption {
	return func(m *AccountMutation) {
		m.oldValue = func(context.Context) (*Account, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccountMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccountMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Account.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AccountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AccountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AccountMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AccountMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AccountMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AccountMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AccountMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AccountMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AccountMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[account.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AccountMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[account.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AccountMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, account.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *AccountMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AccountMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AccountMutation) ResetName() {
	m.name = nil
}

// SetNotes sets the "notes" field.
func (m *AccountMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *AccountMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldNotes(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *AccountMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[account.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *AccountMutation) NotesCleared() bool {
	_, ok := m.clearedFields[account.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *AccountMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, account.FieldNotes)
}

// SetPlatform sets the "platform" field.
func (m *AccountMutation) SetPlatform(s string) {
	m.platform = &s
}

// Platform returns the value of the "platform" field in the mutation.
func (m *AccountMutation) Platform() (r string, exists bool) {
	v := m.platform
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatform returns the old "platform" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldPlatform(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatform: %w", err)
	}
	return oldValue.Platform, nil
}

// ResetPlatform resets all changes to the "platform" field.
func (m *AccountMutation) ResetPlatform() {
	m.platform = nil
}

// SetType sets the "type" field.
func (m *AccountMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *AccountMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *AccountMutation) ResetType() {
	m._type = nil
}

// SetCredentials sets the "credentials" field.
func (m *AccountMutation) SetCredentials(value map[string]interface{}) {
	m.credentials = &value
}

// Credentials returns the value of the "credentials" field in the mutation.
func (m *AccountMutation) Credentials() (r map[string]interface{}, exists bool) {
	v := m.credentials
	if v == nil {
		return
	}
	return *v, true
}

// OldCredentials returns the old "credentials" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldCredentials(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCredentials is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCredentials requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCredentials: %w", err)
	}
	return oldValue.Credentials, nil
}

// ResetCredentials resets all changes to the "credentials" field.
func (m *AccountMutation) ResetCredentials() {
	m.credentials = nil
}

// SetExtra sets the "extra" field.
func (m *AccountMutation) SetExtra(value map[string]interface{}) {
	m.extra = &value
}

// Extra returns the value of the "extra" field in the mutation.
func (m *AccountMutation) Extra() (r map[string]interface{}, exists bool) {
	v := m.extra
	if v == nil {
		return
	}
	return *v, true
}

// OldExtra returns the old "extra" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldExtra(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtra is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtra requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtra: %w", err)
	}
	return oldValue.Extra, nil
}

// ResetExtra resets all changes to the "extra" field.
func (m *AccountMutation) ResetExtra() {
	m.extra = nil
}

// SetProxyID sets the "proxy_id" field.
func (m *AccountMutation) SetProxyID(i int64) {
	m.proxy = &i
}

// ProxyID returns the value of the "proxy_id" field in the mutation.
func (m *AccountMutation) ProxyID() (r int64, exists bool) {
	v := m.proxy
	if v == nil {
		return
	}
	return *v, true
}

// OldProxyID returns the old "proxy_id" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldProxyID(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProxyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProxyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProxyID: %w", err)
	}
	return oldValue.ProxyID, nil
}

// ClearProxyID clears the value of the "proxy_id" field.
func (m *AccountMutation) ClearProxyID() {
	m.proxy = nil
	m.clearedFields[account.FieldProxyID] = struct{}{}
}

// ProxyIDCleared returns if the "proxy_id" field was cleared in this mutation.
func (m *AccountMutation) ProxyIDCleared() bool {
	_, ok := m.clearedFields[account.FieldProxyID]
	return ok
}

// ResetProxyID resets all changes to the "proxy_id" field.
func (m *AccountMutation) ResetProxyID() {
	m.proxy = nil
	delete(m.clearedFields, account.FieldProxyID)
}

// SetConcurrency sets the "concurrency" field.
func (m *AccountMutation) SetConcurrency(i int) {
	m.concurrency = &i
	m.addconcurrency = nil
}

// Concurrency returns the value of the "concurrency" field in the mutation.
func (m *AccountMutation) Concurrency() (r int, exists bool) {
	v := m.concurrency
	if v == nil {
		return
	}
	return *v, true
}

// OldConcurrency returns the old "concurrency" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldConcurrency(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConcurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConcurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConcurrency: %w", err)
	}
	return oldValue.Concurrency, nil
}

// AddConcurrency adds i to the "concurrency" field.
func (m *AccountMutation) AddConcurrency(i int) {
	if m.addconcurrency != nil {
		*m.addconcurrency += i
	} else {
		m.addconcurrency = &i
	}
}

// AddedConcurrency returns the value that was added to the "concurrency" field in this mutation.
func (m *AccountMutation) AddedConcurrency() (r int, exists bool) {
	v := m.addconcurrency
	if v == nil {
		return
	}
	return *v, true
}

// ResetConcurrency resets all changes to the "concurrency" field.
func (m *AccountMutation) ResetConcurrency() {
	m.concurrency = nil
	m.addconcurrency = nil
}

// SetPriority sets the "priority" field.
func (m *AccountMutation) SetPriority(i int) {
	m.priority = &i
	m.addpriority = nil
}

// Priority returns the value of the "priority" field in the mutation.
func (m *AccountMutation) Priority() (r int, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldPriority(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// AddPriority adds i to the "priority" field.
func (m *AccountMutation) AddPriority(i int) {
	if m.addpriority != nil {
		*m.addpriority += i
	} else {
		m.addpriority = &i
	}
}

// AddedPriority returns the value that was added to the "priority" field in this mutation.
func (m *AccountMutation) AddedPriority() (r int, exists bool) {
	v := m.addpriority
	if v == nil {
		return
	}
	return *v, true
}

// ResetPriority resets all changes to the "priority" field.
func (m *AccountMutation) ResetPriority() {
	m.priority = nil
	m.addpriority = nil
}

// SetRateMultiplier sets the "rate_multiplier" field.
func (m *AccountMutation) SetRateMultiplier(f float64) {
	m.rate_multiplier = &f
	m.addrate_multiplier = nil
}

// RateMultiplier returns the value of the "rate_multiplier" field in the mutation.
func (m *AccountMutation) RateMultiplier() (r float64, exists bool) {
	v := m.rate_multiplier
	if v == nil {
		return
	}
	return *v, true
}

// OldRateMultiplier returns the old "rate_multiplier" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldRateMultiplier(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRateMultiplier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRateMultiplier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRateMultiplier: %w", err)
	}
	return oldValue.RateMultiplier, nil
}

// AddRateMultiplier adds f to the "rate_multiplier" field.
func (m *AccountMutation) AddRateMultiplier(f float64) {
	if m.addrate_multiplier != nil {
		*m.addrate_multiplier += f
	} else {
		m.addrate_multiplier = &f
	}
}

// AddedRateMultiplier returns the value that was added to the "rate_multiplier" field in this mutation.
func (m *AccountMutation) AddedRateMultiplier() (r float64, exists bool) {
	v := m.addrate_multiplier
	if v == nil {
		return
	}
	return *v, true
}

// ResetRateMultiplier resets all changes to the "rate_multiplier" field.
func (m *AccountMutation) ResetRateMultiplier() {
	m.rate_multiplier = nil
	m.addrate_multiplier = nil
}

// SetStatus sets the "status" field.
func (m *AccountMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *AccountMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *AccountMutation) ResetStatus() {
	m.status = nil
}

// SetErrorMessage sets the "error_message" field.
func (m *AccountMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *AccountMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldErrorMessage(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *AccountMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[account.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *AccountMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[account.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *AccountMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, account.FieldErrorMessage)
}

// SetLastUsedAt sets the "last_used_at" field.
func (m *AccountMutation) SetLastUsedAt(t time.Time) {
	m.last_used_at = &t
}

// LastUsedAt returns the value of the "last_used_at" field in the mutation.
func (m *AccountMutation) LastUsedAt() (r time.Time, exists bool) {
	v := m.last_used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUsedAt returns the old "last_used_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldLastUsedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUsedAt: %w", err)
	}
	return oldValue.LastUsedAt, nil
}

// ClearLastUsedAt clears the value of the "last_used_at" field.
func (m *AccountMutation) ClearLastUsedAt() {
	m.last_used_at = nil
	m.clearedFields[account.FieldLastUsedAt] = struct{}{}
}

// LastUsedAtCleared returns if the "last_used_at" field was cleared in this mutation.
func (m *AccountMutation) LastUsedAtCleared() bool {
	_, ok := m.clearedFields[account.FieldLastUsedAt]
	return ok
}

// ResetLastUsedAt resets all changes to the "last_used_at" field.
func (m *AccountMutation) ResetLastUsedAt() {
	m.last_used_at = nil
	delete(m.clearedFields, account.FieldLastUsedAt)
}

// SetExpiresAt sets the "expires_at" field.
func (m *AccountMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *AccountMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldExpiresAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *AccountMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[account.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *AccountMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[account.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *AccountMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, account.FieldExpiresAt)
}

// SetAutoPauseOnExpired sets the "auto_pause_on_expired" field.
func (m *AccountMutation) SetAutoPauseOnExpired(b bool) {
	m.auto_pause_on_expired = &b
}

// AutoPauseOnExpired returns the value of the "auto_pause_on_expired" field in the mutation.
func (m *AccountMutation) AutoPauseOnExpired() (r bool, exists bool) {
	v := m.auto_pause_on_expired
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoPauseOnExpired returns the old "auto_pause_on_expired" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldAutoPauseOnExpired(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAutoPauseOnExpired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAutoPauseOnExpired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoPauseOnExpired: %w", err)
	}
	return oldValue.AutoPauseOnExpired, nil
}

// ResetAutoPauseOnExpired resets all changes to the "auto_pause_on_expired" field.
func (m *AccountMutation) ResetAutoPauseOnExpired() {
	m.auto_pause_on_expired = nil
}

// SetSchedulable sets the "schedulable" field.
func (m *AccountMutation) SetSchedulable(b bool) {
	m.schedulable = &b
}

// Schedulable returns the value of the "schedulable" field in the mutation.
func (m *AccountMutation) Schedulable() (r bool, exists bool) {
	v := m.schedulable
	if v == nil {
		return
	}
	return *v, true
}

// OldSchedulable returns the old "schedulable" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldSchedulable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSchedulable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSchedulable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSchedulable: %w", err)
	}
	return oldValue.Schedulable, nil
}

// ResetSchedulable resets all changes to the "schedulable" field.
func (m *AccountMutation) ResetSchedulable() {
	m.schedulable = nil
}

// SetRateLimitedAt sets the "rate_limited_at" field.
func (m *AccountMutation) SetRateLimitedAt(t time.Time) {
	m.rate_limited_at = &t
}

// RateLimitedAt returns the value of the "rate_limited_at" field in the mutation.
func (m *AccountMutation) RateLimitedAt() (r time.Time, exists bool) {
	v := m.rate_limited_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRateLimitedAt returns the old "rate_limited_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldRateLimitedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRateLimitedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRateLimitedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRateLimitedAt: %w", err)
	}
	return oldValue.RateLimitedAt, nil
}

// ClearRateLimitedAt clears the value of the "rate_limited_at" field.
func (m *AccountMutation) ClearRateLimitedAt() {
	m.rate_limited_at = nil
	m.clearedFields[account.FieldRateLimitedAt] = struct{}{}
}

// RateLimitedAtCleared returns if the "rate_limited_at" field was cleared in this mutation.
func (m *AccountMutation) RateLimitedAtCleared() bool {
	_, ok := m.clearedFields[account.FieldRateLimitedAt]
	return ok
}

// ResetRateLimitedAt resets all changes to the "rate_limited_at" field.
func (m *AccountMutation) ResetRateLimitedAt() {
	m.rate_limited_at = nil
	delete(m.clearedFields, account.FieldRateLimitedAt)
}

// SetRateLimitResetAt sets the "rate_limit_reset_at" field.
func (m *AccountMutation) SetRateLimitResetAt(t time.Time) {
	m.rate_limit_reset_at = &t
}

// RateLimitResetAt returns the value of the "rate_limit_reset_at" field in the mutation.
func (m *AccountMutation) RateLimitResetAt() (r time.Time, exists bool) {
	v := m.rate_limit_reset_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRateLimitResetAt returns the old "rate_limit_reset_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldRateLimitResetAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRateLimitResetAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRateLimitResetAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRateLimitResetAt: %w", err)
	}
	return oldValue.RateLimitResetAt, nil
}

// ClearRateLimitResetAt clears the value of the "rate_limit_reset_at" field.
func (m *AccountMutation) ClearRateLimitResetAt() {
	m.rate_limit_reset_at = nil
	m.clearedFields[account.FieldRateLimitResetAt] = struct{}{}
}

// RateLimitResetAtCleared returns if the "rate_limit_reset_at" field was cleared in this mutation.
func (m *AccountMutation) RateLimitResetAtCleared() bool {
	_, ok := m.clearedFields[account.FieldRateLimitResetAt]
	return ok
}

// ResetRateLimitResetAt resets all changes to the "rate_limit_reset_at" field.
func (m *AccountMutation) ResetRateLimitResetAt() {
	m.rate_limit_reset_at = nil
	delete(m.clearedFields, account.FieldRateLimitResetAt)
}

// SetOverloadUntil sets the "overload_until" field.
func (m *AccountMutation) SetOverloadUntil(t time.Time) {
	m.overload_until = &t
}

// OverloadUntil returns the value of the "overload_until" field in the mutation.
func (m *AccountMutation) OverloadUntil() (r time.Time, exists bool) {
	v := m.overload_until
	if v == nil {
		return
	}
	return *v, true
}

// OldOverloadUntil returns the old "overload_until" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldOverloadUntil(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOverloadUntil is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOverloadUntil requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOverloadUntil: %w", err)
	}
	return oldValue.OverloadUntil, nil
}

// ClearOverloadUntil clears the value of the "overload_until" field.
func (m *AccountMutation) ClearOverloadUntil() {
	m.overload_until = nil
	m.clearedFields[account.FieldOverloadUntil] = struct{}{}
}

// OverloadUntilCleared returns if the "overload_until" field was cleared in this mutation.
func (m *AccountMutation) OverloadUntilCleared() bool {
	_, ok := m.clearedFields[account.FieldOverloadUntil]
	return ok
}

// ResetOverloadUntil resets all changes to the "overload_until" field.
func (m *AccountMutation) ResetOverloadUntil() {
	m.overload_until = nil
	delete(m.clearedFields, account.FieldOverloadUntil)
}

// SetSessionWindowStart sets the "session_window_start" field.
func (m *AccountMutation) SetSessionWindowStart(t time.Time) {
	m.session_window_start = &t
}

// SessionWindowStart returns the value of the "session_window_start" field in the mutation.
func (m *AccountMutation) SessionWindowStart() (r time.Time, exists bool) {
	v := m.session_window_start
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionWindowStart returns the old "session_window_start" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldSessionWindowStart(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionWindowStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionWindowStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionWindowStart: %w", err)
	}
	return oldValue.SessionWindowStart, nil
}

// ClearSessionWindowStart clears the value of the "session_window_start" field.
func (m *AccountMutation) ClearSessionWindowStart() {
	m.session_window_start = nil
	m.clearedFields[account.FieldSessionWindowStart] = struct{}{}
}

// SessionWindowStartCleared returns if the "session_window_start" field was cleared in this mutation.
func (m *AccountMutation) SessionWindowStartCleared() bool {
	_, ok := m.clearedFields[account.FieldSessionWindowStart]
	return ok
}

// ResetSessionWindowStart resets all changes to the "session_window_start" field.
func (m *AccountMutation) ResetSessionWindowStart() {
	m.session_window_start = nil
	delete(m.clearedFields, account.FieldSessionWindowStart)
}

// SetSessionWindowEnd sets the "session_window_end" field.
func (m *AccountMutation) SetSessionWindowEnd(t time.Time) {
	m.session_window_end = &t
}

// SessionWindowEnd returns the value of the "session_window_end" field in the mutation.
func (m *AccountMutation) SessionWindowEnd() (r time.Time, exists bool) {
	v := m.session_window_end
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionWindowEnd returns the old "session_window_end" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldSessionWindowEnd(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionWindowEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionWindowEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionWindowEnd: %w", err)
	}
	return oldValue.SessionWindowEnd, nil
}

// ClearSessionWindowEnd clears the value of the "session_window_end" field.
func (m *AccountMutation) ClearSessionWindowEnd() {
	m.session_window_end = nil
	m.clearedFields[account.FieldSessionWindowEnd] = struct{}{}
}

// SessionWindowEndCleared returns if the "session_window_end" field was cleared in this mutation.
func (m *AccountMutation) SessionWindowEndCleared() bool {
	_, ok := m.clearedFields[account.FieldSessionWindowEnd]
	return ok
}

// ResetSessionWindowEnd resets all changes to the "session_window_end" field.
func (m *AccountMutation) ResetSessionWindowEnd() {
	m.session_window_end = nil
	delete(m.clearedFields, account.FieldSessionWindowEnd)
}

// SetSessionWindowStatus sets the "session_window_status" field.
func (m *AccountMutation) SetSessionWindowStatus(s string) {
	m.session_window_status = &s
}

// SessionWindowStatus returns the value of the "session_window_status" field in the mutation.
func (m *AccountMutation) SessionWindowStatus() (r string, exists bool) {
	v := m.session_window_status
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionWindowStatus returns the old "session_window_status" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldSessionWindowStatus(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionWindowStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionWindowStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionWindowStatus: %w", err)
	}
	return oldValue.SessionWindowStatus, nil
}

// ClearSessionWindowStatus clears the value of the "session_window_status" field.
func (m *AccountMutation) ClearSessionWindowStatus() {
	m.session_window_status = nil
	m.clearedFields[account.FieldSessionWindowStatus] = struct{}{}
}

// SessionWindowStatusCleared returns if the "session_window_status" field was cleared in this mutation.
func (m *AccountMutation) SessionWindowStatusCleared() bool {
	_, ok := m.clearedFields[account.FieldSessionWindowStatus]
	return ok
}

// ResetSessionWindowStatus resets all changes to the "session_window_status" field.
func (m *AccountMutation) ResetSessionWindowStatus() {
	m.session_window_status = nil
	delete(m.clearedFields, account.FieldSessionWindowStatus)
}

// AddGroupIDs adds the "groups" edge to the Group entity by ids.
func (m *AccountMutation) AddGroupIDs(ids ...int64) {
	if m.groups == nil {
		m.groups = make(map[int64]struct{})
	}
	for i := range ids {
		m.groups[ids[i]] = struct{}{}
	}
}

// ClearGroups clears the "groups" edge to the Group entity.
func (m *AccountMutation) ClearGroups() {
	m.clearedgroups = true
}

// GroupsCleared reports if the "groups" edge to the Group entity was cleared.
func (m *AccountMutation) GroupsCleared() bool {
	return m.clearedgroups
}

// RemoveGroupIDs removes the "groups" edge to the Group entity by IDs.
func (m *AccountMutation) RemoveGroupIDs(ids ...int64) {
	if m.removedgroups == nil {
		m.removedgroups = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.groups, ids[i])
		m.removedgroups[ids[i]] = struct{}{}
	}
}

// RemovedGroups returns the removed IDs of the "groups" edge to the Group entity.
func (m *AccountMutation) RemovedGroupsIDs() (ids []int64) {
	for id := range m.removedgroups {
		ids = append(ids, id)
	}
	return
}

// GroupsIDs returns the "groups" edge IDs in the mutation.
func (m *AccountMutation) GroupsIDs() (ids []int64) {
	for id := range m.groups {
		ids = append(ids, id)
	}
	return
}

// ResetGroups resets all changes to the "groups" edge.
func (m *AccountMutation) ResetGroups() {
	m.groups = nil
	m.clearedgroups = false
	m.removedgroups = nil
}

// ClearProxy clears the "proxy" edge to the Proxy entity.
func (m *AccountMutation) ClearProxy() {
	m.clearedproxy = true
	m.clearedFields[account.FieldProxyID] = struct{}{}
}

// ProxyCleared reports if the "proxy" edge to the Proxy entity was cleared.
func (m *AccountMutation) ProxyCleared() bool {
	return m.ProxyIDCleared() || m.clearedproxy
}

// ProxyIDs returns the "proxy" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProxyID instead. It exists only for internal usage by the builders.
func (m *AccountMutation) ProxyIDs() (ids []int64) {
	if id := m.proxy; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProxy resets all changes to the "proxy" edge.
func (m *AccountMutation) ResetProxy() {
	m.proxy = nil
	m.clearedproxy = false
}

// AddUsageLogIDs adds the "usage_logs" edge to the UsageLog entity by ids.
func (m *AccountMutation) AddUsageLogIDs(ids ...int64) {
	if m.usage_logs == nil {
		m.usage_logs = make(map[int64]struct{})
	}
	for i := range ids {
		m.usage_logs[ids[i]] = struct{}{}
	}
}

// ClearUsageLogs clears the "usage_logs" edge to the UsageLog entity.
func (m *AccountMutation) ClearUsageLogs() {
	m.clearedusage_logs = true
}

// UsageLogsCleared reports if the "usage_logs" edge to the UsageLog entity was cleared.
func (m *AccountMutation) UsageLogsCleared() bool {
	return m.clearedusage_logs
}

// RemoveUsageLogIDs removes the "usage_logs" edge to the UsageLog entity by IDs.
func (m *AccountMutation) RemoveUsageLogIDs(ids ...int64) {
	if m.removedusage_logs == nil {
		m.removedusage_logs = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.usage_logs, ids[i])
		m.removedusage_logs[ids[i]] = struct{}{}
	}
}

// RemovedUsageLogs returns the removed IDs of the "usage_logs" edge to the UsageLog entity.
func (m *AccountMutation) RemovedUsageLogsIDs() (ids []int64) {
	for id := range m.removedusage_logs {
		ids = append(ids, id)
	}
	return
}

// UsageLogsIDs returns the "usage_logs" edge IDs in the mutation.
func (m *AccountMutation) UsageLogsIDs() (ids []int64) {
	for id := range m.usage_logs {
		ids = append(ids, id)
	}
	return
}

// ResetUsageLogs resets all changes to the "usage_logs" edge.
func (m *AccountMutation) ResetUsageLogs() {
	m.usage_logs = nil
	m.clearedusage_logs = false
	m.removedusage_logs = nil
}

// Where appends a list predicates to the AccountMutation builder.
func (m *AccountMutation) Where(ps ...predicate.Account) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AccountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AccountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Account, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AccountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AccountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Account).
func (m *AccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountMutation) Fields() []string {
	fields := make([]string, 0, 25)
	if m.created_at != nil {
		fields = append(fields, account.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, account.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, account.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, account.FieldName)
	}
	if m.notes != nil {
		fields = append(fields, account.FieldNotes)
	}
	if m.platform != nil {
		fields = append(fields, account.FieldPlatform)
	}
	if m._type != nil {
		fields = append(fields, account.FieldType)
	}
	if m.credentials != nil {
		fields = append(fields, account.FieldCredentials)
	}
	if m.extra != nil {
		fields = append(fields, account.FieldExtra)
	}
	if m.proxy != nil {
		fields = append(fields, account.FieldProxyID)
	}
	if m.concurrency != nil {
		fields = append(fields, account.FieldConcurrency)
	}
	if m.priority != nil {
		fields = append(fields, account.FieldPriority)
	}
	if m.rate_multiplier != nil {
		fields = append(fields, account.FieldRateMultiplier)
	}
	if m.status != nil {
		fields = append(fields, account.FieldStatus)
	}
	if m.error_message != nil {
		fields = append(fields, account.FieldErrorMessage)
	}
	if m.last_used_at != nil {
		fields = append(fields, account.FieldLastUsedAt)
	}
	if m.expires_at != nil {
		fields = append(fields, account.FieldExpiresAt)
	}
	if m.auto_pause_on_expired != nil {
		fields = append(fields, account.FieldAutoPauseOnExpired)
	}
	if m.schedulable != nil {
		fields = append(fields, account.FieldSchedulable)
	}
	if m.rate_limited_at != nil {
		fields = append(fields, account.FieldRateLimitedAt)
	}
	if m.rate_limit_reset_at != nil {
		fields = append(fields, account.FieldRateLimitResetAt)
	}
	if m.overload_until != nil {
		fields = append(fields, account.FieldOverloadUntil)
	}
	if m.session_window_start != nil {
		fields = append(fields, account.FieldSessionWindowStart)
	}
	if m.session_window_end != nil {
		fields = append(fields, account.FieldSessionWindowEnd)
	}
	if m.session_window_status != nil {
		fields = append(fields, account.FieldSessionWindowStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case account.FieldCreatedAt:
		return m.CreatedAt()
	case account.FieldUpdatedAt:
		return m.UpdatedAt()
	case account.FieldDeletedAt:
		return m.DeletedAt()
	case account.FieldName:
		return m.Name()
	case account.FieldNotes:
		return m.Notes()
	case account.FieldPlatform:
		return m.Platform()
	case account.FieldType:
		return m.GetType()
	case account.FieldCredentials:
		return m.Credentials()
	case account.FieldExtra:
		return m.Extra()
	case account.FieldProxyID:
		return m.ProxyID()
	case account.FieldConcurrency:
		return m.Concurrency()
	case account.FieldPriority:
		return m.Priority()
	case account.FieldRateMultiplier:
		return m.RateMultiplier()
	case account.FieldStatus:
		return m.Status()
	case account.FieldErrorMessage:
		return m.ErrorMessage()
	case account.FieldLastUsedAt:
		return m.LastUsedAt()
	case account.FieldExpiresAt:
		return m.ExpiresAt()
	case account.FieldAutoPauseOnExpired:
		return m.AutoPauseOnExpired()
	case account.FieldSchedulable:
		return m.Schedulable()
	case account.FieldRateLimitedAt:
		return m.RateLimitedAt()
	case account.FieldRateLimitResetAt:
		return m.RateLimitResetAt()
	case account.FieldOverloadUntil:
		return m.OverloadUntil()
	case account.FieldSessionWindowStart:
		return m.SessionWindowStart()
	case account.FieldSessionWindowEnd:
		return m.SessionWindowEnd()
	case account.FieldSessionWindowStatus:
		return m.SessionWindowStatus()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case account.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case account.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case account.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case account.FieldName:
		return m.OldName(ctx)
	case account.FieldNotes:
		return m.OldNotes(ctx)
	case account.FieldPlatform:
		return m.OldPlatform(ctx)
	case account.FieldType:
		return m.OldType(ctx)
	case account.FieldCredentials:
		return m.OldCredentials(ctx)
	case account.FieldExtra:
		return m.OldExtra(ctx)
	case account.FieldProxyID:
		return m.OldProxyID(ctx)
	case account.FieldConcurrency:
		return m.OldConcurrency(ctx)
	case account.FieldPriority:
		return m.OldPriority(ctx)
	case account.FieldRateMultiplier:
		return m.OldRateMultiplier(ctx)
	case account.FieldStatus:
		return m.OldStatus(ctx)
	case account.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case account.FieldLastUsedAt:
		return m.OldLastUsedAt(ctx)
	case account.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case account.FieldAutoPauseOnExpired:
		return m.OldAutoPauseOnExpired(ctx)
	case account.FieldSchedulable:
		return m.OldSchedulable(ctx)
	case account.FieldRateLimitedAt:
		return m.OldRateLimitedAt(ctx)
	case account.FieldRateLimitResetAt:
		return m.OldRateLimitResetAt(ctx)
	case account.FieldOverloadUntil:
		return m.OldOverloadUntil(ctx)
	case account.FieldSessionWindowStart:
		return m.OldSessionWindowStart(ctx)
	case account.FieldSessionWindowEnd:
		return m.OldSessionWindowEnd(ctx)
	case account.FieldSessionWindowStatus:
		return m.OldSessionWindowStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Account field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case account.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case account.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case account.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case account.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case account.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	case account.FieldPlatform:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatform(v)
		return nil
	case account.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case account.FieldCredentials:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCredentials(v)
		return nil
	case account.FieldExtra:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtra(v)
		return nil
	case account.FieldProxyID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProxyID(v)
		return nil
	case account.FieldConcurrency:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConcurrency(v)
		return nil
	case account.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case account.FieldRateMultiplier:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRateMultiplier(v)
		return nil
	case account.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case account.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case account.FieldLastUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUsedAt(v)
		return nil
	case account.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case account.FieldAutoPauseOnExpired:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoPauseOnExpired(v)
		return nil
	case account.FieldSchedulable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSchedulable(v)
		return nil
	case account.FieldRateLimitedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRateLimitedAt(v)
		return nil
	case account.FieldRateLimitResetAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRateLimitResetAt(v)
		return nil
	case account.FieldOverloadUntil:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOverloadUntil(v)
		return nil
	case account.FieldSessionWindowStart:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionWindowStart(v)
		return nil
	case account.FieldSessionWindowEnd:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionWindowEnd(v)
		return nil
	case account.FieldSessionWindowStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionWindowStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountMutation) AddedFields() []string {
	var fields []string
	if m.addconcurrency != nil {
		fields = append(fields, account.FieldConcurrency)
	}
	if m.addpriority != nil {
		fields = append(fields, account.FieldPriority)
	}
	if m.addrate_multiplier != nil {
		fields = append(fields, account.FieldRateMultiplier)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case account.FieldConcurrency:
		return m.AddedConcurrency()
	case account.FieldPriority:
		return m.AddedPriority()
	case account.FieldRateMultiplier:
		return m.AddedRateMultiplier()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case account.FieldConcurrency:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddConcurrency(v)
		return nil
	case account.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriority(v)
		return nil
	case account.FieldRateMultiplier:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRateMultiplier(v)
		return nil
	}
	return fmt.Errorf("unknown Account numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(account.FieldDeletedAt) {
		fields = append(fields, account.FieldDeletedAt)
	}
	if m.FieldCleared(account.FieldNotes) {
		fields = append(fields, account.FieldNotes)
	}
	if m.FieldCleared(account.FieldProxyID) {
		fields = append(fields, account.FieldProxyID)
	}
	if m.FieldCleared(account.FieldErrorMessage) {
		fields = append(fields, account.FieldErrorMessage)
	}
	if m.FieldCleared(account.FieldLastUsedAt) {
		fields = append(fields, account.FieldLastUsedAt)
	}
	if m.FieldCleared(account.FieldExpiresAt) {
		fields = append(fields, account.FieldExpiresAt)
	}
	if m.FieldCleared(account.FieldRateLimitedAt) {
		fields = append(fields, account.FieldRateLimitedAt)
	}
	if m.FieldCleared(account.FieldRateLimitResetAt) {
		fields = append(fields, account.FieldRateLimitResetAt)
	}
	if m.FieldCleared(account.FieldOverloadUntil) {
		fields = append(fields, account.FieldOverloadUntil)
	}
	if m.FieldCleared(account.FieldSessionWindowStart) {
		fields = append(fields, account.FieldSessionWindowStart)
	}
	if m.FieldCleared(account.FieldSessionWindowEnd) {
		fields = append(fields, account.FieldSessionWindowEnd)
	}
	if m.FieldCleared(account.FieldSessionWindowStatus) {
		fields = append(fields, account.FieldSessionWindowStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountMutation) ClearField(name string) error {
	switch name {
	case account.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case account.FieldNotes:
		m.ClearNotes()
		return nil
	case account.FieldProxyID:
		m.ClearProxyID()
		return nil
	case account.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	case account.FieldLastUsedAt:
		m.ClearLastUsedAt()
		return nil
	case account.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	case account.FieldRateLimitedAt:
		m.ClearRateLimitedAt()
		return nil
	case account.FieldRateLimitResetAt:
		m.ClearRateLimitResetAt()
		return nil
	case account.FieldOverloadUntil:
		m.ClearOverloadUntil()
		return nil
	case account.FieldSessionWindowStart:
		m.ClearSessionWindowStart()
		return nil
	case account.FieldSessionWindowEnd:
		m.ClearSessionWindowEnd()
		return nil
	case account.FieldSessionWindowStatus:
		m.ClearSessionWindowStatus()
		return nil
	}
	return fmt.Errorf("unknown Account nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountMutation) ResetField(name string) error {
	switch name {
	case account.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case account.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case account.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case account.FieldName:
		m.ResetName()
		return nil
	case account.FieldNotes:
		m.ResetNotes()
		return nil
	case account.FieldPlatform:
		m.ResetPlatform()
		return nil
	case account.FieldType:
		m.ResetType()
		return nil
	case account.FieldCredentials:
		m.ResetCredentials()
		return nil
	case account.FieldExtra:
		m.ResetExtra()
		return nil
	case account.FieldProxyID:
		m.ResetProxyID()
		return nil
	case account.FieldConcurrency:
		m.ResetConcurrency()
		return nil
	case account.FieldPriority:
		m.ResetPriority()
		return nil
	case account.FieldRateMultiplier:
		m.ResetRateMultiplier()
		return nil
	case account.FieldStatus:
		m.ResetStatus()
		return nil
	case account.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case account.FieldLastUsedAt:
		m.ResetLastUsedAt()
		return nil
	case account.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case account.FieldAutoPauseOnExpired:
		m.ResetAutoPauseOnExpired()
		return nil
	case account.FieldSchedulable:
		m.ResetSchedulable()
		return nil
	case account.FieldRateLimitedAt:
		m.ResetRateLimitedAt()
		return nil
	case account.FieldRateLimitResetAt:
		m.ResetRateLimitResetAt()
		return nil
	case account.FieldOverloadUntil:
		m.ResetOverloadUntil()
		return nil
	case account.FieldSessionWindowStart:
		m.ResetSessionWindowStart()
		return nil
	case account.FieldSessionWindowEnd:
		m.ResetSessionWindowEnd()
		return nil
	case account.FieldSessionWindowStatus:
		m.ResetSessionWindowStatus()
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.groups != nil {
		edges = append(edges, account.EdgeGroups)
	}
	if m.proxy != nil {
		edges = append(edges, account.EdgeProxy)
	}
	if m.usage_logs != nil {
		edges = append(edges, account.EdgeUsageLogs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case account.EdgeGroups:
		ids := make([]ent.Value, 0, len(m.groups))
		for id := range m.groups {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeProxy:
		if id := m.proxy; id != nil {
			return []ent.Value{*id}
		}
	case account.EdgeUsageLogs:
		ids := make([]ent.Value, 0, len(m.usage_logs))
		for id := range m.usage_logs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedgroups != nil {
		edges = append(edges, account.EdgeGroups)
	}
	if m.removedusage_logs != nil {
		edges = append(edges, account.EdgeUsageLogs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case account.EdgeGroups:
		ids := make([]ent.Value, 0, len(m.removedgroups))
		for id := range m.removedgroups {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeUsageLogs:
		ids := make([]ent.Value, 0, len(m.removedusage_logs))
		for id := range m.removedusage_logs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedgroups {
		edges = append(edges, account.EdgeGroups)
	}
	if m.clearedproxy {
		edges = append(edges, account.EdgeProxy)
	}
	if m.clearedusage_logs {
		edges = append(edges, account.EdgeUsageLogs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountMutation) EdgeCleared(name string) bool {
	switch name {
	case account.EdgeGroups:
		return m.clearedgroups
	case account.EdgeProxy:
		return m.clearedproxy
	case account.EdgeUsageLogs:
		return m.clearedusage_logs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountMutation) ClearEdge(name string) error {
	switch name {
	case account.EdgeProxy:
		m.ClearProxy()
		return nil
	}
	return fmt.Errorf("unknown Account unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountMutation) ResetEdge(name string) error {
	switch name {
	case account.EdgeGroups:
		m.ResetGroups()
		return nil
	case account.EdgeProxy:
		m.ResetProxy()
		return nil
	case account.EdgeUsageLogs:
		m.ResetUsageLogs()
		return nil
	}
	return fmt.Errorf("unknown Account edge %s", name)
}

// AccountGroupMutation represents an operation that mutates the AccountGroup nodes in the graph.
type AccountGroupMutation struct {
	config
	op             Op
	typ            string
	priority       *int
	addpriority    *int
	created_at     *time.Time
	clearedFields  map[string]struct{}
	account        *int64
	clearedaccount bool
	group          *int64
	clearedgroup   bool
	done           bool
	oldValue       func(context.Context) (*AccountGroup, error)
	predicates     []predicate.AccountGroup
}

var _ ent.Mutation = (*AccountGroupMutation)(nil)

// accountgroupOption allows management of the mutation configuration using functional options.
type accountgroupOption func(*AccountGroupMutation)

// newAccountGroupMutation creates new mutation for the AccountGroup entity.
func newAccountGroupMutation(c config, op Op, opts ...accountgroupOption) *AccountGroupMutation {
	m := &AccountGroupMutation{
		config:        c,
		op:            op,
		typ:           TypeAccountGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetAccountID sets the "account_id" field.
func (m *AccountGroupMutation) SetAccountID(i int64) {
	m.account = &i
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *AccountGroupMutation) AccountID() (r int64, exists bool) {
	v := m.account
	if v == nil {
		return
	}
	return *v, true
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *AccountGroupMutation) ResetAccountID() {
	m.account = nil
}

// SetGroupID sets the "group_id" field.
func (m *AccountGroupMutation) SetGroupID(i int64) {
	m.group = &i
}

// GroupID returns the value of the "group_id" field in the mutation.
func (m *AccountGroupMutation) GroupID() (r int64, exists bool) {
	v := m.group
	if v == nil {
		return
	}
	return *v, true
}

// ResetGroupID resets all changes to the "group_id" field.
func (m *AccountGroupMutation) ResetGroupID() {
	m.group = nil
}

// SetPriority sets the "priority" field.
func (m *AccountGroupMutation) SetPriority(i int) {
	m.priority = &i
	m.addpriority = nil
}

// Priority returns the value of the "priority" field in the mutation.
func (m *AccountGroupMutation) Priority() (r int, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// AddPriority adds i to the "priority" field.
func (m *AccountGroupMutation) AddPriority(i int) {
	if m.addpriority != nil {
		*m.addpriority += i
	} else {
		m.addpriority = &i
	}
}

// AddedPriority returns the value that was added to the "priority" field in this mutation.
func (m *AccountGroupMutation) AddedPriority() (r int, exists bool) {
	v := m.addpriority
	if v == nil {
		return
	}
	return *v, true
}

// ResetPriority resets all changes to the "priority" field.
func (m *AccountGroupMutation) ResetPriority() {
	m.priority = nil
	m.addpriority = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AccountGroupMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AccountGroupMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AccountGroupMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearAccount clears the "account" edge to the Account entity.
func (m *AccountGroupMutation) ClearAccount() {
	m.clearedaccount = true
	m.clearedFields[accountgroup.FieldAccountID] = struct{}{}
}

// AccountCleared reports if the "account" edge to the Account entity was cleared.
func (m *AccountGroupMutation) AccountCleared() bool {
	return m.clearedaccount
}

// AccountIDs returns the "account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountID instead. It exists only for internal usage by the builders.
func (m *AccountGroupMutation) AccountIDs() (ids []int64) {
	if id := m.account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccount resets all changes to the "account" edge.
func (m *AccountGroupMutation) ResetAccount() {
	m.account = nil
	m.clearedaccount = false
}

// ClearGroup clears the "group" edge to the Group entity.
func (m *AccountGroupMutation) ClearGroup() {
	m.clearedgroup = true
	m.clearedFields[accountgroup.FieldGroupID] = struct{}{}
}

// GroupCleared reports if the "group" edge to the Group entity was cleared.
func (m *AccountGroupMutation) GroupCleared() bool {
	return m.clearedgroup
}

// GroupIDs returns the "group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupID instead. It exists only for internal usage by the builders.
func (m *AccountGroupMutation) GroupIDs() (ids []int64) {
	if id := m.group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroup resets all changes to the "group" edge.
func (m *AccountGroupMutation) ResetGroup() {
	m.group = nil
	m.clearedgroup = false
}

// Where appends a list predicates to the AccountGroupMutation builder.
func (m *AccountGroupMutation) Where(ps ...predicate.AccountGroup) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AccountGroupMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AccountGroupMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AccountGroup, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AccountGroupMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AccountGroupMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AccountGroup).
func (m *AccountGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountGroupMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.account != nil {
		fields = append(fields, accountgroup.FieldAccountID)
	}
	if m.group != nil {
		fields = append(fields, accountgroup.FieldGroupID)
	}
	if m.priority != nil {
		fields = append(fields, accountgroup.FieldPriority)
	}
	if m.created_at != nil {
		fields = append(fields, accountgroup.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case accountgroup.FieldAccountID:
		return m.AccountID()
	case accountgroup.FieldGroupID:
		return m.GroupID()
	case accountgroup.FieldPriority:
		return m.Priority()
	case accountgroup.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, errors.New("edge schema AccountGroup does not support getting old values")
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case accountgroup.FieldAccountID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case accountgroup.FieldGroupID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupID(v)
		return nil
	case accountgroup.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case accountgroup.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AccountGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountGroupMutation) AddedFields() []string {
	var fields []string
	if m.addpriority != nil {
		fields = append(fields, accountgroup.FieldPriority)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountGroupMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case accountgroup.FieldPriority:
		return m.AddedPriority()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	case accountgroup.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriority(v)
		return nil
	}
	return fmt.Errorf("unknown AccountGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountGroupMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountGroupMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AccountGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountGroupMutation) ResetField(name string) error {
	switch name {
	case accountgroup.FieldAccountID:
		m.ResetAccountID()
		return nil
	case accountgroup.FieldGroupID:
		m.ResetGroupID()
		return nil
	case accountgroup.FieldPriority:
		m.ResetPriority()
		return nil
	case accountgroup.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown AccountGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.account != nil {
		edges = append(edges, accountgroup.EdgeAccount)
	}
	if m.group != nil {
		edges = append(edges, accountgroup.EdgeGroup)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountGroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case accountgroup.EdgeAccount:
		if id := m.account; id != nil {
			return []ent.Value{*id}
		}
	case accountgroup.EdgeGroup:
		if id := m.group; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountGroupMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedaccount {
		edges = append(edges, accountgroup.EdgeAccount)
	}
	if m.clearedgroup {
		edges = append(edges, accountgroup.EdgeGroup)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountGroupMutation) EdgeCleared(name string) bool {
	switch name {
	case accountgroup.EdgeAccount:
		return m.clearedaccount
	case accountgroup.EdgeGroup:
		return m.clearedgroup
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountGroupMutation) ClearEdge(name string) error {
	switch name {
	case accountgroup.EdgeAccount:
		m.ClearAccount()
		return nil
	case accountgroup.EdgeGroup:
		m.ClearGroup()
		return nil
	}
	return fmt.Errorf("unknown AccountGroup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountGroupMutation) ResetEdge(name string) error {
	switch name {
	case accountgroup.EdgeAccount:
		m.ResetAccount()
		return nil
	case accountgroup.EdgeGroup:
		m.ResetGroup()
		return nil
	}
	return fmt.Errorf("unknown AccountGroup edge %s", name)
}

// AnnouncementMutation represents an operation that mutates the Announcement nodes in the graph.
type AnnouncementMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	title         *string
	content       *string
	status        *string
	targeting     *domain.AnnouncementTargeting
	starts_at     *time.Time
	ends_at       *time.Time
	created_by    *int64
	addcreated_by *int64
	updated_by    *int64
	addupdated_by *int64
	created_at    *time.Time
	updated_at    *time.Time
	owner_id      *int64
	addowner_id   *int64
	clearedFields map[string]struct{}
	reads         map[int64]struct{}
	removedreads  map[int64]struct{}
	clearedreads  bool
	done          bool
	oldValue      func(context.Context) (*Announcement, error)
	predicates    []predicate.Announcement
}

var _ ent.Mutation = (*AnnouncementMutation)(nil)

// announcementOption allows management of the mutation configuration using functional options.
type announcementOption func(*AnnouncementMutation)

// newAnnouncementMutation creates new mutation for the Announcement entity.
func newAnnouncementMutation(c config, op Op, opts ...announcementOption) *AnnouncementMutation {
	m := &AnnouncementMutation{
		config:        c,
		op:            op,
		typ:           TypeAnnouncement,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAnnouncementID sets the ID field of the mutation.
func withAnnouncementID(id int64) announcementOption {
	return func(m *AnnouncementMutation) {
		var (
			err   error
			once  sync.Once
			value *Announcement
		)
		m.oldValue = func(ctx context.Context) (*Announcement, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Announcement.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAnnouncement sets the old Announcement of the mutation.
func withAnnouncement(node *Announcement) announcementOption {
	return func(m *AnnouncementMutation) {
		m.oldValue = func(context.Context) (*Announcement, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AnnouncementMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AnnouncementMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AnnouncementMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AnnouncementMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Announcement.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *AnnouncementMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *AnnouncementMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Announcement entity.
// If the Announcement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnnouncementMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *AnnouncementMutation) ResetTitle() {
	m.title = nil
}

// SetContent sets the "content" field.
func (m *AnnouncementMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *AnnouncementMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Announcement entity.
// If the Announcement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnnouncementMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *AnnouncementMutation) ResetContent() {
	m.content = nil
}

// SetStatus sets the "status" field.
func (m *AnnouncementMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *AnnouncementMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Announcement entity.
// If the Announcement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnnouncementMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *AnnouncementMutation) ResetStatus() {
	m.status = nil
}

// SetTargeting sets the "targeting" field.
func (m *AnnouncementMutation) SetTargeting(dt domain.AnnouncementTargeting) {
	m.targeting = &dt
}

// Targeting returns the value of the "targeting" field in the mutation.
func (m *AnnouncementMutation) Targeting() (r domain.AnnouncementTargeting, exists bool) {
	v := m.targeting
	if v == nil {
		return
	}
	return *v, true
}

// OldTargeting returns the old "targeting" field's value of the Announcement entity.
// If the Announcement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnnouncementMutation) OldTargeting(ctx context.Context) (v domain.AnnouncementTargeting, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargeting is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargeting requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargeting: %w", err)
	}
	return oldValue.Targeting, nil
}

// ClearTargeting clears the value of the "targeting" field.
func (m *AnnouncementMutation) ClearTargeting() {
	m.targeting = nil
	m.clearedFields[announcement.FieldTargeting] = struct{}{}
}

// TargetingCleared returns if the "targeting" field was cleared in this mutation.
func (m *AnnouncementMutation) TargetingCleared() bool {
	_, ok := m.clearedFields[announcement.FieldTargeting]
	return ok
}

// ResetTargeting resets all changes to the "targeting" field.
func (m *AnnouncementMutation) ResetTargeting() {
	m.targeting = nil
	delete(m.clearedFields, announcement.FieldTargeting)
}

// SetStartsAt sets the "starts_at" field.
func (m *AnnouncementMutation) SetStartsAt(t time.Time) {
	m.starts_at = &t
}

// StartsAt returns the value of the "starts_at" field in the mutation.
func (m *AnnouncementMutation) StartsAt() (r time.Time, exists bool) {
	v := m.starts_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartsAt returns the old "starts_at" field's value of the Announcement entity.
// If the Announcement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnnouncementMutation) OldStartsAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartsAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartsAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartsAt: %w", err)
	}
	return oldValue.StartsAt, nil
}

// ClearStartsAt clears the value of the "starts_at" field.
func (m *AnnouncementMutation) ClearStartsAt() {
	m.starts_at = nil
	m.clearedFields[announcement.FieldStartsAt] = struct{}{}
}

// StartsAtCleared returns if the "starts_at" field was cleared in this mutation.
func (m *AnnouncementMutation) StartsAtCleared() bool {
	_, ok := m.clearedFields[announcement.FieldStartsAt]
	return ok
}

// ResetStartsAt resets all changes to the "starts_at" field.
func (m *AnnouncementMutation) ResetStartsAt() {
	m.starts_at = nil
	delete(m.clearedFields, announcement.FieldStartsAt)
}

// SetEndsAt sets the "ends_at" field.
func (m *AnnouncementMutation) SetEndsAt(t time.Time) {
	m.ends_at = &t
}

// EndsAt returns the value of the "ends_at" field in the mutation.
func (m *AnnouncementMutation) EndsAt() (r time.Time, exists bool) {
	v := m.ends_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndsAt returns the old "ends_at" field's value of the Announcement entity.
// If the Announcement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnnouncementMutation) OldEndsAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndsAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndsAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndsAt: %w", err)
	}
	return oldValue.EndsAt, nil
}

// ClearEndsAt clears the value of the "ends_at" field.
func (m *AnnouncementMutation) ClearEndsAt() {
	m.ends_at = nil
	m.clearedFields[announcement.FieldEndsAt] = struct{}{}
}

// EndsAtCleared returns if the "ends_at" field was cleared in this mutation.
func (m *AnnouncementMutation) EndsAtCleared() bool {
	_, ok := m.clearedFields[announcement.FieldEndsAt]
	return ok
}

// ResetEndsAt resets all changes to the "ends_at" field.
func (m *AnnouncementMutation) ResetEndsAt() {
	m.ends_at = nil
	delete(m.clearedFields, announcement.FieldEndsAt)
}

// SetCreatedBy sets the "created_by" field.
func (m *AnnouncementMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *AnnouncementMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Announcement entity.
// If the Announcement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnnouncementMutation) OldCreatedBy(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *AnnouncementMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *AnnouncementMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *AnnouncementMutation) ClearCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	m.clearedFields[announcement.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *AnnouncementMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[announcement.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *AnnouncementMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	delete(m.clearedFields, announcement.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *AnnouncementMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *AnnouncementMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Announcement entity.
// If the Announcement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnnouncementMutation) OldUpdatedBy(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *AnnouncementMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *AnnouncementMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *AnnouncementMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[announcement.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *AnnouncementMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[announcement.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *AnnouncementMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, announcement.FieldUpdatedBy)
}

// SetCreatedAt sets the "created_at" field.
func (m *AnnouncementMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AnnouncementMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Announcement entity.
// If the Announcement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnnouncementMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AnnouncementMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AnnouncementMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AnnouncementMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Announcement entity.
// If the Announcement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnnouncementMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AnnouncementMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetOwnerID sets the "owner_id" field.
func (m *AnnouncementMutation) SetOwnerID(i int64) {
	m.owner_id = &i
	m.addowner_id = nil
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *AnnouncementMutation) OwnerID() (r int64, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the Announcement entity.
// If the Announcement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnnouncementMutation) OldOwnerID(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// AddOwnerID adds i to the "owner_id" field.
func (m *AnnouncementMutation) AddOwnerID(i int64) {
	if m.addowner_id != nil {
		*m.addowner_id += i
	} else {
		m.addowner_id = &i
	}
}

// AddedOwnerID returns the value that was added to the "owner_id" field in this mutation.
func (m *AnnouncementMutation) AddedOwnerID() (r int64, exists bool) {
	v := m.addowner_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *AnnouncementMutation) ClearOwnerID() {
	m.owner_id = nil
	m.addowner_id = nil
	m.clearedFields[announcement.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *AnnouncementMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[announcement.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *AnnouncementMutation) ResetOwnerID() {
	m.owner_id = nil
	m.addowner_id = nil
	delete(m.clearedFields, announcement.FieldOwnerID)
}

// AddReadIDs adds the "reads" edge to the AnnouncementRead entity by ids.
func (m *AnnouncementMutation) AddReadIDs(ids ...int64) {
	if m.reads == nil {
		m.reads = make(map[int64]struct{})
	}
	for i := range ids {
		m.reads[ids[i]] = struct{}{}
	}
}

// ClearReads clears the "reads" edge to the AnnouncementRead entity.
func (m *AnnouncementMutation) ClearReads() {
	m.clearedreads = true
}

// ReadsCleared reports if the "reads" edge to the AnnouncementRead entity was cleared.
func (m *AnnouncementMutation) ReadsCleared() bool {
	return m.clearedreads
}

// RemoveReadIDs removes the "reads" edge to the AnnouncementRead entity by IDs.
func (m *AnnouncementMutation) RemoveReadIDs(ids ...int64) {
	if m.removedreads == nil {
		m.removedreads = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.reads, ids[i])
		m.removedreads[ids[i]] = struct{}{}
	}
}

// RemovedReads returns the removed IDs of the "reads" edge to the AnnouncementRead entity.
func (m *AnnouncementMutation) RemovedReadsIDs() (ids []int64) {
	for id := range m.removedreads {
		ids = append(ids, id)
	}
	return
}

// ReadsIDs returns the "reads" edge IDs in the mutation.
func (m *AnnouncementMutation) ReadsIDs() (ids []int64) {
	for id := range m.reads {
		ids = append(ids, id)
	}
	return
}

// ResetReads resets all changes to the "reads" edge.
func (m *AnnouncementMutation) ResetReads() {
	m.reads = nil
	m.clearedreads = false
	m.removedreads = nil
}

// Where appends a list predicates to the AnnouncementMutation builder.
func (m *AnnouncementMutation) Where(ps ...predicate.Announcement) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AnnouncementMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AnnouncementMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Announcement, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AnnouncementMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AnnouncementMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Announcement).
func (m *AnnouncementMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AnnouncementMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.title != nil {
		fields = append(fields, announcement.FieldTitle)
	}
	if m.content != nil {
		fields = append(fields, announcement.FieldContent)
	}
	if m.status != nil {
		fields = append(fields, announcement.FieldStatus)
	}
	if m.targeting != nil {
		fields = append(fields, announcement.FieldTargeting)
	}
	if m.starts_at != nil {
		fields = append(fields, announcement.FieldStartsAt)
	}
	if m.ends_at != nil {
		fields = append(fields, announcement.FieldEndsAt)
	}
	if m.created_by != nil {
		fields = append(fields, announcement.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, announcement.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, announcement.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, announcement.FieldUpdatedAt)
	}
	if m.owner_id != nil {
		fields = append(fields, announcement.FieldOwnerID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AnnouncementMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case announcement.FieldTitle:
		return m.Title()
	case announcement.FieldContent:
		return m.Content()
	case announcement.FieldStatus:
		return m.Status()
	case announcement.FieldTargeting:
		return m.Targeting()
	case announcement.FieldStartsAt:
		return m.StartsAt()
	case announcement.FieldEndsAt:
		return m.EndsAt()
	case announcement.FieldCreatedBy:
		return m.CreatedBy()
	case announcement.FieldUpdatedBy:
		return m.UpdatedBy()
	case announcement.FieldCreatedAt:
		return m.CreatedAt()
	case announcement.FieldUpdatedAt:
		return m.UpdatedAt()
	case announcement.FieldOwnerID:
		return m.OwnerID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AnnouncementMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case announcement.FieldTitle:
		return m.OldTitle(ctx)
	case announcement.FieldContent:
		return m.OldContent(ctx)
	case announcement.FieldStatus:
		return m.OldStatus(ctx)
	case announcement.FieldTargeting:
		return m.OldTargeting(ctx)
	case announcement.FieldStartsAt:
		return m.OldStartsAt(ctx)
	case announcement.FieldEndsAt:
		return m.OldEndsAt(ctx)
	case announcement.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case announcement.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case announcement.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case announcement.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case announcement.FieldOwnerID:
		return m.OldOwnerID(ctx)
	}
	return nil, fmt.Errorf("unknown Announcement field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AnnouncementMutation) SetField(name string, value ent.Value) error {
	switch name {
	case announcement.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case announcement.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case announcement.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case announcement.FieldTargeting:
		v, ok := value.(domain.AnnouncementTargeting)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargeting(v)
		return nil
	case announcement.FieldStartsAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartsAt(v)
		return nil
	case announcement.FieldEndsAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndsAt(v)
		return nil
	case announcement.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case announcement.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case announcement.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case announcement.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case announcement.FieldOwnerID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	}
	return fmt.Errorf("unknown Announcement field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AnnouncementMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, announcement.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, announcement.FieldUpdatedBy)
	}
	if m.addowner_id != nil {
		fields = append(fields, announcement.FieldOwnerID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AnnouncementMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case announcement.FieldCreatedBy:
		return m.AddedCreatedBy()
	case announcement.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case announcement.FieldOwnerID:
		return m.AddedOwnerID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AnnouncementMutation) AddField(name string, value ent.Value) error {
	switch name {
	case announcement.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case announcement.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case announcement.FieldOwnerID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOwnerID(v)
		return nil
	}
	return fmt.Errorf("unknown Announcement numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AnnouncementMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(announcement.FieldTargeting) {
		fields = append(fields, announcement.FieldTargeting)
	}
	if m.FieldCleared(announcement.FieldStartsAt) {
		fields = append(fields, announcement.FieldStartsAt)
	}
	if m.FieldCleared(announcement.FieldEndsAt) {
		fields = append(fields, announcement.FieldEndsAt)
	}
	if m.FieldCleared(announcement.FieldCreatedBy) {
		fields = append(fields, announcement.FieldCreatedBy)
	}
	if m.FieldCleared(announcement.FieldUpdatedBy) {
		fields = append(fields, announcement.FieldUpdatedBy)
	}
	if m.FieldCleared(announcement.FieldOwnerID) {
		fields = append(fields, announcement.FieldOwnerID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AnnouncementMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AnnouncementMutation) ClearField(name string) error {
	switch name {
	case announcement.FieldTargeting:
		m.ClearTargeting()
		return nil
	case announcement.FieldStartsAt:
		m.ClearStartsAt()
		return nil
	case announcement.FieldEndsAt:
		m.ClearEndsAt()
		return nil
	case announcement.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case announcement.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case announcement.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	}
	return fmt.Errorf("unknown Announcement nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AnnouncementMutation) ResetField(name string) error {
	switch name {
	case announcement.FieldTitle:
		m.ResetTitle()
		return nil
	case announcement.FieldContent:
		m.ResetContent()
		return nil
	case announcement.FieldStatus:
		m.ResetStatus()
		return nil
	case announcement.FieldTargeting:
		m.ResetTargeting()
		return nil
	case announcement.FieldStartsAt:
		m.ResetStartsAt()
		return nil
	case announcement.FieldEndsAt:
		m.ResetEndsAt()
		return nil
	case announcement.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case announcement.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case announcement.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case announcement.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case announcement.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	}
	return fmt.Errorf("unknown Announcement field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AnnouncementMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.reads != nil {
		edges = append(edges, announcement.EdgeReads)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AnnouncementMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case announcement.EdgeReads:
		ids := make([]ent.Value, 0, len(m.reads))
		for id := range m.reads {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AnnouncementMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedreads != nil {
		edges = append(edges, announcement.EdgeReads)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AnnouncementMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case announcement.EdgeReads:
		ids := make([]ent.Value, 0, len(m.removedreads))
		for id := range m.removedreads {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AnnouncementMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedreads {
		edges = append(edges, announcement.EdgeReads)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AnnouncementMutation) EdgeCleared(name string) bool {
	switch name {
	case announcement.EdgeReads:
		return m.clearedreads
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AnnouncementMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Announcement unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AnnouncementMutation) ResetEdge(name string) error {
	switch name {
	case announcement.EdgeReads:
		m.ResetReads()
		return nil
	}
	return fmt.Errorf("unknown Announcement edge %s", name)
}

// AnnouncementReadMutation represents an operation that mutates the AnnouncementRead nodes in the graph.
type AnnouncementReadMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int64
	read_at             *time.Time
	created_at          *time.Time
	clearedFields       map[string]struct{}
	announcement        *int64
	clearedannouncement bool
	user                *int64
	cleareduser         bool
	done                bool
	oldValue            func(context.Context) (*AnnouncementRead, error)
	predicates          []predicate.AnnouncementRead
}

var _ ent.Mutation = (*AnnouncementReadMutation)(nil)

// announcementreadOption allows management of the mutation configuration using functional options.
type announcementreadOption func(*AnnouncementReadMutation)

// newAnnouncementReadMutation creates new mutation for the AnnouncementRead entity.
func newAnnouncementReadMutation(c config, op Op, opts ...announcementreadOption) *AnnouncementReadMutation {
	m := &AnnouncementReadMutation{
		config:        c,
		op:            op,
		typ:           TypeAnnouncementRead,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAnnouncementReadID sets the ID field of the mutation.
func withAnnouncementReadID(id int64) announcementreadOption {
	return func(m *AnnouncementReadMutation) {
		var (
			err   error
			once  sync.Once
			value *AnnouncementRead
		)
		m.oldValue = func(ctx context.Context) (*AnnouncementRead, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AnnouncementRead.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAnnouncementRead sets the old AnnouncementRead of the mutation.
func withAnnouncementRead(node *AnnouncementRead) announcementreadOption {
	return func(m *AnnouncementReadMutation) {
		m.oldValue = func(context.Context) (*AnnouncementRead, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AnnouncementReadMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AnnouncementReadMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AnnouncementReadMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AnnouncementReadMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AnnouncementRead.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAnnouncementID sets the "announcement_id" field.
func (m *AnnouncementReadMutation) SetAnnouncementID(i int64) {
	m.announcement = &i
}

// AnnouncementID returns the value of the "announcement_id" field in the mutation.
func (m *AnnouncementReadMutation) AnnouncementID() (r int64, exists bool) {
	v := m.announcement
	if v == nil {
		return
	}
	return *v, true
}

// OldAnnouncementID returns the old "announcement_id" field's value of the AnnouncementRead entity.
// If the AnnouncementRead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnnouncementReadMutation) OldAnnouncementID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnnouncementID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnnouncementID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnnouncementID: %w", err)
	}
	return oldValue.AnnouncementID, nil
}

// ResetAnnouncementID resets all changes to the "announcement_id" field.
func (m *AnnouncementReadMutation) ResetAnnouncementID() {
	m.announcement = nil
}

// SetUserID sets the "user_id" field.
func (m *AnnouncementReadMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AnnouncementReadMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the AnnouncementRead entity.
// If the AnnouncementRead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnnouncementReadMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AnnouncementReadMutation) ResetUserID() {
	m.user = nil
}

// SetReadAt sets the "read_at" field.
func (m *AnnouncementReadMutation) SetReadAt(t time.Time) {
	m.read_at = &t
}

// ReadAt returns the value of the "read_at" field in the mutation.
func (m *AnnouncementReadMutation) ReadAt() (r time.Time, exists bool) {
	v := m.read_at
	if v == nil {
		return
	}
	return *v, true
}

// OldReadAt returns the old "read_at" field's value of the AnnouncementRead entity.
// If the AnnouncementRead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnnouncementReadMutation) OldReadAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReadAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReadAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReadAt: %w", err)
	}
	return oldValue.ReadAt, nil
}

// ResetReadAt resets all changes to the "read_at" field.
func (m *AnnouncementReadMutation) ResetReadAt() {
	m.read_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AnnouncementReadMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AnnouncementReadMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AnnouncementRead entity.
// If the AnnouncementRead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnnouncementReadMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AnnouncementReadMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearAnnouncement clears the "announcement" edge to the Announcement entity.
func (m *AnnouncementReadMutation) ClearAnnouncement() {
	m.clearedannouncement = true
	m.clearedFields[announcementread.FieldAnnouncementID] = struct{}{}
}

// AnnouncementCleared reports if the "announcement" edge to the Announcement entity was cleared.
func (m *AnnouncementReadMutation) AnnouncementCleared() bool {
	return m.clearedannouncement
}

// AnnouncementIDs returns the "announcement" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AnnouncementID instead. It exists only for internal usage by the builders.
func (m *AnnouncementReadMutation) AnnouncementIDs() (ids []int64) {
	if id := m.announcement; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAnnouncement resets all changes to the "announcement" edge.
func (m *AnnouncementReadMutation) ResetAnnouncement() {
	m.announcement = nil
	m.clearedannouncement = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *AnnouncementReadMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[announcementread.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *AnnouncementReadMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *AnnouncementReadMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *AnnouncementReadMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the AnnouncementReadMutation builder.
func (m *AnnouncementReadMutation) Where(ps ...predicate.AnnouncementRead) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AnnouncementReadMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AnnouncementReadMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AnnouncementRead, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AnnouncementReadMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AnnouncementReadMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AnnouncementRead).
func (m *AnnouncementReadMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AnnouncementReadMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.announcement != nil {
		fields = append(fields, announcementread.FieldAnnouncementID)
	}
	if m.user != nil {
		fields = append(fields, announcementread.FieldUserID)
	}
	if m.read_at != nil {
		fields = append(fields, announcementread.FieldReadAt)
	}
	if m.created_at != nil {
		fields = append(fields, announcementread.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AnnouncementReadMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case announcementread.FieldAnnouncementID:
		return m.AnnouncementID()
	case announcementread.FieldUserID:
		return m.UserID()
	case announcementread.FieldReadAt:
		return m.ReadAt()
	case announcementread.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AnnouncementReadMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case announcementread.FieldAnnouncementID:
		return m.OldAnnouncementID(ctx)
	case announcementread.FieldUserID:
		return m.OldUserID(ctx)
	case announcementread.FieldReadAt:
		return m.OldReadAt(ctx)
	case announcementread.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown AnnouncementRead field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AnnouncementReadMutation) SetField(name string, value ent.Value) error {
	switch name {
	case announcementread.FieldAnnouncementID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnnouncementID(v)
		return nil
	case announcementread.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case announcementread.FieldReadAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReadAt(v)
		return nil
	case announcementread.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown AnnouncementRead field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AnnouncementReadMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AnnouncementReadMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AnnouncementReadMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AnnouncementRead numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AnnouncementReadMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AnnouncementReadMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AnnouncementReadMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AnnouncementRead nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AnnouncementReadMutation) ResetField(name string) error {
	switch name {
	case announcementread.FieldAnnouncementID:
		m.ResetAnnouncementID()
		return nil
	case announcementread.FieldUserID:
		m.ResetUserID()
		return nil
	case announcementread.FieldReadAt:
		m.ResetReadAt()
		return nil
	case announcementread.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown AnnouncementRead field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AnnouncementReadMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.announcement != nil {
		edges = append(edges, announcementread.EdgeAnnouncement)
	}
	if m.user != nil {
		edges = append(edges, announcementread.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AnnouncementReadMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case announcementread.EdgeAnnouncement:
		if id := m.announcement; id != nil {
			return []ent.Value{*id}
		}
	case announcementread.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AnnouncementReadMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AnnouncementReadMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AnnouncementReadMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedannouncement {
		edges = append(edges, announcementread.EdgeAnnouncement)
	}
	if m.cleareduser {
		edges = append(edges, announcementread.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AnnouncementReadMutation) EdgeCleared(name string) bool {
	switch name {
	case announcementread.EdgeAnnouncement:
		return m.clearedannouncement
	case announcementread.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AnnouncementReadMutation) ClearEdge(name string) error {
	switch name {
	case announcementread.EdgeAnnouncement:
		m.ClearAnnouncement()
		return nil
	case announcementread.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown AnnouncementRead unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AnnouncementReadMutation) ResetEdge(name string) error {
	switch name {
	case announcementread.EdgeAnnouncement:
		m.ResetAnnouncement()
		return nil
	case announcementread.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown AnnouncementRead edge %s", name)
}

// ChannelMutation represents an operation that mutates the Channel nodes in the graph.
type ChannelMutation struct {
	config
	op                Op
	typ               string
	id                *int64
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	name              *string
	description       *string
	platform          *string
	status            *string
	icon_url          *string
	website_url       *string
	balance_url       *string
	balance_method    *string
	balance_headers   *map[string]string
	balance_body      *string
	balance_path      *string
	balance_unit      *string
	cached_balance    *float64
	addcached_balance *float64
	last_check_at     *time.Time
	last_error        *string
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*Channel, error)
	predicates        []predicate.Channel
}

var _ ent.Mutation = (*ChannelMutation)(nil)

// channelOption allows management of the mutation configuration using functional options.
type channelOption func(*ChannelMutation)

// newChannelMutation creates new mutation for the Channel entity.
func newChannelMutation(c config, op Op, opts ...channelOption) *ChannelMutation {
	m := &ChannelMutation{
		config:        c,
		op:            op,
		typ:           TypeChannel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChannelID sets the ID field of the mutation.
func withChannelID(id int64) channelOption {
	return func(m *ChannelMutation) {
		var (
			err   error
			once  sync.Once
			value *Channel
		)
		m.oldValue = func(ctx context.Context) (*Channel, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Channel.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChannel sets the old Channel of the mutation.
func withChannel(node *Channel) channelOption {
	return func(m *ChannelMutation) {
		m.oldValue = func(context.Context) (*Channel, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChannelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChannelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChannelMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChannelMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Channel.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ChannelMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ChannelMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ChannelMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ChannelMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ChannelMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ChannelMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ChannelMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ChannelMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ChannelMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[channel.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ChannelMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[channel.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ChannelMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, channel.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *ChannelMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ChannelMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ChannelMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ChannelMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ChannelMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ChannelMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[channel.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ChannelMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[channel.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ChannelMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, channel.FieldDescription)
}

// SetPlatform sets the "platform" field.
func (m *ChannelMutation) SetPlatform(s string) {
	m.platform = &s
}

// Platform returns the value of the "platform" field in the mutation.
func (m *ChannelMutation) Platform() (r string, exists bool) {
	v := m.platform
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatform returns the old "platform" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldPlatform(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatform: %w", err)
	}
	return oldValue.Platform, nil
}

// ClearPlatform clears the value of the "platform" field.
func (m *ChannelMutation) ClearPlatform() {
	m.platform = nil
	m.clearedFields[channel.FieldPlatform] = struct{}{}
}

// PlatformCleared returns if the "platform" field was cleared in this mutation.
func (m *ChannelMutation) PlatformCleared() bool {
	_, ok := m.clearedFields[channel.FieldPlatform]
	return ok
}

// ResetPlatform resets all changes to the "platform" field.
func (m *ChannelMutation) ResetPlatform() {
	m.platform = nil
	delete(m.clearedFields, channel.FieldPlatform)
}

// SetStatus sets the "status" field.
func (m *ChannelMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ChannelMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ChannelMutation) ResetStatus() {
	m.status = nil
}

// SetIconURL sets the "icon_url" field.
func (m *ChannelMutation) SetIconURL(s string) {
	m.icon_url = &s
}

// IconURL returns the value of the "icon_url" field in the mutation.
func (m *ChannelMutation) IconURL() (r string, exists bool) {
	v := m.icon_url
	if v == nil {
		return
	}
	return *v, true
}

// OldIconURL returns the old "icon_url" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldIconURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIconURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIconURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIconURL: %w", err)
	}
	return oldValue.IconURL, nil
}

// ClearIconURL clears the value of the "icon_url" field.
func (m *ChannelMutation) ClearIconURL() {
	m.icon_url = nil
	m.clearedFields[channel.FieldIconURL] = struct{}{}
}

// IconURLCleared returns if the "icon_url" field was cleared in this mutation.
func (m *ChannelMutation) IconURLCleared() bool {
	_, ok := m.clearedFields[channel.FieldIconURL]
	return ok
}

// ResetIconURL resets all changes to the "icon_url" field.
func (m *ChannelMutation) ResetIconURL() {
	m.icon_url = nil
	delete(m.clearedFields, channel.FieldIconURL)
}

// SetWebsiteURL sets the "website_url" field.
func (m *ChannelMutation) SetWebsiteURL(s string) {
	m.website_url = &s
}

// WebsiteURL returns the value of the "website_url" field in the mutation.
func (m *ChannelMutation) WebsiteURL() (r string, exists bool) {
	v := m.website_url
	if v == nil {
		return
	}
	return *v, true
}

// OldWebsiteURL returns the old "website_url" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldWebsiteURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWebsiteURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWebsiteURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWebsiteURL: %w", err)
	}
	return oldValue.WebsiteURL, nil
}

// ClearWebsiteURL clears the value of the "website_url" field.
func (m *ChannelMutation) ClearWebsiteURL() {
	m.website_url = nil
	m.clearedFields[channel.FieldWebsiteURL] = struct{}{}
}

// WebsiteURLCleared returns if the "website_url" field was cleared in this mutation.
func (m *ChannelMutation) WebsiteURLCleared() bool {
	_, ok := m.clearedFields[channel.FieldWebsiteURL]
	return ok
}

// ResetWebsiteURL resets all changes to the "website_url" field.
func (m *ChannelMutation) ResetWebsiteURL() {
	m.website_url = nil
	delete(m.clearedFields, channel.FieldWebsiteURL)
}

// SetBalanceURL sets the "balance_url" field.
func (m *ChannelMutation) SetBalanceURL(s string) {
	m.balance_url = &s
}

// BalanceURL returns the value of the "balance_url" field in the mutation.
func (m *ChannelMutation) BalanceURL() (r string, exists bool) {
	v := m.balance_url
	if v == nil {
		return
	}
	return *v, true
}

// OldBalanceURL returns the old "balance_url" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldBalanceURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBalanceURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBalanceURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalanceURL: %w", err)
	}
	return oldValue.BalanceURL, nil
}

// ClearBalanceURL clears the value of the "balance_url" field.
func (m *ChannelMutation) ClearBalanceURL() {
	m.balance_url = nil
	m.clearedFields[channel.FieldBalanceURL] = struct{}{}
}

// BalanceURLCleared returns if the "balance_url" field was cleared in this mutation.
func (m *ChannelMutation) BalanceURLCleared() bool {
	_, ok := m.clearedFields[channel.FieldBalanceURL]
	return ok
}

// ResetBalanceURL resets all changes to the "balance_url" field.
func (m *ChannelMutation) ResetBalanceURL() {
	m.balance_url = nil
	delete(m.clearedFields, channel.FieldBalanceURL)
}

// SetBalanceMethod sets the "balance_method" field.
func (m *ChannelMutation) SetBalanceMethod(s string) {
	m.balance_method = &s
}

// BalanceMethod returns the value of the "balance_method" field in the mutation.
func (m *ChannelMutation) BalanceMethod() (r string, exists bool) {
	v := m.balance_method
	if v == nil {
		return
	}
	return *v, true
}

// OldBalanceMethod returns the old "balance_method" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldBalanceMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBalanceMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBalanceMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalanceMethod: %w", err)
	}
	return oldValue.BalanceMethod, nil
}

// ResetBalanceMethod resets all changes to the "balance_method" field.
func (m *ChannelMutation) ResetBalanceMethod() {
	m.balance_method = nil
}

// SetBalanceHeaders sets the "balance_headers" field.
func (m *ChannelMutation) SetBalanceHeaders(value map[string]string) {
	m.balance_headers = &value
}

// BalanceHeaders returns the value of the "balance_headers" field in the mutation.
func (m *ChannelMutation) BalanceHeaders() (r map[string]string, exists bool) {
	v := m.balance_headers
	if v == nil {
		return
	}
	return *v, true
}

// OldBalanceHeaders returns the old "balance_headers" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldBalanceHeaders(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBalanceHeaders is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBalanceHeaders requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalanceHeaders: %w", err)
	}
	return oldValue.BalanceHeaders, nil
}

// ClearBalanceHeaders clears the value of the "balance_headers" field.
func (m *ChannelMutation) ClearBalanceHeaders() {
	m.balance_headers = nil
	m.clearedFields[channel.FieldBalanceHeaders] = struct{}{}
}

// BalanceHeadersCleared returns if the "balance_headers" field was cleared in this mutation.
func (m *ChannelMutation) BalanceHeadersCleared() bool {
	_, ok := m.clearedFields[channel.FieldBalanceHeaders]
	return ok
}

// ResetBalanceHeaders resets all changes to the "balance_headers" field.
func (m *ChannelMutation) ResetBalanceHeaders() {
	m.balance_headers = nil
	delete(m.clearedFields, channel.FieldBalanceHeaders)
}

// SetBalanceBody sets the "balance_body" field.
func (m *ChannelMutation) SetBalanceBody(s string) {
	m.balance_body = &s
}

// BalanceBody returns the value of the "balance_body" field in the mutation.
func (m *ChannelMutation) BalanceBody() (r string, exists bool) {
	v := m.balance_body
	if v == nil {
		return
	}
	return *v, true
}

// OldBalanceBody returns the old "balance_body" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldBalanceBody(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBalanceBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBalanceBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalanceBody: %w", err)
	}
	return oldValue.BalanceBody, nil
}

// ClearBalanceBody clears the value of the "balance_body" field.
func (m *ChannelMutation) ClearBalanceBody() {
	m.balance_body = nil
	m.clearedFields[channel.FieldBalanceBody] = struct{}{}
}

// BalanceBodyCleared returns if the "balance_body" field was cleared in this mutation.
func (m *ChannelMutation) BalanceBodyCleared() bool {
	_, ok := m.clearedFields[channel.FieldBalanceBody]
	return ok
}

// ResetBalanceBody resets all changes to the "balance_body" field.
func (m *ChannelMutation) ResetBalanceBody() {
	m.balance_body = nil
	delete(m.clearedFields, channel.FieldBalanceBody)
}

// SetBalancePath sets the "balance_path" field.
func (m *ChannelMutation) SetBalancePath(s string) {
	m.balance_path = &s
}

// BalancePath returns the value of the "balance_path" field in the mutation.
func (m *ChannelMutation) BalancePath() (r string, exists bool) {
	v := m.balance_path
	if v == nil {
		return
	}
	return *v, true
}

// OldBalancePath returns the old "balance_path" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldBalancePath(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBalancePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBalancePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalancePath: %w", err)
	}
	return oldValue.BalancePath, nil
}

// ClearBalancePath clears the value of the "balance_path" field.
func (m *ChannelMutation) ClearBalancePath() {
	m.balance_path = nil
	m.clearedFields[channel.FieldBalancePath] = struct{}{}
}

// BalancePathCleared returns if the "balance_path" field was cleared in this mutation.
func (m *ChannelMutation) BalancePathCleared() bool {
	_, ok := m.clearedFields[channel.FieldBalancePath]
	return ok
}

// ResetBalancePath resets all changes to the "balance_path" field.
func (m *ChannelMutation) ResetBalancePath() {
	m.balance_path = nil
	delete(m.clearedFields, channel.FieldBalancePath)
}

// SetBalanceUnit sets the "balance_unit" field.
func (m *ChannelMutation) SetBalanceUnit(s string) {
	m.balance_unit = &s
}

// BalanceUnit returns the value of the "balance_unit" field in the mutation.
func (m *ChannelMutation) BalanceUnit() (r string, exists bool) {
	v := m.balance_unit
	if v == nil {
		return
	}
	return *v, true
}

// OldBalanceUnit returns the old "balance_unit" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldBalanceUnit(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBalanceUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBalanceUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalanceUnit: %w", err)
	}
	return oldValue.BalanceUnit, nil
}

// ResetBalanceUnit resets all changes to the "balance_unit" field.
func (m *ChannelMutation) ResetBalanceUnit() {
	m.balance_unit = nil
}

// SetCachedBalance sets the "cached_balance" field.
func (m *ChannelMutation) SetCachedBalance(f float64) {
	m.cached_balance = &f
	m.addcached_balance = nil
}

// CachedBalance returns the value of the "cached_balance" field in the mutation.
func (m *ChannelMutation) CachedBalance() (r float64, exists bool) {
	v := m.cached_balance
	if v == nil {
		return
	}
	return *v, true
}

// OldCachedBalance returns the old "cached_balance" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldCachedBalance(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCachedBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCachedBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCachedBalance: %w", err)
	}
	return oldValue.CachedBalance, nil
}

// AddCachedBalance adds f to the "cached_balance" field.
func (m *ChannelMutation) AddCachedBalance(f float64) {
	if m.addcached_balance != nil {
		*m.addcached_balance += f
	} else {
		m.addcached_balance = &f
	}
}

// AddedCachedBalance returns the value that was added to the "cached_balance" field in this mutation.
func (m *ChannelMutation) AddedCachedBalance() (r float64, exists bool) {
	v := m.addcached_balance
	if v == nil {
		return
	}
	return *v, true
}

// ClearCachedBalance clears the value of the "cached_balance" field.
func (m *ChannelMutation) ClearCachedBalance() {
	m.cached_balance = nil
	m.addcached_balance = nil
	m.clearedFields[channel.FieldCachedBalance] = struct{}{}
}

// CachedBalanceCleared returns if the "cached_balance" field was cleared in this mutation.
func (m *ChannelMutation) CachedBalanceCleared() bool {
	_, ok := m.clearedFields[channel.FieldCachedBalance]
	return ok
}

// ResetCachedBalance resets all changes to the "cached_balance" field.
func (m *ChannelMutation) ResetCachedBalance() {
	m.cached_balance = nil
	m.addcached_balance = nil
	delete(m.clearedFields, channel.FieldCachedBalance)
}

// SetLastCheckAt sets the "last_check_at" field.
func (m *ChannelMutation) SetLastCheckAt(t time.Time) {
	m.last_check_at = &t
}

// LastCheckAt returns the value of the "last_check_at" field in the mutation.
func (m *ChannelMutation) LastCheckAt() (r time.Time, exists bool) {
	v := m.last_check_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastCheckAt returns the old "last_check_at" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldLastCheckAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastCheckAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastCheckAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastCheckAt: %w", err)
	}
	return oldValue.LastCheckAt, nil
}

// ClearLastCheckAt clears the value of the "last_check_at" field.
func (m *ChannelMutation) ClearLastCheckAt() {
	m.last_check_at = nil
	m.clearedFields[channel.FieldLastCheckAt] = struct{}{}
}

// LastCheckAtCleared returns if the "last_check_at" field was cleared in this mutation.
func (m *ChannelMutation) LastCheckAtCleared() bool {
	_, ok := m.clearedFields[channel.FieldLastCheckAt]
	return ok
}

// ResetLastCheckAt resets all changes to the "last_check_at" field.
func (m *ChannelMutation) ResetLastCheckAt() {
	m.last_check_at = nil
	delete(m.clearedFields, channel.FieldLastCheckAt)
}

// SetLastError sets the "last_error" field.
func (m *ChannelMutation) SetLastError(s string) {
	m.last_error = &s
}

// LastError returns the value of the "last_error" field in the mutation.
func (m *ChannelMutation) LastError() (r string, exists bool) {
	v := m.last_error
	if v == nil {
		return
	}
	return *v, true
}

// OldLastError returns the old "last_error" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldLastError(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastError is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastError: %w", err)
	}
	return oldValue.LastError, nil
}

// ClearLastError clears the value of the "last_error" field.
func (m *ChannelMutation) ClearLastError() {
	m.last_error = nil
	m.clearedFields[channel.FieldLastError] = struct{}{}
}

// LastErrorCleared returns if the "last_error" field was cleared in this mutation.
func (m *ChannelMutation) LastErrorCleared() bool {
	_, ok := m.clearedFields[channel.FieldLastError]
	return ok
}

// ResetLastError resets all changes to the "last_error" field.
func (m *ChannelMutation) ResetLastError() {
	m.last_error = nil
	delete(m.clearedFields, channel.FieldLastError)
}

// Where appends a list predicates to the ChannelMutation builder.
func (m *ChannelMutation) Where(ps ...predicate.Channel) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ChannelMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ChannelMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Channel, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ChannelMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ChannelMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Channel).
func (m *ChannelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChannelMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.created_at != nil {
		fields = append(fields, channel.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, channel.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, channel.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, channel.FieldName)
	}
	if m.description != nil {
		fields = append(fields, channel.FieldDescription)
	}
	if m.platform != nil {
		fields = append(fields, channel.FieldPlatform)
	}
	if m.status != nil {
		fields = append(fields, channel.FieldStatus)
	}
	if m.icon_url != nil {
		fields = append(fields, channel.FieldIconURL)
	}
	if m.website_url != nil {
		fields = append(fields, channel.FieldWebsiteURL)
	}
	if m.balance_url != nil {
		fields = append(fields, channel.FieldBalanceURL)
	}
	if m.balance_method != nil {
		fields = append(fields, channel.FieldBalanceMethod)
	}
	if m.balance_headers != nil {
		fields = append(fields, channel.FieldBalanceHeaders)
	}
	if m.balance_body != nil {
		fields = append(fields, channel.FieldBalanceBody)
	}
	if m.balance_path != nil {
		fields = append(fields, channel.FieldBalancePath)
	}
	if m.balance_unit != nil {
		fields = append(fields, channel.FieldBalanceUnit)
	}
	if m.cached_balance != nil {
		fields = append(fields, channel.FieldCachedBalance)
	}
	if m.last_check_at != nil {
		fields = append(fields, channel.FieldLastCheckAt)
	}
	if m.last_error != nil {
		fields = append(fields, channel.FieldLastError)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChannelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case channel.FieldCreatedAt:
		return m.CreatedAt()
	case channel.FieldUpdatedAt:
		return m.UpdatedAt()
	case channel.FieldDeletedAt:
		return m.DeletedAt()
	case channel.FieldName:
		return m.Name()
	case channel.FieldDescription:
		return m.Description()
	case channel.FieldPlatform:
		return m.Platform()
	case channel.FieldStatus:
		return m.Status()
	case channel.FieldIconURL:
		return m.IconURL()
	case channel.FieldWebsiteURL:
		return m.WebsiteURL()
	case channel.FieldBalanceURL:
		return m.BalanceURL()
	case channel.FieldBalanceMethod:
		return m.BalanceMethod()
	case channel.FieldBalanceHeaders:
		return m.BalanceHeaders()
	case channel.FieldBalanceBody:
		return m.BalanceBody()
	case channel.FieldBalancePath:
		return m.BalancePath()
	case channel.FieldBalanceUnit:
		return m.BalanceUnit()
	case channel.FieldCachedBalance:
		return m.CachedBalance()
	case channel.FieldLastCheckAt:
		return m.LastCheckAt()
	case channel.FieldLastError:
		return m.LastError()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChannelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case channel.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case channel.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case channel.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case channel.FieldName:
		return m.OldName(ctx)
	case channel.FieldDescription:
		return m.OldDescription(ctx)
	case channel.FieldPlatform:
		return m.OldPlatform(ctx)
	case channel.FieldStatus:
		return m.OldStatus(ctx)
	case channel.FieldIconURL:
		return m.OldIconURL(ctx)
	case channel.FieldWebsiteURL:
		return m.OldWebsiteURL(ctx)
	case channel.FieldBalanceURL:
		return m.OldBalanceURL(ctx)
	case channel.FieldBalanceMethod:
		return m.OldBalanceMethod(ctx)
	case channel.FieldBalanceHeaders:
		return m.OldBalanceHeaders(ctx)
	case channel.FieldBalanceBody:
		return m.OldBalanceBody(ctx)
	case channel.FieldBalancePath:
		return m.OldBalancePath(ctx)
	case channel.FieldBalanceUnit:
		return m.OldBalanceUnit(ctx)
	case channel.FieldCachedBalance:
		return m.OldCachedBalance(ctx)
	case channel.FieldLastCheckAt:
		return m.OldLastCheckAt(ctx)
	case channel.FieldLastError:
		return m.OldLastError(ctx)
	}
	return nil, fmt.Errorf("unknown Channel field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChannelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case channel.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case channel.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case channel.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case channel.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case channel.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case channel.FieldPlatform:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatform(v)
		return nil
	case channel.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case channel.FieldIconURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIconURL(v)
		return nil
	case channel.FieldWebsiteURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWebsiteURL(v)
		return nil
	case channel.FieldBalanceURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalanceURL(v)
		return nil
	case channel.FieldBalanceMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalanceMethod(v)
		return nil
	case channel.FieldBalanceHeaders:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalanceHeaders(v)
		return nil
	case channel.FieldBalanceBody:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalanceBody(v)
		return nil
	case channel.FieldBalancePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalancePath(v)
		return nil
	case channel.FieldBalanceUnit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalanceUnit(v)
		return nil
	case channel.FieldCachedBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCachedBalance(v)
		return nil
	case channel.FieldLastCheckAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastCheckAt(v)
		return nil
	case channel.FieldLastError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastError(v)
		return nil
	}
	return fmt.Errorf("unknown Channel field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChannelMutation) AddedFields() []string {
	var fields []string
	if m.addcached_balance != nil {
		fields = append(fields, channel.FieldCachedBalance)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChannelMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case channel.FieldCachedBalance:
		return m.AddedCachedBalance()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChannelMutation) AddField(name string, value ent.Value) error {
	switch name {
	case channel.FieldCachedBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCachedBalance(v)
		return nil
	}
	return fmt.Errorf("unknown Channel numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChannelMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(channel.FieldDeletedAt) {
		fields = append(fields, channel.FieldDeletedAt)
	}
	if m.FieldCleared(channel.FieldDescription) {
		fields = append(fields, channel.FieldDescription)
	}
	if m.FieldCleared(channel.FieldPlatform) {
		fields = append(fields, channel.FieldPlatform)
	}
	if m.FieldCleared(channel.FieldIconURL) {
		fields = append(fields, channel.FieldIconURL)
	}
	if m.FieldCleared(channel.FieldWebsiteURL) {
		fields = append(fields, channel.FieldWebsiteURL)
	}
	if m.FieldCleared(channel.FieldBalanceURL) {
		fields = append(fields, channel.FieldBalanceURL)
	}
	if m.FieldCleared(channel.FieldBalanceHeaders) {
		fields = append(fields, channel.FieldBalanceHeaders)
	}
	if m.FieldCleared(channel.FieldBalanceBody) {
		fields = append(fields, channel.FieldBalanceBody)
	}
	if m.FieldCleared(channel.FieldBalancePath) {
		fields = append(fields, channel.FieldBalancePath)
	}
	if m.FieldCleared(channel.FieldCachedBalance) {
		fields = append(fields, channel.FieldCachedBalance)
	}
	if m.FieldCleared(channel.FieldLastCheckAt) {
		fields = append(fields, channel.FieldLastCheckAt)
	}
	if m.FieldCleared(channel.FieldLastError) {
		fields = append(fields, channel.FieldLastError)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChannelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChannelMutation) ClearField(name string) error {
	switch name {
	case channel.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case channel.FieldDescription:
		m.ClearDescription()
		return nil
	case channel.FieldPlatform:
		m.ClearPlatform()
		return nil
	case channel.FieldIconURL:
		m.ClearIconURL()
		return nil
	case channel.FieldWebsiteURL:
		m.ClearWebsiteURL()
		return nil
	case channel.FieldBalanceURL:
		m.ClearBalanceURL()
		return nil
	case channel.FieldBalanceHeaders:
		m.ClearBalanceHeaders()
		return nil
	case channel.FieldBalanceBody:
		m.ClearBalanceBody()
		return nil
	case channel.FieldBalancePath:
		m.ClearBalancePath()
		return nil
	case channel.FieldCachedBalance:
		m.ClearCachedBalance()
		return nil
	case channel.FieldLastCheckAt:
		m.ClearLastCheckAt()
		return nil
	case channel.FieldLastError:
		m.ClearLastError()
		return nil
	}
	return fmt.Errorf("unknown Channel nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChannelMutation) ResetField(name string) error {
	switch name {
	case channel.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case channel.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case channel.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case channel.FieldName:
		m.ResetName()
		return nil
	case channel.FieldDescription:
		m.ResetDescription()
		return nil
	case channel.FieldPlatform:
		m.ResetPlatform()
		return nil
	case channel.FieldStatus:
		m.ResetStatus()
		return nil
	case channel.FieldIconURL:
		m.ResetIconURL()
		return nil
	case channel.FieldWebsiteURL:
		m.ResetWebsiteURL()
		return nil
	case channel.FieldBalanceURL:
		m.ResetBalanceURL()
		return nil
	case channel.FieldBalanceMethod:
		m.ResetBalanceMethod()
		return nil
	case channel.FieldBalanceHeaders:
		m.ResetBalanceHeaders()
		return nil
	case channel.FieldBalanceBody:
		m.ResetBalanceBody()
		return nil
	case channel.FieldBalancePath:
		m.ResetBalancePath()
		return nil
	case channel.FieldBalanceUnit:
		m.ResetBalanceUnit()
		return nil
	case channel.FieldCachedBalance:
		m.ResetCachedBalance()
		return nil
	case channel.FieldLastCheckAt:
		m.ResetLastCheckAt()
		return nil
	case channel.FieldLastError:
		m.ResetLastError()
		return nil
	}
	return fmt.Errorf("unknown Channel field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChannelMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChannelMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChannelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChannelMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChannelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChannelMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChannelMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Channel unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChannelMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Channel edge %s", name)
}

// ErrorPassthroughRuleMutation represents an operation that mutates the ErrorPassthroughRule nodes in the graph.
type ErrorPassthroughRuleMutation struct {
	config
	op                Op
	typ               string
	id                *int64
	created_at        *time.Time
	updated_at        *time.Time
	name              *string
	enabled           *bool
	priority          *int
	addpriority       *int
	error_codes       *[]int
	appenderror_codes []int
	keywords          *[]string
	appendkeywords    []string
	match_mode        *string
	platforms         *[]string
	appendplatforms   []string
	passthrough_code  *bool
	response_code     *int
	addresponse_code  *int
	passthrough_body  *bool
	custom_message    *string
	description       *string
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*ErrorPassthroughRule, error)
	predicates        []predicate.ErrorPassthroughRule
}

var _ ent.Mutation = (*ErrorPassthroughRuleMutation)(nil)

// errorpassthroughruleOption allows management of the mutation configuration using functional options.
type errorpassthroughruleOption func(*ErrorPassthroughRuleMutation)

// newErrorPassthroughRuleMutation creates new mutation for the ErrorPassthroughRule entity.
func newErrorPassthroughRuleMutation(c config, op Op, opts ...errorpassthroughruleOption) *ErrorPassthroughRuleMutation {
	m := &ErrorPassthroughRuleMutation{
		config:        c,
		op:            op,
		typ:           TypeErrorPassthroughRule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withErrorPassthroughRuleID sets the ID field of the mutation.
func withErrorPassthroughRuleID(id int64) errorpassthroughruleOption {
	return func(m *ErrorPassthroughRuleMutation) {
		var (
			err   error
			once  sync.Once
			value *ErrorPassthroughRule
		)
		m.oldValue = func(ctx context.Context) (*ErrorPassthroughRule, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ErrorPassthroughRule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withErrorPassthroughRule sets the old ErrorPassthroughRule of the mutation.
func withErrorPassthroughRule(node *ErrorPassthroughRule) errorpassthroughruleOption {
	return func(m *ErrorPassthroughRuleMutation) {
		m.oldValue = func(context.Context) (*ErrorPassthroughRule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ErrorPassthroughRuleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ErrorPassthroughRuleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ErrorPassthroughRuleMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ErrorPassthroughRuleMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ErrorPassthroughRule.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ErrorPassthroughRuleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ErrorPassthroughRuleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ErrorPassthroughRule entity.
// If the ErrorPassthroughRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ErrorPassthroughRuleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ErrorPassthroughRuleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ErrorPassthroughRuleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ErrorPassthroughRuleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ErrorPassthroughRule entity.
// If the ErrorPassthroughRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ErrorPassthroughRuleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ErrorPassthroughRuleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *ErrorPassthroughRuleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ErrorPassthroughRuleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ErrorPassthroughRule entity.
// If the ErrorPassthroughRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ErrorPassthroughRuleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ErrorPassthroughRuleMutation) ResetName() {
	m.name = nil
}

// SetEnabled sets the "enabled" field.
func (m *ErrorPassthroughRuleMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *ErrorPassthroughRuleMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the ErrorPassthroughRule entity.
// If the ErrorPassthroughRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ErrorPassthroughRuleMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *ErrorPassthroughRuleMutation) ResetEnabled() {
	m.enabled = nil
}

// SetPriority sets the "priority" field.
func (m *ErrorPassthroughRuleMutation) SetPriority(i int) {
	m.priority = &i
	m.addpriority = nil
}

// Priority returns the value of the "priority" field in the mutation.
func (m *ErrorPassthroughRuleMutation) Priority() (r int, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the ErrorPassthroughRule entity.
// If the ErrorPassthroughRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ErrorPassthroughRuleMutation) OldPriority(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// AddPriority adds i to the "priority" field.
func (m *ErrorPassthroughRuleMutation) AddPriority(i int) {
	if m.addpriority != nil {
		*m.addpriority += i
	} else {
		m.addpriority = &i
	}
}

// AddedPriority returns the value that was added to the "priority" field in this mutation.
func (m *ErrorPassthroughRuleMutation) AddedPriority() (r int, exists bool) {
	v := m.addpriority
	if v == nil {
		return
	}
	return *v, true
}

// ResetPriority resets all changes to the "priority" field.
func (m *ErrorPassthroughRuleMutation) ResetPriority() {
	m.priority = nil
	m.addpriority = nil
}

// SetErrorCodes sets the "error_codes" field.
func (m *ErrorPassthroughRuleMutation) SetErrorCodes(i []int) {
	m.error_codes = &i
	m.appenderror_codes = nil
}

// ErrorCodes returns the value of the "error_codes" field in the mutation.
func (m *ErrorPassthroughRuleMutation) ErrorCodes() (r []int, exists bool) {
	v := m.error_codes
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorCodes returns the old "error_codes" field's value of the ErrorPassthroughRule entity.
// If the ErrorPassthroughRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ErrorPassthroughRuleMutation) OldErrorCodes(ctx context.Context) (v []int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorCodes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorCodes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorCodes: %w", err)
	}
	return oldValue.ErrorCodes, nil
}

// AppendErrorCodes adds i to the "error_codes" field.
func (m *ErrorPassthroughRuleMutation) AppendErrorCodes(i []int) {
	m.appenderror_codes = append(m.appenderror_codes, i...)
}

// AppendedErrorCodes returns the list of values that were appended to the "error_codes" field in this mutation.
func (m *ErrorPassthroughRuleMutation) AppendedErrorCodes() ([]int, bool) {
	if len(m.appenderror_codes) == 0 {
		return nil, false
	}
	return m.appenderror_codes, true
}

// ClearErrorCodes clears the value of the "error_codes" field.
func (m *ErrorPassthroughRuleMutation) ClearErrorCodes() {
	m.error_codes = nil
	m.appenderror_codes = nil
	m.clearedFields[errorpassthroughrule.FieldErrorCodes] = struct{}{}
}

// ErrorCodesCleared returns if the "error_codes" field was cleared in this mutation.
func (m *ErrorPassthroughRuleMutation) ErrorCodesCleared() bool {
	_, ok := m.clearedFields[errorpassthroughrule.FieldErrorCodes]
	return ok
}

// ResetErrorCodes resets all changes to the "error_codes" field.
func (m *ErrorPassthroughRuleMutation) ResetErrorCodes() {
	m.error_codes = nil
	m.appenderror_codes = nil
	delete(m.clearedFields, errorpassthroughrule.FieldErrorCodes)
}

// SetKeywords sets the "keywords" field.
func (m *ErrorPassthroughRuleMutation) SetKeywords(s []string) {
	m.keywords = &s
	m.appendkeywords = nil
}

// Keywords returns the value of the "keywords" field in the mutation.
func (m *ErrorPassthroughRuleMutation) Keywords() (r []string, exists bool) {
	v := m.keywords
	if v == nil {
		return
	}
	return *v, true
}

// OldKeywords returns the old "keywords" field's value of the ErrorPassthroughRule entity.
// If the ErrorPassthroughRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ErrorPassthroughRuleMutation) OldKeywords(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKeywords is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKeywords requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKeywords: %w", err)
	}
	return oldValue.Keywords, nil
}

// AppendKeywords adds s to the "keywords" field.
func (m *ErrorPassthroughRuleMutation) AppendKeywords(s []string) {
	m.appendkeywords = append(m.appendkeywords, s...)
}

// AppendedKeywords returns the list of values that were appended to the "keywords" field in this mutation.
func (m *ErrorPassthroughRuleMutation) AppendedKeywords() ([]string, bool) {
	if len(m.appendkeywords) == 0 {
		return nil, false
	}
	return m.appendkeywords, true
}

// ClearKeywords clears the value of the "keywords" field.
func (m *ErrorPassthroughRuleMutation) ClearKeywords() {
	m.keywords = nil
	m.appendkeywords = nil
	m.clearedFields[errorpassthroughrule.FieldKeywords] = struct{}{}
}

// KeywordsCleared returns if the "keywords" field was cleared in this mutation.
func (m *ErrorPassthroughRuleMutation) KeywordsCleared() bool {
	_, ok := m.clearedFields[errorpassthroughrule.FieldKeywords]
	return ok
}

// ResetKeywords resets all changes to the "keywords" field.
func (m *ErrorPassthroughRuleMutation) ResetKeywords() {
	m.keywords = nil
	m.appendkeywords = nil
	delete(m.clearedFields, errorpassthroughrule.FieldKeywords)
}

// SetMatchMode sets the "match_mode" field.
func (m *ErrorPassthroughRuleMutation) SetMatchMode(s string) {
	m.match_mode = &s
}

// MatchMode returns the value of the "match_mode" field in the mutation.
func (m *ErrorPassthroughRuleMutation) MatchMode() (r string, exists bool) {
	v := m.match_mode
	if v == nil {
		return
	}
	return *v, true
}

// OldMatchMode returns the old "match_mode" field's value of the ErrorPassthroughRule entity.
// If the ErrorPassthroughRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ErrorPassthroughRuleMutation) OldMatchMode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMatchMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMatchMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMatchMode: %w", err)
	}
	return oldValue.MatchMode, nil
}

// ResetMatchMode resets all changes to the "match_mode" field.
func (m *ErrorPassthroughRuleMutation) ResetMatchMode() {
	m.match_mode = nil
}

// SetPlatforms sets the "platforms" field.
func (m *ErrorPassthroughRuleMutation) SetPlatforms(s []string) {
	m.platforms = &s
	m.appendplatforms = nil
}

// Platforms returns the value of the "platforms" field in the mutation.
func (m *ErrorPassthroughRuleMutation) Platforms() (r []string, exists bool) {
	v := m.platforms
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatforms returns the old "platforms" field's value of the ErrorPassthroughRule entity.
// If the ErrorPassthroughRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ErrorPassthroughRuleMutation) OldPlatforms(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatforms is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatforms requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatforms: %w", err)
	}
	return oldValue.Platforms, nil
}

// AppendPlatforms adds s to the "platforms" field.
func (m *ErrorPassthroughRuleMutation) AppendPlatforms(s []string) {
	m.appendplatforms = append(m.appendplatforms, s...)
}

// AppendedPlatforms returns the list of values that were appended to the "platforms" field in this mutation.
func (m *ErrorPassthroughRuleMutation) AppendedPlatforms() ([]string, bool) {
	if len(m.appendplatforms) == 0 {
		return nil, false
	}
	return m.appendplatforms, true
}

// ClearPlatforms clears the value of the "platforms" field.
func (m *ErrorPassthroughRuleMutation) ClearPlatforms() {
	m.platforms = nil
	m.appendplatforms = nil
	m.clearedFields[errorpassthroughrule.FieldPlatforms] = struct{}{}
}

// PlatformsCleared returns if the "platforms" field was cleared in this mutation.
func (m *ErrorPassthroughRuleMutation) PlatformsCleared() bool {
	_, ok := m.clearedFields[errorpassthroughrule.FieldPlatforms]
	return ok
}

// ResetPlatforms resets all changes to the "platforms" field.
func (m *ErrorPassthroughRuleMutation) ResetPlatforms() {
	m.platforms = nil
	m.appendplatforms = nil
	delete(m.clearedFields, errorpassthroughrule.FieldPlatforms)
}

// SetPassthroughCode sets the "passthrough_code" field.
func (m *ErrorPassthroughRuleMutation) SetPassthroughCode(b bool) {
	m.passthrough_code = &b
}

// PassthroughCode returns the value of the "passthrough_code" field in the mutation.
func (m *ErrorPassthroughRuleMutation) PassthroughCode() (r bool, exists bool) {
	v := m.passthrough_code
	if v == nil {
		return
	}
	return *v, true
}

// OldPassthroughCode returns the old "passthrough_code" field's value of the ErrorPassthroughRule entity.
// If the ErrorPassthroughRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ErrorPassthroughRuleMutation) OldPassthroughCode(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassthroughCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassthroughCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassthroughCode: %w", err)
	}
	return oldValue.PassthroughCode, nil
}

// ResetPassthroughCode resets all changes to the "passthrough_code" field.
func (m *ErrorPassthroughRuleMutation) ResetPassthroughCode() {
	m.passthrough_code = nil
}

// SetResponseCode sets the "response_code" field.
func (m *ErrorPassthroughRuleMutation) SetResponseCode(i int) {
	m.response_code = &i
	m.addresponse_code = nil
}

// ResponseCode returns the value of the "response_code" field in the mutation.
func (m *ErrorPassthroughRuleMutation) ResponseCode() (r int, exists bool) {
	v := m.response_code
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseCode returns the old "response_code" field's value of the ErrorPassthroughRule entity.
// If the ErrorPassthroughRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ErrorPassthroughRuleMutation) OldResponseCode(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseCode: %w", err)
	}
	return oldValue.ResponseCode, nil
}

// AddResponseCode adds i to the "response_code" field.
func (m *ErrorPassthroughRuleMutation) AddResponseCode(i int) {
	if m.addresponse_code != nil {
		*m.addresponse_code += i
	} else {
		m.addresponse_code = &i
	}
}

// AddedResponseCode returns the value that was added to the "response_code" field in this mutation.
func (m *ErrorPassthroughRuleMutation) AddedResponseCode() (r int, exists bool) {
	v := m.addresponse_code
	if v == nil {
		return
	}
	return *v, true
}

// ClearResponseCode clears the value of the "response_code" field.
func (m *ErrorPassthroughRuleMutation) ClearResponseCode() {
	m.response_code = nil
	m.addresponse_code = nil
	m.clearedFields[errorpassthroughrule.FieldResponseCode] = struct{}{}
}

// ResponseCodeCleared returns if the "response_code" field was cleared in this mutation.
func (m *ErrorPassthroughRuleMutation) ResponseCodeCleared() bool {
	_, ok := m.clearedFields[errorpassthroughrule.FieldResponseCode]
	return ok
}

// ResetResponseCode resets all changes to the "response_code" field.
func (m *ErrorPassthroughRuleMutation) ResetResponseCode() {
	m.response_code = nil
	m.addresponse_code = nil
	delete(m.clearedFields, errorpassthroughrule.FieldResponseCode)
}

// SetPassthroughBody sets the "passthrough_body" field.
func (m *ErrorPassthroughRuleMutation) SetPassthroughBody(b bool) {
	m.passthrough_body = &b
}

// PassthroughBody returns the value of the "passthrough_body" field in the mutation.
func (m *ErrorPassthroughRuleMutation) PassthroughBody() (r bool, exists bool) {
	v := m.passthrough_body
	if v == nil {
		return
	}
	return *v, true
}

// OldPassthroughBody returns the old "passthrough_body" field's value of the ErrorPassthroughRule entity.
// If the ErrorPassthroughRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ErrorPassthroughRuleMutation) OldPassthroughBody(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassthroughBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassthroughBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassthroughBody: %w", err)
	}
	return oldValue.PassthroughBody, nil
}

// ResetPassthroughBody resets all changes to the "passthrough_body" field.
func (m *ErrorPassthroughRuleMutation) ResetPassthroughBody() {
	m.passthrough_body = nil
}

// SetCustomMessage sets the "custom_message" field.
func (m *ErrorPassthroughRuleMutation) SetCustomMessage(s string) {
	m.custom_message = &s
}

// CustomMessage returns the value of the "custom_message" field in the mutation.
func (m *ErrorPassthroughRuleMutation) CustomMessage() (r string, exists bool) {
	v := m.custom_message
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomMessage returns the old "custom_message" field's value of the ErrorPassthroughRule entity.
// If the ErrorPassthroughRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ErrorPassthroughRuleMutation) OldCustomMessage(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomMessage: %w", err)
	}
	return oldValue.CustomMessage, nil
}

// ClearCustomMessage clears the value of the "custom_message" field.
func (m *ErrorPassthroughRuleMutation) ClearCustomMessage() {
	m.custom_message = nil
	m.clearedFields[errorpassthroughrule.FieldCustomMessage] = struct{}{}
}

// CustomMessageCleared returns if the "custom_message" field was cleared in this mutation.
func (m *ErrorPassthroughRuleMutation) CustomMessageCleared() bool {
	_, ok := m.clearedFields[errorpassthroughrule.FieldCustomMessage]
	return ok
}

// ResetCustomMessage resets all changes to the "custom_message" field.
func (m *ErrorPassthroughRuleMutation) ResetCustomMessage() {
	m.custom_message = nil
	delete(m.clearedFields, errorpassthroughrule.FieldCustomMessage)
}

// SetDescription sets the "description" field.
func (m *ErrorPassthroughRuleMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ErrorPassthroughRuleMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ErrorPassthroughRule entity.
// If the ErrorPassthroughRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ErrorPassthroughRuleMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ErrorPassthroughRuleMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[errorpassthroughrule.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ErrorPassthroughRuleMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[errorpassthroughrule.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ErrorPassthroughRuleMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, errorpassthroughrule.FieldDescription)
}

// Where appends a list predicates to the ErrorPassthroughRuleMutation builder.
func (m *ErrorPassthroughRuleMutation) Where(ps ...predicate.ErrorPassthroughRule) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ErrorPassthroughRuleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ErrorPassthroughRuleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ErrorPassthroughRule, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ErrorPassthroughRuleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ErrorPassthroughRuleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ErrorPassthroughRule).
func (m *ErrorPassthroughRuleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ErrorPassthroughRuleMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, errorpassthroughrule.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, errorpassthroughrule.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, errorpassthroughrule.FieldName)
	}
	if m.enabled != nil {
		fields = append(fields, errorpassthroughrule.FieldEnabled)
	}
	if m.priority != nil {
		fields = append(fields, errorpassthroughrule.FieldPriority)
	}
	if m.error_codes != nil {
		fields = append(fields, errorpassthroughrule.FieldErrorCodes)
	}
	if m.keywords != nil {
		fields = append(fields, errorpassthroughrule.FieldKeywords)
	}
	if m.match_mode != nil {
		fields = append(fields, errorpassthroughrule.FieldMatchMode)
	}
	if m.platforms != nil {
		fields = append(fields, errorpassthroughrule.FieldPlatforms)
	}
	if m.passthrough_code != nil {
		fields = append(fields, errorpassthroughrule.FieldPassthroughCode)
	}
	if m.response_code != nil {
		fields = append(fields, errorpassthroughrule.FieldResponseCode)
	}
	if m.passthrough_body != nil {
		fields = append(fields, errorpassthroughrule.FieldPassthroughBody)
	}
	if m.custom_message != nil {
		fields = append(fields, errorpassthroughrule.FieldCustomMessage)
	}
	if m.description != nil {
		fields = append(fields, errorpassthroughrule.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ErrorPassthroughRuleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case errorpassthroughrule.FieldCreatedAt:
		return m.CreatedAt()
	case errorpassthroughrule.FieldUpdatedAt:
		return m.UpdatedAt()
	case errorpassthroughrule.FieldName:
		return m.Name()
	case errorpassthroughrule.FieldEnabled:
		return m.Enabled()
	case errorpassthroughrule.FieldPriority:
		return m.Priority()
	case errorpassthroughrule.FieldErrorCodes:
		return m.ErrorCodes()
	case errorpassthroughrule.FieldKeywords:
		return m.Keywords()
	case errorpassthroughrule.FieldMatchMode:
		return m.MatchMode()
	case errorpassthroughrule.FieldPlatforms:
		return m.Platforms()
	case errorpassthroughrule.FieldPassthroughCode:
		return m.PassthroughCode()
	case errorpassthroughrule.FieldResponseCode:
		return m.ResponseCode()
	case errorpassthroughrule.FieldPassthroughBody:
		return m.PassthroughBody()
	case errorpassthroughrule.FieldCustomMessage:
		return m.CustomMessage()
	case errorpassthroughrule.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ErrorPassthroughRuleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case errorpassthroughrule.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case errorpassthroughrule.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case errorpassthroughrule.FieldName:
		return m.OldName(ctx)
	case errorpassthroughrule.FieldEnabled:
		return m.OldEnabled(ctx)
	case errorpassthroughrule.FieldPriority:
		return m.OldPriority(ctx)
	case errorpassthroughrule.FieldErrorCodes:
		return m.OldErrorCodes(ctx)
	case errorpassthroughrule.FieldKeywords:
		return m.OldKeywords(ctx)
	case errorpassthroughrule.FieldMatchMode:
		return m.OldMatchMode(ctx)
	case errorpassthroughrule.FieldPlatforms:
		return m.OldPlatforms(ctx)
	case errorpassthroughrule.FieldPassthroughCode:
		return m.OldPassthroughCode(ctx)
	case errorpassthroughrule.FieldResponseCode:
		return m.OldResponseCode(ctx)
	case errorpassthroughrule.FieldPassthroughBody:
		return m.OldPassthroughBody(ctx)
	case errorpassthroughrule.FieldCustomMessage:
		return m.OldCustomMessage(ctx)
	case errorpassthroughrule.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown ErrorPassthroughRule field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ErrorPassthroughRuleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case errorpassthroughrule.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case errorpassthroughrule.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case errorpassthroughrule.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case errorpassthroughrule.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case errorpassthroughrule.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case errorpassthroughrule.FieldErrorCodes:
		v, ok := value.([]int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorCodes(v)
		return nil
	case errorpassthroughrule.FieldKeywords:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKeywords(v)
		return nil
	case errorpassthroughrule.FieldMatchMode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMatchMode(v)
		return nil
	case errorpassthroughrule.FieldPlatforms:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatforms(v)
		return nil
	case errorpassthroughrule.FieldPassthroughCode:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassthroughCode(v)
		return nil
	case errorpassthroughrule.FieldResponseCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseCode(v)
		return nil
	case errorpassthroughrule.FieldPassthroughBody:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassthroughBody(v)
		return nil
	case errorpassthroughrule.FieldCustomMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomMessage(v)
		return nil
	case errorpassthroughrule.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown ErrorPassthroughRule field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ErrorPassthroughRuleMutation) AddedFields() []string {
	var fields []string
	if m.addpriority != nil {
		fields = append(fields, errorpassthroughrule.FieldPriority)
	}
	if m.addresponse_code != nil {
		fields = append(fields, errorpassthroughrule.FieldResponseCode)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ErrorPassthroughRuleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case errorpassthroughrule.FieldPriority:
		return m.AddedPriority()
	case errorpassthroughrule.FieldResponseCode:
		return m.AddedResponseCode()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ErrorPassthroughRuleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case errorpassthroughrule.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriority(v)
		return nil
	case errorpassthroughrule.FieldResponseCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResponseCode(v)
		return nil
	}
	return fmt.Errorf("unknown ErrorPassthroughRule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ErrorPassthroughRuleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(errorpassthroughrule.FieldErrorCodes) {
		fields = append(fields, errorpassthroughrule.FieldErrorCodes)
	}
	if m.FieldCleared(errorpassthroughrule.FieldKeywords) {
		fields = append(fields, errorpassthroughrule.FieldKeywords)
	}
	if m.FieldCleared(errorpassthroughrule.FieldPlatforms) {
		fields = append(fields, errorpassthroughrule.FieldPlatforms)
	}
	if m.FieldCleared(errorpassthroughrule.FieldResponseCode) {
		fields = append(fields, errorpassthroughrule.FieldResponseCode)
	}
	if m.FieldCleared(errorpassthroughrule.FieldCustomMessage) {
		fields = append(fields, errorpassthroughrule.FieldCustomMessage)
	}
	if m.FieldCleared(errorpassthroughrule.FieldDescription) {
		fields = append(fields, errorpassthroughrule.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ErrorPassthroughRuleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ErrorPassthroughRuleMutation) ClearField(name string) error {
	switch name {
	case errorpassthroughrule.FieldErrorCodes:
		m.ClearErrorCodes()
		return nil
	case errorpassthroughrule.FieldKeywords:
		m.ClearKeywords()
		return nil
	case errorpassthroughrule.FieldPlatforms:
		m.ClearPlatforms()
		return nil
	case errorpassthroughrule.FieldResponseCode:
		m.ClearResponseCode()
		return nil
	case errorpassthroughrule.FieldCustomMessage:
		m.ClearCustomMessage()
		return nil
	case errorpassthroughrule.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown ErrorPassthroughRule nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ErrorPassthroughRuleMutation) ResetField(name string) error {
	switch name {
	case errorpassthroughrule.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case errorpassthroughrule.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case errorpassthroughrule.FieldName:
		m.ResetName()
		return nil
	case errorpassthroughrule.FieldEnabled:
		m.ResetEnabled()
		return nil
	case errorpassthroughrule.FieldPriority:
		m.ResetPriority()
		return nil
	case errorpassthroughrule.FieldErrorCodes:
		m.ResetErrorCodes()
		return nil
	case errorpassthroughrule.FieldKeywords:
		m.ResetKeywords()
		return nil
	case errorpassthroughrule.FieldMatchMode:
		m.ResetMatchMode()
		return nil
	case errorpassthroughrule.FieldPlatforms:
		m.ResetPlatforms()
		return nil
	case errorpassthroughrule.FieldPassthroughCode:
		m.ResetPassthroughCode()
		return nil
	case errorpassthroughrule.FieldResponseCode:
		m.ResetResponseCode()
		return nil
	case errorpassthroughrule.FieldPassthroughBody:
		m.ResetPassthroughBody()
		return nil
	case errorpassthroughrule.FieldCustomMessage:
		m.ResetCustomMessage()
		return nil
	case errorpassthroughrule.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown ErrorPassthroughRule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ErrorPassthroughRuleMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ErrorPassthroughRuleMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ErrorPassthroughRuleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ErrorPassthroughRuleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ErrorPassthroughRuleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ErrorPassthroughRuleMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ErrorPassthroughRuleMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ErrorPassthroughRule unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ErrorPassthroughRuleMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ErrorPassthroughRule edge %s", name)
}

// GroupMutation represents an operation that mutates the Group nodes in the graph.
type GroupMutation struct {
	config
	op                                      Op
	typ                                     string
	id                                      *int64
	created_at                              *time.Time
	updated_at                              *time.Time
	deleted_at                              *time.Time
	name                                    *string
	description                             *string
	rate_multiplier                         *float64
	addrate_multiplier                      *float64
	is_exclusive                            *bool
	status                                  *string
	platform                                *string
	subscription_type                       *string
	daily_limit_usd                         *float64
	adddaily_limit_usd                      *float64
	weekly_limit_usd                        *float64
	addweekly_limit_usd                     *float64
	monthly_limit_usd                       *float64
	addmonthly_limit_usd                    *float64
	default_validity_days                   *int
	adddefault_validity_days                *int
	image_price_1k                          *float64
	addimage_price_1k                       *float64
	image_price_2k                          *float64
	addimage_price_2k                       *float64
	image_price_4k                          *float64
	addimage_price_4k                       *float64
	claude_code_only                        *bool
	fallback_group_id                       *int64
	addfallback_group_id                    *int64
	fallback_group_id_on_invalid_request    *int64
	addfallback_group_id_on_invalid_request *int64
	model_routing                           *map[string][]int64
	model_routing_enabled                   *bool
	mcp_xml_inject                          *bool
	supported_model_scopes                  *[]string
	appendsupported_model_scopes            []string
	price                                   *float64
	addprice                                *float64
	is_purchasable                          *bool
	sort_order                              *int
	addsort_order                           *int
	is_recommended                          *bool
	external_buy_url                        *string
	owner_id                                *int64
	addowner_id                             *int64
	source_group_id                         *int64
	addsource_group_id                      *int64
	reseller_template                       *bool
	clearedFields                           map[string]struct{}
	api_keys                                map[int64]struct{}
	removedapi_keys                         map[int64]struct{}
	clearedapi_keys                         bool
	redeem_codes                            map[int64]struct{}
	removedredeem_codes                     map[int64]struct{}
	clearedredeem_codes                     bool
	subscriptions                           map[int64]struct{}
	removedsubscriptions                    map[int64]struct{}
	clearedsubscriptions                    bool
	usage_logs                              map[int64]struct{}
	removedusage_logs                       map[int64]struct{}
	clearedusage_logs                       bool
	orders                                  map[int64]struct{}
	removedorders                           map[int64]struct{}
	clearedorders                           bool
	accounts                                map[int64]struct{}
	removedaccounts                         map[int64]struct{}
	clearedaccounts                         bool
	allowed_users                           map[int64]struct{}
	removedallowed_users                    map[int64]struct{}
	clearedallowed_users                    bool
	done                                    bool
	oldValue                                func(context.Context) (*Group, error)
	predicates                              []predicate.Group
}

var _ ent.Mutation = (*GroupMutation)(nil)

// groupOption allows management of the mutation configuration using functional options.
type groupOption func(*GroupMutation)

// newGroupMutation creates new mutation for the Group entity.
func newGroupMutation(c config, op Op, opts ...groupOption) *GroupMutation {
	m := &GroupMutation{
		config:        c,
		op:            op,
		typ:           TypeGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGroupID sets the ID field of the mutation.
func withGroupID(id int64) groupOption {
	return func(m *GroupMutation) {
		var (
			err   error
			once  sync.Once
			value *Group
		)
		m.oldValue = func(ctx context.Context) (*Group, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Group.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGroup sets the old Group of the mutation.
func withGroup(node *Group) groupOption {
	return func(m *GroupMutation) {
		m.oldValue = func(context.Context) (*Group, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GroupMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GroupMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Group.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *GroupMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GroupMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GroupMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GroupMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GroupMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GroupMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *GroupMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *GroupMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *GroupMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[group.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *GroupMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[group.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *GroupMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, group.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *GroupMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *GroupMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *GroupMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *GroupMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *GroupMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *GroupMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[group.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *GroupMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[group.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *GroupMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, group.FieldDescription)
}

// SetRateMultiplier sets the "rate_multiplier" field.
func (m *GroupMutation) SetRateMultiplier(f float64) {
	m.rate_multiplier = &f
	m.addrate_multiplier = nil
}

// RateMultiplier returns the value of the "rate_multiplier" field in the mutation.
func (m *GroupMutation) RateMultiplier() (r float64, exists bool) {
	v := m.rate_multiplier
	if v == nil {
		return
	}
	return *v, true
}

// OldRateMultiplier returns the old "rate_multiplier" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldRateMultiplier(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRateMultiplier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRateMultiplier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRateMultiplier: %w", err)
	}
	return oldValue.RateMultiplier, nil
}

// AddRateMultiplier adds f to the "rate_multiplier" field.
func (m *GroupMutation) AddRateMultiplier(f float64) {
	if m.addrate_multiplier != nil {
		*m.addrate_multiplier += f
	} else {
		m.addrate_multiplier = &f
	}
}

// AddedRateMultiplier returns the value that was added to the "rate_multiplier" field in this mutation.
func (m *GroupMutation) AddedRateMultiplier() (r float64, exists bool) {
	v := m.addrate_multiplier
	if v == nil {
		return
	}
	return *v, true
}

// ResetRateMultiplier resets all changes to the "rate_multiplier" field.
func (m *GroupMutation) ResetRateMultiplier() {
	m.rate_multiplier = nil
	m.addrate_multiplier = nil
}

// SetIsExclusive sets the "is_exclusive" field.
func (m *GroupMutation) SetIsExclusive(b bool) {
	m.is_exclusive = &b
}

// IsExclusive returns the value of the "is_exclusive" field in the mutation.
func (m *GroupMutation) IsExclusive() (r bool, exists bool) {
	v := m.is_exclusive
	if v == nil {
		return
	}
	return *v, true
}

// OldIsExclusive returns the old "is_exclusive" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldIsExclusive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsExclusive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsExclusive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsExclusive: %w", err)
	}
	return oldValue.IsExclusive, nil
}

// ResetIsExclusive resets all changes to the "is_exclusive" field.
func (m *GroupMutation) ResetIsExclusive() {
	m.is_exclusive = nil
}

// SetStatus sets the "status" field.
func (m *GroupMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *GroupMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *GroupMutation) ResetStatus() {
	m.status = nil
}

// SetPlatform sets the "platform" field.
func (m *GroupMutation) SetPlatform(s string) {
	m.platform = &s
}

// Platform returns the value of the "platform" field in the mutation.
func (m *GroupMutation) Platform() (r string, exists bool) {
	v := m.platform
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatform returns the old "platform" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldPlatform(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatform: %w", err)
	}
	return oldValue.Platform, nil
}

// ResetPlatform resets all changes to the "platform" field.
func (m *GroupMutation) ResetPlatform() {
	m.platform = nil
}

// SetSubscriptionType sets the "subscription_type" field.
func (m *GroupMutation) SetSubscriptionType(s string) {
	m.subscription_type = &s
}

// SubscriptionType returns the value of the "subscription_type" field in the mutation.
func (m *GroupMutation) SubscriptionType() (r string, exists bool) {
	v := m.subscription_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscriptionType returns the old "subscription_type" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldSubscriptionType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscriptionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscriptionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscriptionType: %w", err)
	}
	return oldValue.SubscriptionType, nil
}

// ResetSubscriptionType resets all changes to the "subscription_type" field.
func (m *GroupMutation) ResetSubscriptionType() {
	m.subscription_type = nil
}

// SetDailyLimitUsd sets the "daily_limit_usd" field.
func (m *GroupMutation) SetDailyLimitUsd(f float64) {
	m.daily_limit_usd = &f
	m.adddaily_limit_usd = nil
}

// DailyLimitUsd returns the value of the "daily_limit_usd" field in the mutation.
func (m *GroupMutation) DailyLimitUsd() (r float64, exists bool) {
	v := m.daily_limit_usd
	if v == nil {
		return
	}
	return *v, true
}

// OldDailyLimitUsd returns the old "daily_limit_usd" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldDailyLimitUsd(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDailyLimitUsd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDailyLimitUsd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDailyLimitUsd: %w", err)
	}
	return oldValue.DailyLimitUsd, nil
}

// AddDailyLimitUsd adds f to the "daily_limit_usd" field.
func (m *GroupMutation) AddDailyLimitUsd(f float64) {
	if m.adddaily_limit_usd != nil {
		*m.adddaily_limit_usd += f
	} else {
		m.adddaily_limit_usd = &f
	}
}

// AddedDailyLimitUsd returns the value that was added to the "daily_limit_usd" field in this mutation.
func (m *GroupMutation) AddedDailyLimitUsd() (r float64, exists bool) {
	v := m.adddaily_limit_usd
	if v == nil {
		return
	}
	return *v, true
}

// ClearDailyLimitUsd clears the value of the "daily_limit_usd" field.
func (m *GroupMutation) ClearDailyLimitUsd() {
	m.daily_limit_usd = nil
	m.adddaily_limit_usd = nil
	m.clearedFields[group.FieldDailyLimitUsd] = struct{}{}
}

// DailyLimitUsdCleared returns if the "daily_limit_usd" field was cleared in this mutation.
func (m *GroupMutation) DailyLimitUsdCleared() bool {
	_, ok := m.clearedFields[group.FieldDailyLimitUsd]
	return ok
}

// ResetDailyLimitUsd resets all changes to the "daily_limit_usd" field.
func (m *GroupMutation) ResetDailyLimitUsd() {
	m.daily_limit_usd = nil
	m.adddaily_limit_usd = nil
	delete(m.clearedFields, group.FieldDailyLimitUsd)
}

// SetWeeklyLimitUsd sets the "weekly_limit_usd" field.
func (m *GroupMutation) SetWeeklyLimitUsd(f float64) {
	m.weekly_limit_usd = &f
	m.addweekly_limit_usd = nil
}

// WeeklyLimitUsd returns the value of the "weekly_limit_usd" field in the mutation.
func (m *GroupMutation) WeeklyLimitUsd() (r float64, exists bool) {
	v := m.weekly_limit_usd
	if v == nil {
		return
	}
	return *v, true
}

// OldWeeklyLimitUsd returns the old "weekly_limit_usd" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldWeeklyLimitUsd(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeeklyLimitUsd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeeklyLimitUsd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeeklyLimitUsd: %w", err)
	}
	return oldValue.WeeklyLimitUsd, nil
}

// AddWeeklyLimitUsd adds f to the "weekly_limit_usd" field.
func (m *GroupMutation) AddWeeklyLimitUsd(f float64) {
	if m.addweekly_limit_usd != nil {
		*m.addweekly_limit_usd += f
	} else {
		m.addweekly_limit_usd = &f
	}
}

// AddedWeeklyLimitUsd returns the value that was added to the "weekly_limit_usd" field in this mutation.
func (m *GroupMutation) AddedWeeklyLimitUsd() (r float64, exists bool) {
	v := m.addweekly_limit_usd
	if v == nil {
		return
	}
	return *v, true
}

// ClearWeeklyLimitUsd clears the value of the "weekly_limit_usd" field.
func (m *GroupMutation) ClearWeeklyLimitUsd() {
	m.weekly_limit_usd = nil
	m.addweekly_limit_usd = nil
	m.clearedFields[group.FieldWeeklyLimitUsd] = struct{}{}
}

// WeeklyLimitUsdCleared returns if the "weekly_limit_usd" field was cleared in this mutation.
func (m *GroupMutation) WeeklyLimitUsdCleared() bool {
	_, ok := m.clearedFields[group.FieldWeeklyLimitUsd]
	return ok
}

// ResetWeeklyLimitUsd resets all changes to the "weekly_limit_usd" field.
func (m *GroupMutation) ResetWeeklyLimitUsd() {
	m.weekly_limit_usd = nil
	m.addweekly_limit_usd = nil
	delete(m.clearedFields, group.FieldWeeklyLimitUsd)
}

// SetMonthlyLimitUsd sets the "monthly_limit_usd" field.
func (m *GroupMutation) SetMonthlyLimitUsd(f float64) {
	m.monthly_limit_usd = &f
	m.addmonthly_limit_usd = nil
}

// MonthlyLimitUsd returns the value of the "monthly_limit_usd" field in the mutation.
func (m *GroupMutation) MonthlyLimitUsd() (r float64, exists bool) {
	v := m.monthly_limit_usd
	if v == nil {
		return
	}
	return *v, true
}

// OldMonthlyLimitUsd returns the old "monthly_limit_usd" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldMonthlyLimitUsd(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMonthlyLimitUsd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMonthlyLimitUsd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMonthlyLimitUsd: %w", err)
	}
	return oldValue.MonthlyLimitUsd, nil
}

// AddMonthlyLimitUsd adds f to the "monthly_limit_usd" field.
func (m *GroupMutation) AddMonthlyLimitUsd(f float64) {
	if m.addmonthly_limit_usd != nil {
		*m.addmonthly_limit_usd += f
	} else {
		m.addmonthly_limit_usd = &f
	}
}

// AddedMonthlyLimitUsd returns the value that was added to the "monthly_limit_usd" field in this mutation.
func (m *GroupMutation) AddedMonthlyLimitUsd() (r float64, exists bool) {
	v := m.addmonthly_limit_usd
	if v == nil {
		return
	}
	return *v, true
}

// ClearMonthlyLimitUsd clears the value of the "monthly_limit_usd" field.
func (m *GroupMutation) ClearMonthlyLimitUsd() {
	m.monthly_limit_usd = nil
	m.addmonthly_limit_usd = nil
	m.clearedFields[group.FieldMonthlyLimitUsd] = struct{}{}
}

// MonthlyLimitUsdCleared returns if the "monthly_limit_usd" field was cleared in this mutation.
func (m *GroupMutation) MonthlyLimitUsdCleared() bool {
	_, ok := m.clearedFields[group.FieldMonthlyLimitUsd]
	return ok
}

// ResetMonthlyLimitUsd resets all changes to the "monthly_limit_usd" field.
func (m *GroupMutation) ResetMonthlyLimitUsd() {
	m.monthly_limit_usd = nil
	m.addmonthly_limit_usd = nil
	delete(m.clearedFields, group.FieldMonthlyLimitUsd)
}

// SetDefaultValidityDays sets the "default_validity_days" field.
func (m *GroupMutation) SetDefaultValidityDays(i int) {
	m.default_validity_days = &i
	m.adddefault_validity_days = nil
}

// DefaultValidityDays returns the value of the "default_validity_days" field in the mutation.
func (m *GroupMutation) DefaultValidityDays() (r int, exists bool) {
	v := m.default_validity_days
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultValidityDays returns the old "default_validity_days" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldDefaultValidityDays(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultValidityDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultValidityDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultValidityDays: %w", err)
	}
	return oldValue.DefaultValidityDays, nil
}

// AddDefaultValidityDays adds i to the "default_validity_days" field.
func (m *GroupMutation) AddDefaultValidityDays(i int) {
	if m.adddefault_validity_days != nil {
		*m.adddefault_validity_days += i
	} else {
		m.adddefault_validity_days = &i
	}
}

// AddedDefaultValidityDays returns the value that was added to the "default_validity_days" field in this mutation.
func (m *GroupMutation) AddedDefaultValidityDays() (r int, exists bool) {
	v := m.adddefault_validity_days
	if v == nil {
		return
	}
	return *v, true
}

// ResetDefaultValidityDays resets all changes to the "default_validity_days" field.
func (m *GroupMutation) ResetDefaultValidityDays() {
	m.default_validity_days = nil
	m.adddefault_validity_days = nil
}

// SetImagePrice1k sets the "image_price_1k" field.
func (m *GroupMutation) SetImagePrice1k(f float64) {
	m.image_price_1k = &f
	m.addimage_price_1k = nil
}

// ImagePrice1k returns the value of the "image_price_1k" field in the mutation.
func (m *GroupMutation) ImagePrice1k() (r float64, exists bool) {
	v := m.image_price_1k
	if v == nil {
		return
	}
	return *v, true
}

// OldImagePrice1k returns the old "image_price_1k" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldImagePrice1k(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImagePrice1k is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImagePrice1k requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImagePrice1k: %w", err)
	}
	return oldValue.ImagePrice1k, nil
}

// AddImagePrice1k adds f to the "image_price_1k" field.
func (m *GroupMutation) AddImagePrice1k(f float64) {
	if m.addimage_price_1k != nil {
		*m.addimage_price_1k += f
	} else {
		m.addimage_price_1k = &f
	}
}

// AddedImagePrice1k returns the value that was added to the "image_price_1k" field in this mutation.
func (m *GroupMutation) AddedImagePrice1k() (r float64, exists bool) {
	v := m.addimage_price_1k
	if v == nil {
		return
	}
	return *v, true
}

// ClearImagePrice1k clears the value of the "image_price_1k" field.
func (m *GroupMutation) ClearImagePrice1k() {
	m.image_price_1k = nil
	m.addimage_price_1k = nil
	m.clearedFields[group.FieldImagePrice1k] = struct{}{}
}

// ImagePrice1kCleared returns if the "image_price_1k" field was cleared in this mutation.
func (m *GroupMutation) ImagePrice1kCleared() bool {
	_, ok := m.clearedFields[group.FieldImagePrice1k]
	return ok
}

// ResetImagePrice1k resets all changes to the "image_price_1k" field.
func (m *GroupMutation) ResetImagePrice1k() {
	m.image_price_1k = nil
	m.addimage_price_1k = nil
	delete(m.clearedFields, group.FieldImagePrice1k)
}

// SetImagePrice2k sets the "image_price_2k" field.
func (m *GroupMutation) SetImagePrice2k(f float64) {
	m.image_price_2k = &f
	m.addimage_price_2k = nil
}

// ImagePrice2k returns the value of the "image_price_2k" field in the mutation.
func (m *GroupMutation) ImagePrice2k() (r float64, exists bool) {
	v := m.image_price_2k
	if v == nil {
		return
	}
	return *v, true
}

// OldImagePrice2k returns the old "image_price_2k" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldImagePrice2k(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImagePrice2k is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImagePrice2k requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImagePrice2k: %w", err)
	}
	return oldValue.ImagePrice2k, nil
}

// AddImagePrice2k adds f to the "image_price_2k" field.
func (m *GroupMutation) AddImagePrice2k(f float64) {
	if m.addimage_price_2k != nil {
		*m.addimage_price_2k += f
	} else {
		m.addimage_price_2k = &f
	}
}

// AddedImagePrice2k returns the value that was added to the "image_price_2k" field in this mutation.
func (m *GroupMutation) AddedImagePrice2k() (r float64, exists bool) {
	v := m.addimage_price_2k
	if v == nil {
		return
	}
	return *v, true
}

// ClearImagePrice2k clears the value of the "image_price_2k" field.
func (m *GroupMutation) ClearImagePrice2k() {
	m.image_price_2k = nil
	m.addimage_price_2k = nil
	m.clearedFields[group.FieldImagePrice2k] = struct{}{}
}

// ImagePrice2kCleared returns if the "image_price_2k" field was cleared in this mutation.
func (m *GroupMutation) ImagePrice2kCleared() bool {
	_, ok := m.clearedFields[group.FieldImagePrice2k]
	return ok
}

// ResetImagePrice2k resets all changes to the "image_price_2k" field.
func (m *GroupMutation) ResetImagePrice2k() {
	m.image_price_2k = nil
	m.addimage_price_2k = nil
	delete(m.clearedFields, group.FieldImagePrice2k)
}

// SetImagePrice4k sets the "image_price_4k" field.
func (m *GroupMutation) SetImagePrice4k(f float64) {
	m.image_price_4k = &f
	m.addimage_price_4k = nil
}

// ImagePrice4k returns the value of the "image_price_4k" field in the mutation.
func (m *GroupMutation) ImagePrice4k() (r float64, exists bool) {
	v := m.image_price_4k
	if v == nil {
		return
	}
	return *v, true
}

// OldImagePrice4k returns the old "image_price_4k" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldImagePrice4k(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImagePrice4k is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImagePrice4k requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImagePrice4k: %w", err)
	}
	return oldValue.ImagePrice4k, nil
}

// AddImagePrice4k adds f to the "image_price_4k" field.
func (m *GroupMutation) AddImagePrice4k(f float64) {
	if m.addimage_price_4k != nil {
		*m.addimage_price_4k += f
	} else {
		m.addimage_price_4k = &f
	}
}

// AddedImagePrice4k returns the value that was added to the "image_price_4k" field in this mutation.
func (m *GroupMutation) AddedImagePrice4k() (r float64, exists bool) {
	v := m.addimage_price_4k
	if v == nil {
		return
	}
	return *v, true
}

// ClearImagePrice4k clears the value of the "image_price_4k" field.
func (m *GroupMutation) ClearImagePrice4k() {
	m.image_price_4k = nil
	m.addimage_price_4k = nil
	m.clearedFields[group.FieldImagePrice4k] = struct{}{}
}

// ImagePrice4kCleared returns if the "image_price_4k" field was cleared in this mutation.
func (m *GroupMutation) ImagePrice4kCleared() bool {
	_, ok := m.clearedFields[group.FieldImagePrice4k]
	return ok
}

// ResetImagePrice4k resets all changes to the "image_price_4k" field.
func (m *GroupMutation) ResetImagePrice4k() {
	m.image_price_4k = nil
	m.addimage_price_4k = nil
	delete(m.clearedFields, group.FieldImagePrice4k)
}

// SetClaudeCodeOnly sets the "claude_code_only" field.
func (m *GroupMutation) SetClaudeCodeOnly(b bool) {
	m.claude_code_only = &b
}

// ClaudeCodeOnly returns the value of the "claude_code_only" field in the mutation.
func (m *GroupMutation) ClaudeCodeOnly() (r bool, exists bool) {
	v := m.claude_code_only
	if v == nil {
		return
	}
	return *v, true
}

// OldClaudeCodeOnly returns the old "claude_code_only" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldClaudeCodeOnly(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClaudeCodeOnly is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClaudeCodeOnly requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClaudeCodeOnly: %w", err)
	}
	return oldValue.ClaudeCodeOnly, nil
}

// ResetClaudeCodeOnly resets all changes to the "claude_code_only" field.
func (m *GroupMutation) ResetClaudeCodeOnly() {
	m.claude_code_only = nil
}

// SetFallbackGroupID sets the "fallback_group_id" field.
func (m *GroupMutation) SetFallbackGroupID(i int64) {
	m.fallback_group_id = &i
	m.addfallback_group_id = nil
}

// FallbackGroupID returns the value of the "fallback_group_id" field in the mutation.
func (m *GroupMutation) FallbackGroupID() (r int64, exists bool) {
	v := m.fallback_group_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFallbackGroupID returns the old "fallback_group_id" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldFallbackGroupID(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFallbackGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFallbackGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFallbackGroupID: %w", err)
	}
	return oldValue.FallbackGroupID, nil
}

// AddFallbackGroupID adds i to the "fallback_group_id" field.
func (m *GroupMutation) AddFallbackGroupID(i int64) {
	if m.addfallback_group_id != nil {
		*m.addfallback_group_id += i
	} else {
		m.addfallback_group_id = &i
	}
}

// AddedFallbackGroupID returns the value that was added to the "fallback_group_id" field in this mutation.
func (m *GroupMutation) AddedFallbackGroupID() (r int64, exists bool) {
	v := m.addfallback_group_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearFallbackGroupID clears the value of the "fallback_group_id" field.
func (m *GroupMutation) ClearFallbackGroupID() {
	m.fallback_group_id = nil
	m.addfallback_group_id = nil
	m.clearedFields[group.FieldFallbackGroupID] = struct{}{}
}

// FallbackGroupIDCleared returns if the "fallback_group_id" field was cleared in this mutation.
func (m *GroupMutation) FallbackGroupIDCleared() bool {
	_, ok := m.clearedFields[group.FieldFallbackGroupID]
	return ok
}

// ResetFallbackGroupID resets all changes to the "fallback_group_id" field.
func (m *GroupMutation) ResetFallbackGroupID() {
	m.fallback_group_id = nil
	m.addfallback_group_id = nil
	delete(m.clearedFields, group.FieldFallbackGroupID)
}

// SetFallbackGroupIDOnInvalidRequest sets the "fallback_group_id_on_invalid_request" field.
func (m *GroupMutation) SetFallbackGroupIDOnInvalidRequest(i int64) {
	m.fallback_group_id_on_invalid_request = &i
	m.addfallback_group_id_on_invalid_request = nil
}

// FallbackGroupIDOnInvalidRequest returns the value of the "fallback_group_id_on_invalid_request" field in the mutation.
func (m *GroupMutation) FallbackGroupIDOnInvalidRequest() (r int64, exists bool) {
	v := m.fallback_group_id_on_invalid_request
	if v == nil {
		return
	}
	return *v, true
}

// OldFallbackGroupIDOnInvalidRequest returns the old "fallback_group_id_on_invalid_request" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldFallbackGroupIDOnInvalidRequest(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFallbackGroupIDOnInvalidRequest is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFallbackGroupIDOnInvalidRequest requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFallbackGroupIDOnInvalidRequest: %w", err)
	}
	return oldValue.FallbackGroupIDOnInvalidRequest, nil
}

// AddFallbackGroupIDOnInvalidRequest adds i to the "fallback_group_id_on_invalid_request" field.
func (m *GroupMutation) AddFallbackGroupIDOnInvalidRequest(i int64) {
	if m.addfallback_group_id_on_invalid_request != nil {
		*m.addfallback_group_id_on_invalid_request += i
	} else {
		m.addfallback_group_id_on_invalid_request = &i
	}
}

// AddedFallbackGroupIDOnInvalidRequest returns the value that was added to the "fallback_group_id_on_invalid_request" field in this mutation.
func (m *GroupMutation) AddedFallbackGroupIDOnInvalidRequest() (r int64, exists bool) {
	v := m.addfallback_group_id_on_invalid_request
	if v == nil {
		return
	}
	return *v, true
}

// ClearFallbackGroupIDOnInvalidRequest clears the value of the "fallback_group_id_on_invalid_request" field.
func (m *GroupMutation) ClearFallbackGroupIDOnInvalidRequest() {
	m.fallback_group_id_on_invalid_request = nil
	m.addfallback_group_id_on_invalid_request = nil
	m.clearedFields[group.FieldFallbackGroupIDOnInvalidRequest] = struct{}{}
}

// FallbackGroupIDOnInvalidRequestCleared returns if the "fallback_group_id_on_invalid_request" field was cleared in this mutation.
func (m *GroupMutation) FallbackGroupIDOnInvalidRequestCleared() bool {
	_, ok := m.clearedFields[group.FieldFallbackGroupIDOnInvalidRequest]
	return ok
}

// ResetFallbackGroupIDOnInvalidRequest resets all changes to the "fallback_group_id_on_invalid_request" field.
func (m *GroupMutation) ResetFallbackGroupIDOnInvalidRequest() {
	m.fallback_group_id_on_invalid_request = nil
	m.addfallback_group_id_on_invalid_request = nil
	delete(m.clearedFields, group.FieldFallbackGroupIDOnInvalidRequest)
}

// SetModelRouting sets the "model_routing" field.
func (m *GroupMutation) SetModelRouting(value map[string][]int64) {
	m.model_routing = &value
}

// ModelRouting returns the value of the "model_routing" field in the mutation.
func (m *GroupMutation) ModelRouting() (r map[string][]int64, exists bool) {
	v := m.model_routing
	if v == nil {
		return
	}
	return *v, true
}

// OldModelRouting returns the old "model_routing" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldModelRouting(ctx context.Context) (v map[string][]int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModelRouting is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModelRouting requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModelRouting: %w", err)
	}
	return oldValue.ModelRouting, nil
}

// ClearModelRouting clears the value of the "model_routing" field.
func (m *GroupMutation) ClearModelRouting() {
	m.model_routing = nil
	m.clearedFields[group.FieldModelRouting] = struct{}{}
}

// ModelRoutingCleared returns if the "model_routing" field was cleared in this mutation.
func (m *GroupMutation) ModelRoutingCleared() bool {
	_, ok := m.clearedFields[group.FieldModelRouting]
	return ok
}

// ResetModelRouting resets all changes to the "model_routing" field.
func (m *GroupMutation) ResetModelRouting() {
	m.model_routing = nil
	delete(m.clearedFields, group.FieldModelRouting)
}

// SetModelRoutingEnabled sets the "model_routing_enabled" field.
func (m *GroupMutation) SetModelRoutingEnabled(b bool) {
	m.model_routing_enabled = &b
}

// ModelRoutingEnabled returns the value of the "model_routing_enabled" field in the mutation.
func (m *GroupMutation) ModelRoutingEnabled() (r bool, exists bool) {
	v := m.model_routing_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldModelRoutingEnabled returns the old "model_routing_enabled" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldModelRoutingEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModelRoutingEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModelRoutingEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModelRoutingEnabled: %w", err)
	}
	return oldValue.ModelRoutingEnabled, nil
}

// ResetModelRoutingEnabled resets all changes to the "model_routing_enabled" field.
func (m *GroupMutation) ResetModelRoutingEnabled() {
	m.model_routing_enabled = nil
}

// SetMcpXMLInject sets the "mcp_xml_inject" field.
func (m *GroupMutation) SetMcpXMLInject(b bool) {
	m.mcp_xml_inject = &b
}

// McpXMLInject returns the value of the "mcp_xml_inject" field in the mutation.
func (m *GroupMutation) McpXMLInject() (r bool, exists bool) {
	v := m.mcp_xml_inject
	if v == nil {
		return
	}
	return *v, true
}

// OldMcpXMLInject returns the old "mcp_xml_inject" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldMcpXMLInject(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMcpXMLInject is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMcpXMLInject requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMcpXMLInject: %w", err)
	}
	return oldValue.McpXMLInject, nil
}

// ResetMcpXMLInject resets all changes to the "mcp_xml_inject" field.
func (m *GroupMutation) ResetMcpXMLInject() {
	m.mcp_xml_inject = nil
}

// SetSupportedModelScopes sets the "supported_model_scopes" field.
func (m *GroupMutation) SetSupportedModelScopes(s []string) {
	m.supported_model_scopes = &s
	m.appendsupported_model_scopes = nil
}

// SupportedModelScopes returns the value of the "supported_model_scopes" field in the mutation.
func (m *GroupMutation) SupportedModelScopes() (r []string, exists bool) {
	v := m.supported_model_scopes
	if v == nil {
		return
	}
	return *v, true
}

// OldSupportedModelScopes returns the old "supported_model_scopes" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldSupportedModelScopes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupportedModelScopes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupportedModelScopes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupportedModelScopes: %w", err)
	}
	return oldValue.SupportedModelScopes, nil
}

// AppendSupportedModelScopes adds s to the "supported_model_scopes" field.
func (m *GroupMutation) AppendSupportedModelScopes(s []string) {
	m.appendsupported_model_scopes = append(m.appendsupported_model_scopes, s...)
}

// AppendedSupportedModelScopes returns the list of values that were appended to the "supported_model_scopes" field in this mutation.
func (m *GroupMutation) AppendedSupportedModelScopes() ([]string, bool) {
	if len(m.appendsupported_model_scopes) == 0 {
		return nil, false
	}
	return m.appendsupported_model_scopes, true
}

// ResetSupportedModelScopes resets all changes to the "supported_model_scopes" field.
func (m *GroupMutation) ResetSupportedModelScopes() {
	m.supported_model_scopes = nil
	m.appendsupported_model_scopes = nil
}

// SetPrice sets the "price" field.
func (m *GroupMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *GroupMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldPrice(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *GroupMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *GroupMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ClearPrice clears the value of the "price" field.
func (m *GroupMutation) ClearPrice() {
	m.price = nil
	m.addprice = nil
	m.clearedFields[group.FieldPrice] = struct{}{}
}

// PriceCleared returns if the "price" field was cleared in this mutation.
func (m *GroupMutation) PriceCleared() bool {
	_, ok := m.clearedFields[group.FieldPrice]
	return ok
}

// ResetPrice resets all changes to the "price" field.
func (m *GroupMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
	delete(m.clearedFields, group.FieldPrice)
}

// SetIsPurchasable sets the "is_purchasable" field.
func (m *GroupMutation) SetIsPurchasable(b bool) {
	m.is_purchasable = &b
}

// IsPurchasable returns the value of the "is_purchasable" field in the mutation.
func (m *GroupMutation) IsPurchasable() (r bool, exists bool) {
	v := m.is_purchasable
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPurchasable returns the old "is_purchasable" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldIsPurchasable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPurchasable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPurchasable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPurchasable: %w", err)
	}
	return oldValue.IsPurchasable, nil
}

// ResetIsPurchasable resets all changes to the "is_purchasable" field.
func (m *GroupMutation) ResetIsPurchasable() {
	m.is_purchasable = nil
}

// SetSortOrder sets the "sort_order" field.
func (m *GroupMutation) SetSortOrder(i int) {
	m.sort_order = &i
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *GroupMutation) SortOrder() (r int, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldSortOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds i to the "sort_order" field.
func (m *GroupMutation) AddSortOrder(i int) {
	if m.addsort_order != nil {
		*m.addsort_order += i
	} else {
		m.addsort_order = &i
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *GroupMutation) AddedSortOrder() (r int, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *GroupMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
}

// SetIsRecommended sets the "is_recommended" field.
func (m *GroupMutation) SetIsRecommended(b bool) {
	m.is_recommended = &b
}

// IsRecommended returns the value of the "is_recommended" field in the mutation.
func (m *GroupMutation) IsRecommended() (r bool, exists bool) {
	v := m.is_recommended
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRecommended returns the old "is_recommended" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldIsRecommended(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsRecommended is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsRecommended requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRecommended: %w", err)
	}
	return oldValue.IsRecommended, nil
}

// ResetIsRecommended resets all changes to the "is_recommended" field.
func (m *GroupMutation) ResetIsRecommended() {
	m.is_recommended = nil
}

// SetExternalBuyURL sets the "external_buy_url" field.
func (m *GroupMutation) SetExternalBuyURL(s string) {
	m.external_buy_url = &s
}

// ExternalBuyURL returns the value of the "external_buy_url" field in the mutation.
func (m *GroupMutation) ExternalBuyURL() (r string, exists bool) {
	v := m.external_buy_url
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalBuyURL returns the old "external_buy_url" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldExternalBuyURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalBuyURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalBuyURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalBuyURL: %w", err)
	}
	return oldValue.ExternalBuyURL, nil
}

// ClearExternalBuyURL clears the value of the "external_buy_url" field.
func (m *GroupMutation) ClearExternalBuyURL() {
	m.external_buy_url = nil
	m.clearedFields[group.FieldExternalBuyURL] = struct{}{}
}

// ExternalBuyURLCleared returns if the "external_buy_url" field was cleared in this mutation.
func (m *GroupMutation) ExternalBuyURLCleared() bool {
	_, ok := m.clearedFields[group.FieldExternalBuyURL]
	return ok
}

// ResetExternalBuyURL resets all changes to the "external_buy_url" field.
func (m *GroupMutation) ResetExternalBuyURL() {
	m.external_buy_url = nil
	delete(m.clearedFields, group.FieldExternalBuyURL)
}

// SetOwnerID sets the "owner_id" field.
func (m *GroupMutation) SetOwnerID(i int64) {
	m.owner_id = &i
	m.addowner_id = nil
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *GroupMutation) OwnerID() (r int64, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldOwnerID(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// AddOwnerID adds i to the "owner_id" field.
func (m *GroupMutation) AddOwnerID(i int64) {
	if m.addowner_id != nil {
		*m.addowner_id += i
	} else {
		m.addowner_id = &i
	}
}

// AddedOwnerID returns the value that was added to the "owner_id" field in this mutation.
func (m *GroupMutation) AddedOwnerID() (r int64, exists bool) {
	v := m.addowner_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *GroupMutation) ClearOwnerID() {
	m.owner_id = nil
	m.addowner_id = nil
	m.clearedFields[group.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *GroupMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[group.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *GroupMutation) ResetOwnerID() {
	m.owner_id = nil
	m.addowner_id = nil
	delete(m.clearedFields, group.FieldOwnerID)
}

// SetSourceGroupID sets the "source_group_id" field.
func (m *GroupMutation) SetSourceGroupID(i int64) {
	m.source_group_id = &i
	m.addsource_group_id = nil
}

// SourceGroupID returns the value of the "source_group_id" field in the mutation.
func (m *GroupMutation) SourceGroupID() (r int64, exists bool) {
	v := m.source_group_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceGroupID returns the old "source_group_id" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldSourceGroupID(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceGroupID: %w", err)
	}
	return oldValue.SourceGroupID, nil
}

// AddSourceGroupID adds i to the "source_group_id" field.
func (m *GroupMutation) AddSourceGroupID(i int64) {
	if m.addsource_group_id != nil {
		*m.addsource_group_id += i
	} else {
		m.addsource_group_id = &i
	}
}

// AddedSourceGroupID returns the value that was added to the "source_group_id" field in this mutation.
func (m *GroupMutation) AddedSourceGroupID() (r int64, exists bool) {
	v := m.addsource_group_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearSourceGroupID clears the value of the "source_group_id" field.
func (m *GroupMutation) ClearSourceGroupID() {
	m.source_group_id = nil
	m.addsource_group_id = nil
	m.clearedFields[group.FieldSourceGroupID] = struct{}{}
}

// SourceGroupIDCleared returns if the "source_group_id" field was cleared in this mutation.
func (m *GroupMutation) SourceGroupIDCleared() bool {
	_, ok := m.clearedFields[group.FieldSourceGroupID]
	return ok
}

// ResetSourceGroupID resets all changes to the "source_group_id" field.
func (m *GroupMutation) ResetSourceGroupID() {
	m.source_group_id = nil
	m.addsource_group_id = nil
	delete(m.clearedFields, group.FieldSourceGroupID)
}

// SetResellerTemplate sets the "reseller_template" field.
func (m *GroupMutation) SetResellerTemplate(b bool) {
	m.reseller_template = &b
}

// ResellerTemplate returns the value of the "reseller_template" field in the mutation.
func (m *GroupMutation) ResellerTemplate() (r bool, exists bool) {
	v := m.reseller_template
	if v == nil {
		return
	}
	return *v, true
}

// OldResellerTemplate returns the old "reseller_template" field's value of the Group entity.
// If the Group object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GroupMutation) OldResellerTemplate(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResellerTemplate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResellerTemplate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResellerTemplate: %w", err)
	}
	return oldValue.ResellerTemplate, nil
}

// ResetResellerTemplate resets all changes to the "reseller_template" field.
func (m *GroupMutation) ResetResellerTemplate() {
	m.reseller_template = nil
}

// AddAPIKeyIDs adds the "api_keys" edge to the APIKey entity by ids.
func (m *GroupMutation) AddAPIKeyIDs(ids ...int64) {
	if m.api_keys == nil {
		m.api_keys = make(map[int64]struct{})
	}
	for i := range ids {
		m.api_keys[ids[i]] = struct{}{}
	}
}

// ClearAPIKeys clears the "api_keys" edge to the APIKey entity.
func (m *GroupMutation) ClearAPIKeys() {
	m.clearedapi_keys = true
}

// APIKeysCleared reports if the "api_keys" edge to the APIKey entity was cleared.
func (m *GroupMutation) APIKeysCleared() bool {
	return m.clearedapi_keys
}

// RemoveAPIKeyIDs removes the "api_keys" edge to the APIKey entity by IDs.
func (m *GroupMutation) RemoveAPIKeyIDs(ids ...int64) {
	if m.removedapi_keys == nil {
		m.removedapi_keys = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.api_keys, ids[i])
		m.removedapi_keys[ids[i]] = struct{}{}
	}
}

// RemovedAPIKeys returns the removed IDs of the "api_keys" edge to the APIKey entity.
func (m *GroupMutation) RemovedAPIKeysIDs() (ids []int64) {
	for id := range m.removedapi_keys {
		ids = append(ids, id)
	}
	return
}

// APIKeysIDs returns the "api_keys" edge IDs in the mutation.
func (m *GroupMutation) APIKeysIDs() (ids []int64) {
	for id := range m.api_keys {
		ids = append(ids, id)
	}
	return
}

// ResetAPIKeys resets all changes to the "api_keys" edge.
func (m *GroupMutation) ResetAPIKeys() {
	m.api_keys = nil
	m.clearedapi_keys = false
	m.removedapi_keys = nil
}

// AddRedeemCodeIDs adds the "redeem_codes" edge to the RedeemCode entity by ids.
func (m *GroupMutation) AddRedeemCodeIDs(ids ...int64) {
	if m.redeem_codes == nil {
		m.redeem_codes = make(map[int64]struct{})
	}
	for i := range ids {
		m.redeem_codes[ids[i]] = struct{}{}
	}
}

// ClearRedeemCodes clears the "redeem_codes" edge to the RedeemCode entity.
func (m *GroupMutation) ClearRedeemCodes() {
	m.clearedredeem_codes = true
}

// RedeemCodesCleared reports if the "redeem_codes" edge to the RedeemCode entity was cleared.
func (m *GroupMutation) RedeemCodesCleared() bool {
	return m.clearedredeem_codes
}

// RemoveRedeemCodeIDs removes the "redeem_codes" edge to the RedeemCode entity by IDs.
func (m *GroupMutation) RemoveRedeemCodeIDs(ids ...int64) {
	if m.removedredeem_codes == nil {
		m.removedredeem_codes = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.redeem_codes, ids[i])
		m.removedredeem_codes[ids[i]] = struct{}{}
	}
}

// RemovedRedeemCodes returns the removed IDs of the "redeem_codes" edge to the RedeemCode entity.
func (m *GroupMutation) RemovedRedeemCodesIDs() (ids []int64) {
	for id := range m.removedredeem_codes {
		ids = append(ids, id)
	}
	return
}

// RedeemCodesIDs returns the "redeem_codes" edge IDs in the mutation.
func (m *GroupMutation) RedeemCodesIDs() (ids []int64) {
	for id := range m.redeem_codes {
		ids = append(ids, id)
	}
	return
}

// ResetRedeemCodes resets all changes to the "redeem_codes" edge.
func (m *GroupMutation) ResetRedeemCodes() {
	m.redeem_codes = nil
	m.clearedredeem_codes = false
	m.removedredeem_codes = nil
}

// AddSubscriptionIDs adds the "subscriptions" edge to the UserSubscription entity by ids.
func (m *GroupMutation) AddSubscriptionIDs(ids ...int64) {
	if m.subscriptions == nil {
		m.subscriptions = make(map[int64]struct{})
	}
	for i := range ids {
		m.subscriptions[ids[i]] = struct{}{}
	}
}

// ClearSubscriptions clears the "subscriptions" edge to the UserSubscription entity.
func (m *GroupMutation) ClearSubscriptions() {
	m.clearedsubscriptions = true
}

// SubscriptionsCleared reports if the "subscriptions" edge to the UserSubscription entity was cleared.
func (m *GroupMutation) SubscriptionsCleared() bool {
	return m.clearedsubscriptions
}

// RemoveSubscriptionIDs removes the "subscriptions" edge to the UserSubscription entity by IDs.
func (m *GroupMutation) RemoveSubscriptionIDs(ids ...int64) {
	if m.removedsubscriptions == nil {
		m.removedsubscriptions = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.subscriptions, ids[i])
		m.removedsubscriptions[ids[i]] = struct{}{}
	}
}

// RemovedSubscriptions returns the removed IDs of the "subscriptions" edge to the UserSubscription entity.
func (m *GroupMutation) RemovedSubscriptionsIDs() (ids []int64) {
	for id := range m.removedsubscriptions {
		ids = append(ids, id)
	}
	return
}

// SubscriptionsIDs returns the "subscriptions" edge IDs in the mutation.
func (m *GroupMutation) SubscriptionsIDs() (ids []int64) {
	for id := range m.subscriptions {
		ids = append(ids, id)
	}
	return
}

// ResetSubscriptions resets all changes to the "subscriptions" edge.
func (m *GroupMutation) ResetSubscriptions() {
	m.subscriptions = nil
	m.clearedsubscriptions = false
	m.removedsubscriptions = nil
}

// AddUsageLogIDs adds the "usage_logs" edge to the UsageLog entity by ids.
func (m *GroupMutation) AddUsageLogIDs(ids ...int64) {
	if m.usage_logs == nil {
		m.usage_logs = make(map[int64]struct{})
	}
	for i := range ids {
		m.usage_logs[ids[i]] = struct{}{}
	}
}

// ClearUsageLogs clears the "usage_logs" edge to the UsageLog entity.
func (m *GroupMutation) ClearUsageLogs() {
	m.clearedusage_logs = true
}

// UsageLogsCleared reports if the "usage_logs" edge to the UsageLog entity was cleared.
func (m *GroupMutation) UsageLogsCleared() bool {
	return m.clearedusage_logs
}

// RemoveUsageLogIDs removes the "usage_logs" edge to the UsageLog entity by IDs.
func (m *GroupMutation) RemoveUsageLogIDs(ids ...int64) {
	if m.removedusage_logs == nil {
		m.removedusage_logs = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.usage_logs, ids[i])
		m.removedusage_logs[ids[i]] = struct{}{}
	}
}

// RemovedUsageLogs returns the removed IDs of the "usage_logs" edge to the UsageLog entity.
func (m *GroupMutation) RemovedUsageLogsIDs() (ids []int64) {
	for id := range m.removedusage_logs {
		ids = append(ids, id)
	}
	return
}

// UsageLogsIDs returns the "usage_logs" edge IDs in the mutation.
func (m *GroupMutation) UsageLogsIDs() (ids []int64) {
	for id := range m.usage_logs {
		ids = append(ids, id)
	}
	return
}

// ResetUsageLogs resets all changes to the "usage_logs" edge.
func (m *GroupMutation) ResetUsageLogs() {
	m.usage_logs = nil
	m.clearedusage_logs = false
	m.removedusage_logs = nil
}

// AddOrderIDs adds the "orders" edge to the Order entity by ids.
func (m *GroupMutation) AddOrderIDs(ids ...int64) {
	if m.orders == nil {
		m.orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.orders[ids[i]] = struct{}{}
	}
}

// ClearOrders clears the "orders" edge to the Order entity.
func (m *GroupMutation) ClearOrders() {
	m.clearedorders = true
}

// OrdersCleared reports if the "orders" edge to the Order entity was cleared.
func (m *GroupMutation) OrdersCleared() bool {
	return m.clearedorders
}

// RemoveOrderIDs removes the "orders" edge to the Order entity by IDs.
func (m *GroupMutation) RemoveOrderIDs(ids ...int64) {
	if m.removedorders == nil {
		m.removedorders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.orders, ids[i])
		m.removedorders[ids[i]] = struct{}{}
	}
}

// RemovedOrders returns the removed IDs of the "orders" edge to the Order entity.
func (m *GroupMutation) RemovedOrdersIDs() (ids []int64) {
	for id := range m.removedorders {
		ids = append(ids, id)
	}
	return
}

// OrdersIDs returns the "orders" edge IDs in the mutation.
func (m *GroupMutation) OrdersIDs() (ids []int64) {
	for id := range m.orders {
		ids = append(ids, id)
	}
	return
}

// ResetOrders resets all changes to the "orders" edge.
func (m *GroupMutation) ResetOrders() {
	m.orders = nil
	m.clearedorders = false
	m.removedorders = nil
}

// AddAccountIDs adds the "accounts" edge to the Account entity by ids.
func (m *GroupMutation) AddAccountIDs(ids ...int64) {
	if m.accounts == nil {
		m.accounts = make(map[int64]struct{})
	}
	for i := range ids {
		m.accounts[ids[i]] = struct{}{}
	}
}

// ClearAccounts clears the "accounts" edge to the Account entity.
func (m *GroupMutation) ClearAccounts() {
	m.clearedaccounts = true
}

// AccountsCleared reports if the "accounts" edge to the Account entity was cleared.
func (m *GroupMutation) AccountsCleared() bool {
	return m.clearedaccounts
}

// RemoveAccountIDs removes the "accounts" edge to the Account entity by IDs.
func (m *GroupMutation) RemoveAccountIDs(ids ...int64) {
	if m.removedaccounts == nil {
		m.removedaccounts = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.accounts, ids[i])
		m.removedaccounts[ids[i]] = struct{}{}
	}
}

// RemovedAccounts returns the removed IDs of the "accounts" edge to the Account entity.
func (m *GroupMutation) RemovedAccountsIDs() (ids []int64) {
	for id := range m.removedaccounts {
		ids = append(ids, id)
	}
	return
}

// AccountsIDs returns the "accounts" edge IDs in the mutation.
func (m *GroupMutation) AccountsIDs() (ids []int64) {
	for id := range m.accounts {
		ids = append(ids, id)
	}
	return
}

// ResetAccounts resets all changes to the "accounts" edge.
func (m *GroupMutation) ResetAccounts() {
	m.accounts = nil
	m.clearedaccounts = false
	m.removedaccounts = nil
}

// AddAllowedUserIDs adds the "allowed_users" edge to the User entity by ids.
func (m *GroupMutation) AddAllowedUserIDs(ids ...int64) {
	if m.allowed_users == nil {
		m.allowed_users = make(map[int64]struct{})
	}
	for i := range ids {
		m.allowed_users[ids[i]] = struct{}{}
	}
}

// ClearAllowedUsers clears the "allowed_users" edge to the User entity.
func (m *GroupMutation) ClearAllowedUsers() {
	m.clearedallowed_users = true
}

// AllowedUsersCleared reports if the "allowed_users" edge to the User entity was cleared.
func (m *GroupMutation) AllowedUsersCleared() bool {
	return m.clearedallowed_users
}

// RemoveAllowedUserIDs removes the "allowed_users" edge to the User entity by IDs.
func (m *GroupMutation) RemoveAllowedUserIDs(ids ...int64) {
	if m.removedallowed_users == nil {
		m.removedallowed_users = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.allowed_users, ids[i])
		m.removedallowed_users[ids[i]] = struct{}{}
	}
}

// RemovedAllowedUsers returns the removed IDs of the "allowed_users" edge to the User entity.
func (m *GroupMutation) RemovedAllowedUsersIDs() (ids []int64) {
	for id := range m.removedallowed_users {
		ids = append(ids, id)
	}
	return
}

// AllowedUsersIDs returns the "allowed_users" edge IDs in the mutation.
func (m *GroupMutation) AllowedUsersIDs() (ids []int64) {
	for id := range m.allowed_users {
		ids = append(ids, id)
	}
	return
}

// ResetAllowedUsers resets all changes to the "allowed_users" edge.
func (m *GroupMutation) ResetAllowedUsers() {
	m.allowed_users = nil
	m.clearedallowed_users = false
	m.removedallowed_users = nil
}

// Where appends a list predicates to the GroupMutation builder.
func (m *GroupMutation) Where(ps ...predicate.Group) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GroupMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GroupMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Group, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GroupMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GroupMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Group).
func (m *GroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GroupMutation) Fields() []string {
	fields := make([]string, 0, 32)
	if m.created_at != nil {
		fields = append(fields, group.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, group.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, group.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, group.FieldName)
	}
	if m.description != nil {
		fields = append(fields, group.FieldDescription)
	}
	if m.rate_multiplier != nil {
		fields = append(fields, group.FieldRateMultiplier)
	}
	if m.is_exclusive != nil {
		fields = append(fields, group.FieldIsExclusive)
	}
	if m.status != nil {
		fields = append(fields, group.FieldStatus)
	}
	if m.platform != nil {
		fields = append(fields, group.FieldPlatform)
	}
	if m.subscription_type != nil {
		fields = append(fields, group.FieldSubscriptionType)
	}
	if m.daily_limit_usd != nil {
		fields = append(fields, group.FieldDailyLimitUsd)
	}
	if m.weekly_limit_usd != nil {
		fields = append(fields, group.FieldWeeklyLimitUsd)
	}
	if m.monthly_limit_usd != nil {
		fields = append(fields, group.FieldMonthlyLimitUsd)
	}
	if m.default_validity_days != nil {
		fields = append(fields, group.FieldDefaultValidityDays)
	}
	if m.image_price_1k != nil {
		fields = append(fields, group.FieldImagePrice1k)
	}
	if m.image_price_2k != nil {
		fields = append(fields, group.FieldImagePrice2k)
	}
	if m.image_price_4k != nil {
		fields = append(fields, group.FieldImagePrice4k)
	}
	if m.claude_code_only != nil {
		fields = append(fields, group.FieldClaudeCodeOnly)
	}
	if m.fallback_group_id != nil {
		fields = append(fields, group.FieldFallbackGroupID)
	}
	if m.fallback_group_id_on_invalid_request != nil {
		fields = append(fields, group.FieldFallbackGroupIDOnInvalidRequest)
	}
	if m.model_routing != nil {
		fields = append(fields, group.FieldModelRouting)
	}
	if m.model_routing_enabled != nil {
		fields = append(fields, group.FieldModelRoutingEnabled)
	}
	if m.mcp_xml_inject != nil {
		fields = append(fields, group.FieldMcpXMLInject)
	}
	if m.supported_model_scopes != nil {
		fields = append(fields, group.FieldSupportedModelScopes)
	}
	if m.price != nil {
		fields = append(fields, group.FieldPrice)
	}
	if m.is_purchasable != nil {
		fields = append(fields, group.FieldIsPurchasable)
	}
	if m.sort_order != nil {
		fields = append(fields, group.FieldSortOrder)
	}
	if m.is_recommended != nil {
		fields = append(fields, group.FieldIsRecommended)
	}
	if m.external_buy_url != nil {
		fields = append(fields, group.FieldExternalBuyURL)
	}
	if m.owner_id != nil {
		fields = append(fields, group.FieldOwnerID)
	}
	if m.source_group_id != nil {
		fields = append(fields, group.FieldSourceGroupID)
	}
	if m.reseller_template != nil {
		fields = append(fields, group.FieldResellerTemplate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case group.FieldCreatedAt:
		return m.CreatedAt()
	case group.FieldUpdatedAt:
		return m.UpdatedAt()
	case group.FieldDeletedAt:
		return m.DeletedAt()
	case group.FieldName:
		return m.Name()
	case group.FieldDescription:
		return m.Description()
	case group.FieldRateMultiplier:
		return m.RateMultiplier()
	case group.FieldIsExclusive:
		return m.IsExclusive()
	case group.FieldStatus:
		return m.Status()
	case group.FieldPlatform:
		return m.Platform()
	case group.FieldSubscriptionType:
		return m.SubscriptionType()
	case group.FieldDailyLimitUsd:
		return m.DailyLimitUsd()
	case group.FieldWeeklyLimitUsd:
		return m.WeeklyLimitUsd()
	case group.FieldMonthlyLimitUsd:
		return m.MonthlyLimitUsd()
	case group.FieldDefaultValidityDays:
		return m.DefaultValidityDays()
	case group.FieldImagePrice1k:
		return m.ImagePrice1k()
	case group.FieldImagePrice2k:
		return m.ImagePrice2k()
	case group.FieldImagePrice4k:
		return m.ImagePrice4k()
	case group.FieldClaudeCodeOnly:
		return m.ClaudeCodeOnly()
	case group.FieldFallbackGroupID:
		return m.FallbackGroupID()
	case group.FieldFallbackGroupIDOnInvalidRequest:
		return m.FallbackGroupIDOnInvalidRequest()
	case group.FieldModelRouting:
		return m.ModelRouting()
	case group.FieldModelRoutingEnabled:
		return m.ModelRoutingEnabled()
	case group.FieldMcpXMLInject:
		return m.McpXMLInject()
	case group.FieldSupportedModelScopes:
		return m.SupportedModelScopes()
	case group.FieldPrice:
		return m.Price()
	case group.FieldIsPurchasable:
		return m.IsPurchasable()
	case group.FieldSortOrder:
		return m.SortOrder()
	case group.FieldIsRecommended:
		return m.IsRecommended()
	case group.FieldExternalBuyURL:
		return m.ExternalBuyURL()
	case group.FieldOwnerID:
		return m.OwnerID()
	case group.FieldSourceGroupID:
		return m.SourceGroupID()
	case group.FieldResellerTemplate:
		return m.ResellerTemplate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case group.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case group.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case group.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case group.FieldName:
		return m.OldName(ctx)
	case group.FieldDescription:
		return m.OldDescription(ctx)
	case group.FieldRateMultiplier:
		return m.OldRateMultiplier(ctx)
	case group.FieldIsExclusive:
		return m.OldIsExclusive(ctx)
	case group.FieldStatus:
		return m.OldStatus(ctx)
	case group.FieldPlatform:
		return m.OldPlatform(ctx)
	case group.FieldSubscriptionType:
		return m.OldSubscriptionType(ctx)
	case group.FieldDailyLimitUsd:
		return m.OldDailyLimitUsd(ctx)
	case group.FieldWeeklyLimitUsd:
		return m.OldWeeklyLimitUsd(ctx)
	case group.FieldMonthlyLimitUsd:
		return m.OldMonthlyLimitUsd(ctx)
	case group.FieldDefaultValidityDays:
		return m.OldDefaultValidityDays(ctx)
	case group.FieldImagePrice1k:
		return m.OldImagePrice1k(ctx)
	case group.FieldImagePrice2k:
		return m.OldImagePrice2k(ctx)
	case group.FieldImagePrice4k:
		return m.OldImagePrice4k(ctx)
	case group.FieldClaudeCodeOnly:
		return m.OldClaudeCodeOnly(ctx)
	case group.FieldFallbackGroupID:
		return m.OldFallbackGroupID(ctx)
	case group.FieldFallbackGroupIDOnInvalidRequest:
		return m.OldFallbackGroupIDOnInvalidRequest(ctx)
	case group.FieldModelRouting:
		return m.OldModelRouting(ctx)
	case group.FieldModelRoutingEnabled:
		return m.OldModelRoutingEnabled(ctx)
	case group.FieldMcpXMLInject:
		return m.OldMcpXMLInject(ctx)
	case group.FieldSupportedModelScopes:
		return m.OldSupportedModelScopes(ctx)
	case group.FieldPrice:
		return m.OldPrice(ctx)
	case group.FieldIsPurchasable:
		return m.OldIsPurchasable(ctx)
	case group.FieldSortOrder:
		return m.OldSortOrder(ctx)
	case group.FieldIsRecommended:
		return m.OldIsRecommended(ctx)
	case group.FieldExternalBuyURL:
		return m.OldExternalBuyURL(ctx)
	case group.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case group.FieldSourceGroupID:
		return m.OldSourceGroupID(ctx)
	case group.FieldResellerTemplate:
		return m.OldResellerTemplate(ctx)
	}
	return nil, fmt.Errorf("unknown Group field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case group.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case group.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case group.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case group.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case group.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case group.FieldRateMultiplier:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRateMultiplier(v)
		return nil
	case group.FieldIsExclusive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsExclusive(v)
		return nil
	case group.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case group.FieldPlatform:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatform(v)
		return nil
	case group.FieldSubscriptionType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscriptionType(v)
		return nil
	case group.FieldDailyLimitUsd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDailyLimitUsd(v)
		return nil
	case group.FieldWeeklyLimitUsd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeeklyLimitUsd(v)
		return nil
	case group.FieldMonthlyLimitUsd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMonthlyLimitUsd(v)
		return nil
	case group.FieldDefaultValidityDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultValidityDays(v)
		return nil
	case group.FieldImagePrice1k:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImagePrice1k(v)
		return nil
	case group.FieldImagePrice2k:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImagePrice2k(v)
		return nil
	case group.FieldImagePrice4k:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImagePrice4k(v)
		return nil
	case group.FieldClaudeCodeOnly:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClaudeCodeOnly(v)
		return nil
	case group.FieldFallbackGroupID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFallbackGroupID(v)
		return nil
	case group.FieldFallbackGroupIDOnInvalidRequest:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFallbackGroupIDOnInvalidRequest(v)
		return nil
	case group.FieldModelRouting:
		v, ok := value.(map[string][]int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModelRouting(v)
		return nil
	case group.FieldModelRoutingEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModelRoutingEnabled(v)
		return nil
	case group.FieldMcpXMLInject:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMcpXMLInject(v)
		return nil
	case group.FieldSupportedModelScopes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupportedModelScopes(v)
		return nil
	case group.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case group.FieldIsPurchasable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPurchasable(v)
		return nil
	case group.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	case group.FieldIsRecommended:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRecommended(v)
		return nil
	case group.FieldExternalBuyURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalBuyURL(v)
		return nil
	case group.FieldOwnerID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case group.FieldSourceGroupID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceGroupID(v)
		return nil
	case group.FieldResellerTemplate:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResellerTemplate(v)
		return nil
	}
	return fmt.Errorf("unknown Group field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GroupMutation) AddedFields() []string {
	var fields []string
	if m.addrate_multiplier != nil {
		fields = append(fields, group.FieldRateMultiplier)
	}
	if m.adddaily_limit_usd != nil {
		fields = append(fields, group.FieldDailyLimitUsd)
	}
	if m.addweekly_limit_usd != nil {
		fields = append(fields, group.FieldWeeklyLimitUsd)
	}
	if m.addmonthly_limit_usd != nil {
		fields = append(fields, group.FieldMonthlyLimitUsd)
	}
	if m.adddefault_validity_days != nil {
		fields = append(fields, group.FieldDefaultValidityDays)
	}
	if m.addimage_price_1k != nil {
		fields = append(fields, group.FieldImagePrice1k)
	}
	if m.addimage_price_2k != nil {
		fields = append(fields, group.FieldImagePrice2k)
	}
	if m.addimage_price_4k != nil {
		fields = append(fields, group.FieldImagePrice4k)
	}
	if m.addfallback_group_id != nil {
		fields = append(fields, group.FieldFallbackGroupID)
	}
	if m.addfallback_group_id_on_invalid_request != nil {
		fields = append(fields, group.FieldFallbackGroupIDOnInvalidRequest)
	}
	if m.addprice != nil {
		fields = append(fields, group.FieldPrice)
	}
	if m.addsort_order != nil {
		fields = append(fields, group.FieldSortOrder)
	}
	if m.addowner_id != nil {
		fields = append(fields, group.FieldOwnerID)
	}
	if m.addsource_group_id != nil {
		fields = append(fields, group.FieldSourceGroupID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GroupMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case group.FieldRateMultiplier:
		return m.AddedRateMultiplier()
	case group.FieldDailyLimitUsd:
		return m.AddedDailyLimitUsd()
	case group.FieldWeeklyLimitUsd:
		return m.AddedWeeklyLimitUsd()
	case group.FieldMonthlyLimitUsd:
		return m.AddedMonthlyLimitUsd()
	case group.FieldDefaultValidityDays:
		return m.AddedDefaultValidityDays()
	case group.FieldImagePrice1k:
		return m.AddedImagePrice1k()
	case group.FieldImagePrice2k:
		return m.AddedImagePrice2k()
	case group.FieldImagePrice4k:
		return m.AddedImagePrice4k()
	case group.FieldFallbackGroupID:
		return m.AddedFallbackGroupID()
	case group.FieldFallbackGroupIDOnInvalidRequest:
		return m.AddedFallbackGroupIDOnInvalidRequest()
	case group.FieldPrice:
		return m.AddedPrice()
	case group.FieldSortOrder:
		return m.AddedSortOrder()
	case group.FieldOwnerID:
		return m.AddedOwnerID()
	case group.FieldSourceGroupID:
		return m.AddedSourceGroupID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	case group.FieldRateMultiplier:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRateMultiplier(v)
		return nil
	case group.FieldDailyLimitUsd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDailyLimitUsd(v)
		return nil
	case group.FieldWeeklyLimitUsd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeeklyLimitUsd(v)
		return nil
	case group.FieldMonthlyLimitUsd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMonthlyLimitUsd(v)
		return nil
	case group.FieldDefaultValidityDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDefaultValidityDays(v)
		return nil
	case group.FieldImagePrice1k:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddImagePrice1k(v)
		return nil
	case group.FieldImagePrice2k:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddImagePrice2k(v)
		return nil
	case group.FieldImagePrice4k:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddImagePrice4k(v)
		return nil
	case group.FieldFallbackGroupID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFallbackGroupID(v)
		return nil
	case group.FieldFallbackGroupIDOnInvalidRequest:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFallbackGroupIDOnInvalidRequest(v)
		return nil
	case group.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case group.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	case group.FieldOwnerID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOwnerID(v)
		return nil
	case group.FieldSourceGroupID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSourceGroupID(v)
		return nil
	}
	return fmt.Errorf("unknown Group numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GroupMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(group.FieldDeletedAt) {
		fields = append(fields, group.FieldDeletedAt)
	}
	if m.FieldCleared(group.FieldDescription) {
		fields = append(fields, group.FieldDescription)
	}
	if m.FieldCleared(group.FieldDailyLimitUsd) {
		fields = append(fields, group.FieldDailyLimitUsd)
	}
	if m.FieldCleared(group.FieldWeeklyLimitUsd) {
		fields = append(fields, group.FieldWeeklyLimitUsd)
	}
	if m.FieldCleared(group.FieldMonthlyLimitUsd) {
		fields = append(fields, group.FieldMonthlyLimitUsd)
	}
	if m.FieldCleared(group.FieldImagePrice1k) {
		fields = append(fields, group.FieldImagePrice1k)
	}
	if m.FieldCleared(group.FieldImagePrice2k) {
		fields = append(fields, group.FieldImagePrice2k)
	}
	if m.FieldCleared(group.FieldImagePrice4k) {
		fields = append(fields, group.FieldImagePrice4k)
	}
	if m.FieldCleared(group.FieldFallbackGroupID) {
		fields = append(fields, group.FieldFallbackGroupID)
	}
	if m.FieldCleared(group.FieldFallbackGroupIDOnInvalidRequest) {
		fields = append(fields, group.FieldFallbackGroupIDOnInvalidRequest)
	}
	if m.FieldCleared(group.FieldModelRouting) {
		fields = append(fields, group.FieldModelRouting)
	}
	if m.FieldCleared(group.FieldPrice) {
		fields = append(fields, group.FieldPrice)
	}
	if m.FieldCleared(group.FieldExternalBuyURL) {
		fields = append(fields, group.FieldExternalBuyURL)
	}
	if m.FieldCleared(group.FieldOwnerID) {
		fields = append(fields, group.FieldOwnerID)
	}
	if m.FieldCleared(group.FieldSourceGroupID) {
		fields = append(fields, group.FieldSourceGroupID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GroupMutation) ClearField(name string) error {
	switch name {
	case group.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case group.FieldDescription:
		m.ClearDescription()
		return nil
	case group.FieldDailyLimitUsd:
		m.ClearDailyLimitUsd()
		return nil
	case group.FieldWeeklyLimitUsd:
		m.ClearWeeklyLimitUsd()
		return nil
	case group.FieldMonthlyLimitUsd:
		m.ClearMonthlyLimitUsd()
		return nil
	case group.FieldImagePrice1k:
		m.ClearImagePrice1k()
		return nil
	case group.FieldImagePrice2k:
		m.ClearImagePrice2k()
		return nil
	case group.FieldImagePrice4k:
		m.ClearImagePrice4k()
		return nil
	case group.FieldFallbackGroupID:
		m.ClearFallbackGroupID()
		return nil
	case group.FieldFallbackGroupIDOnInvalidRequest:
		m.ClearFallbackGroupIDOnInvalidRequest()
		return nil
	case group.FieldModelRouting:
		m.ClearModelRouting()
		return nil
	case group.FieldPrice:
		m.ClearPrice()
		return nil
	case group.FieldExternalBuyURL:
		m.ClearExternalBuyURL()
		return nil
	case group.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	case group.FieldSourceGroupID:
		m.ClearSourceGroupID()
		return nil
	}
	return fmt.Errorf("unknown Group nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GroupMutation) ResetField(name string) error {
	switch name {
	case group.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case group.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case group.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case group.FieldName:
		m.ResetName()
		return nil
	case group.FieldDescription:
		m.ResetDescription()
		return nil
	case group.FieldRateMultiplier:
		m.ResetRateMultiplier()
		return nil
	case group.FieldIsExclusive:
		m.ResetIsExclusive()
		return nil
	case group.FieldStatus:
		m.ResetStatus()
		return nil
	case group.FieldPlatform:
		m.ResetPlatform()
		return nil
	case group.FieldSubscriptionType:
		m.ResetSubscriptionType()
		return nil
	case group.FieldDailyLimitUsd:
		m.ResetDailyLimitUsd()
		return nil
	case group.FieldWeeklyLimitUsd:
		m.ResetWeeklyLimitUsd()
		return nil
	case group.FieldMonthlyLimitUsd:
		m.ResetMonthlyLimitUsd()
		return nil
	case group.FieldDefaultValidityDays:
		m.ResetDefaultValidityDays()
		return nil
	case group.FieldImagePrice1k:
		m.ResetImagePrice1k()
		return nil
	case group.FieldImagePrice2k:
		m.ResetImagePrice2k()
		return nil
	case group.FieldImagePrice4k:
		m.ResetImagePrice4k()
		return nil
	case group.FieldClaudeCodeOnly:
		m.ResetClaudeCodeOnly()
		return nil
	case group.FieldFallbackGroupID:
		m.ResetFallbackGroupID()
		return nil
	case group.FieldFallbackGroupIDOnInvalidRequest:
		m.ResetFallbackGroupIDOnInvalidRequest()
		return nil
	case group.FieldModelRouting:
		m.ResetModelRouting()
		return nil
	case group.FieldModelRoutingEnabled:
		m.ResetModelRoutingEnabled()
		return nil
	case group.FieldMcpXMLInject:
		m.ResetMcpXMLInject()
		return nil
	case group.FieldSupportedModelScopes:
		m.ResetSupportedModelScopes()
		return nil
	case group.FieldPrice:
		m.ResetPrice()
		return nil
	case group.FieldIsPurchasable:
		m.ResetIsPurchasable()
		return nil
	case group.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	case group.FieldIsRecommended:
		m.ResetIsRecommended()
		return nil
	case group.FieldExternalBuyURL:
		m.ResetExternalBuyURL()
		return nil
	case group.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case group.FieldSourceGroupID:
		m.ResetSourceGroupID()
		return nil
	case group.FieldResellerTemplate:
		m.ResetResellerTemplate()
		return nil
	}
	return fmt.Errorf("unknown Group field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.api_keys != nil {
		edges = append(edges, group.EdgeAPIKeys)
	}
	if m.redeem_codes != nil {
		edges = append(edges, group.EdgeRedeemCodes)
	}
	if m.subscriptions != nil {
		edges = append(edges, group.EdgeSubscriptions)
	}
	if m.usage_logs != nil {
		edges = append(edges, group.EdgeUsageLogs)
	}
	if m.orders != nil {
		edges = append(edges, group.EdgeOrders)
	}
	if m.accounts != nil {
		edges = append(edges, group.EdgeAccounts)
	}
	if m.allowed_users != nil {
		edges = append(edges, group.EdgeAllowedUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case group.EdgeAPIKeys:
		ids := make([]ent.Value, 0, len(m.api_keys))
		for id := range m.api_keys {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeRedeemCodes:
		ids := make([]ent.Value, 0, len(m.redeem_codes))
		for id := range m.redeem_codes {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeSubscriptions:
		ids := make([]ent.Value, 0, len(m.subscriptions))
		for id := range m.subscriptions {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeUsageLogs:
		ids := make([]ent.Value, 0, len(m.usage_logs))
		for id := range m.usage_logs {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.orders))
		for id := range m.orders {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.accounts))
		for id := range m.accounts {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeAllowedUsers:
		ids := make([]ent.Value, 0, len(m.allowed_users))
		for id := range m.allowed_users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedapi_keys != nil {
		edges = append(edges, group.EdgeAPIKeys)
	}
	if m.removedredeem_codes != nil {
		edges = append(edges, group.EdgeRedeemCodes)
	}
	if m.removedsubscriptions != nil {
		edges = append(edges, group.EdgeSubscriptions)
	}
	if m.removedusage_logs != nil {
		edges = append(edges, group.EdgeUsageLogs)
	}
	if m.removedorders != nil {
		edges = append(edges, group.EdgeOrders)
	}
	if m.removedaccounts != nil {
		edges = append(edges, group.EdgeAccounts)
	}
	if m.removedallowed_users != nil {
		edges = append(edges, group.EdgeAllowedUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GroupMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case group.EdgeAPIKeys:
		ids := make([]ent.Value, 0, len(m.removedapi_keys))
		for id := range m.removedapi_keys {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeRedeemCodes:
		ids := make([]ent.Value, 0, len(m.removedredeem_codes))
		for id := range m.removedredeem_codes {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeSubscriptions:
		ids := make([]ent.Value, 0, len(m.removedsubscriptions))
		for id := range m.removedsubscriptions {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeUsageLogs:
		ids := make([]ent.Value, 0, len(m.removedusage_logs))
		for id := range m.removedusage_logs {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.removedorders))
		for id := range m.removedorders {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.removedaccounts))
		for id := range m.removedaccounts {
			ids = append(ids, id)
		}
		return ids
	case group.EdgeAllowedUsers:
		ids := make([]ent.Value, 0, len(m.removedallowed_users))
		for id := range m.removedallowed_users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedapi_keys {
		edges = append(edges, group.EdgeAPIKeys)
	}
	if m.clearedredeem_codes {
		edges = append(edges, group.EdgeRedeemCodes)
	}
	if m.clearedsubscriptions {
		edges = append(edges, group.EdgeSubscriptions)
	}
	if m.clearedusage_logs {
		edges = append(edges, group.EdgeUsageLogs)
	}
	if m.clearedorders {
		edges = append(edges, group.EdgeOrders)
	}
	if m.clearedaccounts {
		edges = append(edges, group.EdgeAccounts)
	}
	if m.clearedallowed_users {
		edges = append(edges, group.EdgeAllowedUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GroupMutation) EdgeCleared(name string) bool {
	switch name {
	case group.EdgeAPIKeys:
		return m.clearedapi_keys
	case group.EdgeRedeemCodes:
		return m.clearedredeem_codes
	case group.EdgeSubscriptions:
		return m.clearedsubscriptions
	case group.EdgeUsageLogs:
		return m.clearedusage_logs
	case group.EdgeOrders:
		return m.clearedorders
	case group.EdgeAccounts:
		return m.clearedaccounts
	case group.EdgeAllowedUsers:
		return m.clearedallowed_users
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GroupMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Group unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GroupMutation) ResetEdge(name string) error {
	switch name {
	case group.EdgeAPIKeys:
		m.ResetAPIKeys()
		return nil
	case group.EdgeRedeemCodes:
		m.ResetRedeemCodes()
		return nil
	case group.EdgeSubscriptions:
		m.ResetSubscriptions()
		return nil
	case group.EdgeUsageLogs:
		m.ResetUsageLogs()
		return nil
	case group.EdgeOrders:
		m.ResetOrders()
		return nil
	case group.EdgeAccounts:
		m.ResetAccounts()
		return nil
	case group.EdgeAllowedUsers:
		m.ResetAllowedUsers()
		return nil
	}
	return fmt.Errorf("unknown Group edge %s", name)
}

// OrderMutation represents an operation that mutates the Order nodes in the graph.
type OrderMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int64
	order_no               *string
	trade_no               *string
	amount                 *float64
	addamount              *float64
	status                 *string
	pay_type               *string
	paid_at                *time.Time
	created_at             *time.Time
	updated_at             *time.Time
	expired_at             *time.Time
	clearedFields          map[string]struct{}
	user                   *int64
	cleareduser            bool
	group                  *int64
	clearedgroup           bool
	subscription           *int64
	clearedsubscription    bool
	referral_reward        *int64
	clearedreferral_reward bool
	done                   bool
	oldValue               func(context.Context) (*Order, error)
	predicates             []predicate.Order
}

var _ ent.Mutation = (*OrderMutation)(nil)

// orderOption allows management of the mutation configuration using functional options.
type orderOption func(*OrderMutation)

// newOrderMutation creates new mutation for the Order entity.
func newOrderMutation(c config, op Op, opts ...orderOption) *OrderMutation {
	m := &OrderMutation{
		config:        c,
		op:            op,
		typ:           TypeOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderID sets the ID field of the mutation.
func withOrderID(id int64) orderOption {
	return func(m *OrderMutation) {
		var (
			err   error
			once  sync.Once
			value *Order
		)
		m.oldValue = func(ctx context.Context) (*Order, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Order.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrder sets the old Order of the mutation.
func withOrder(node *Order) orderOption {
	return func(m *OrderMutation) {
		m.oldValue = func(context.Context) (*Order, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Order.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOrderNo sets the "order_no" field.
func (m *OrderMutation) SetOrderNo(s string) {
	m.order_no = &s
}

// OrderNo returns the value of the "order_no" field in the mutation.
func (m *OrderMutation) OrderNo() (r string, exists bool) {
	v := m.order_no
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderNo returns the old "order_no" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldOrderNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderNo: %w", err)
	}
	return oldValue.OrderNo, nil
}

// ResetOrderNo resets all changes to the "order_no" field.
func (m *OrderMutation) ResetOrderNo() {
	m.order_no = nil
}

// SetTradeNo sets the "trade_no" field.
func (m *OrderMutation) SetTradeNo(s string) {
	m.trade_no = &s
}

// TradeNo returns the value of the "trade_no" field in the mutation.
func (m *OrderMutation) TradeNo() (r string, exists bool) {
	v := m.trade_no
	if v == nil {
		return
	}
	return *v, true
}

// OldTradeNo returns the old "trade_no" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldTradeNo(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTradeNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTradeNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTradeNo: %w", err)
	}
	return oldValue.TradeNo, nil
}

// ClearTradeNo clears the value of the "trade_no" field.
func (m *OrderMutation) ClearTradeNo() {
	m.trade_no = nil
	m.clearedFields[order.FieldTradeNo] = struct{}{}
}

// TradeNoCleared returns if the "trade_no" field was cleared in this mutation.
func (m *OrderMutation) TradeNoCleared() bool {
	_, ok := m.clearedFields[order.FieldTradeNo]
	return ok
}

// ResetTradeNo resets all changes to the "trade_no" field.
func (m *OrderMutation) ResetTradeNo() {
	m.trade_no = nil
	delete(m.clearedFields, order.FieldTradeNo)
}

// SetUserID sets the "user_id" field.
func (m *OrderMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *OrderMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *OrderMutation) ResetUserID() {
	m.user = nil
}

// SetGroupID sets the "group_id" field.
func (m *OrderMutation) SetGroupID(i int64) {
	m.group = &i
}

// GroupID returns the value of the "group_id" field in the mutation.
func (m *OrderMutation) GroupID() (r int64, exists bool) {
	v := m.group
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupID returns the old "group_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldGroupID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupID: %w", err)
	}
	return oldValue.GroupID, nil
}

// ResetGroupID resets all changes to the "group_id" field.
func (m *OrderMutation) ResetGroupID() {
	m.group = nil
}

// SetAmount sets the "amount" field.
func (m *OrderMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *OrderMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *OrderMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *OrderMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *OrderMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetStatus sets the "status" field.
func (m *OrderMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *OrderMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *OrderMutation) ResetStatus() {
	m.status = nil
}

// SetPayType sets the "pay_type" field.
func (m *OrderMutation) SetPayType(s string) {
	m.pay_type = &s
}

// PayType returns the value of the "pay_type" field in the mutation.
func (m *OrderMutation) PayType() (r string, exists bool) {
	v := m.pay_type
	if v == nil {
		return
	}
	return *v, true
}

// OldPayType returns the old "pay_type" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldPayType(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayType: %w", err)
	}
	return oldValue.PayType, nil
}

// ClearPayType clears the value of the "pay_type" field.
func (m *OrderMutation) ClearPayType() {
	m.pay_type = nil
	m.clearedFields[order.FieldPayType] = struct{}{}
}

// PayTypeCleared returns if the "pay_type" field was cleared in this mutation.
func (m *OrderMutation) PayTypeCleared() bool {
	_, ok := m.clearedFields[order.FieldPayType]
	return ok
}

// ResetPayType resets all changes to the "pay_type" field.
func (m *OrderMutation) ResetPayType() {
	m.pay_type = nil
	delete(m.clearedFields, order.FieldPayType)
}

// SetPaidAt sets the "paid_at" field.
func (m *OrderMutation) SetPaidAt(t time.Time) {
	m.paid_at = &t
}

// PaidAt returns the value of the "paid_at" field in the mutation.
func (m *OrderMutation) PaidAt() (r time.Time, exists bool) {
	v := m.paid_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPaidAt returns the old "paid_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldPaidAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaidAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaidAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaidAt: %w", err)
	}
	return oldValue.PaidAt, nil
}

// ClearPaidAt clears the value of the "paid_at" field.
func (m *OrderMutation) ClearPaidAt() {
	m.paid_at = nil
	m.clearedFields[order.FieldPaidAt] = struct{}{}
}

// PaidAtCleared returns if the "paid_at" field was cleared in this mutation.
func (m *OrderMutation) PaidAtCleared() bool {
	_, ok := m.clearedFields[order.FieldPaidAt]
	return ok
}

// ResetPaidAt resets all changes to the "paid_at" field.
func (m *OrderMutation) ResetPaidAt() {
	m.paid_at = nil
	delete(m.clearedFields, order.FieldPaidAt)
}

// SetSubscriptionID sets the "subscription_id" field.
func (m *OrderMutation) SetSubscriptionID(i int64) {
	m.subscription = &i
}

// SubscriptionID returns the value of the "subscription_id" field in the mutation.
func (m *OrderMutation) SubscriptionID() (r int64, exists bool) {
	v := m.subscription
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscriptionID returns the old "subscription_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldSubscriptionID(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscriptionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscriptionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscriptionID: %w", err)
	}
	return oldValue.SubscriptionID, nil
}

// ClearSubscriptionID clears the value of the "subscription_id" field.
func (m *OrderMutation) ClearSubscriptionID() {
	m.subscription = nil
	m.clearedFields[order.FieldSubscriptionID] = struct{}{}
}

// SubscriptionIDCleared returns if the "subscription_id" field was cleared in this mutation.
func (m *OrderMutation) SubscriptionIDCleared() bool {
	_, ok := m.clearedFields[order.FieldSubscriptionID]
	return ok
}

// ResetSubscriptionID resets all changes to the "subscription_id" field.
func (m *OrderMutation) ResetSubscriptionID() {
	m.subscription = nil
	delete(m.clearedFields, order.FieldSubscriptionID)
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetExpiredAt sets the "expired_at" field.
func (m *OrderMutation) SetExpiredAt(t time.Time) {
	m.expired_at = &t
}

// ExpiredAt returns the value of the "expired_at" field in the mutation.
func (m *OrderMutation) ExpiredAt() (r time.Time, exists bool) {
	v := m.expired_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiredAt returns the old "expired_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldExpiredAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiredAt: %w", err)
	}
	return oldValue.ExpiredAt, nil
}

// ClearExpiredAt clears the value of the "expired_at" field.
func (m *OrderMutation) ClearExpiredAt() {
	m.expired_at = nil
	m.clearedFields[order.FieldExpiredAt] = struct{}{}
}

// ExpiredAtCleared returns if the "expired_at" field was cleared in this mutation.
func (m *OrderMutation) ExpiredAtCleared() bool {
	_, ok := m.clearedFields[order.FieldExpiredAt]
	return ok
}

// ResetExpiredAt resets all changes to the "expired_at" field.
func (m *OrderMutation) ResetExpiredAt() {
	m.expired_at = nil
	delete(m.clearedFields, order.FieldExpiredAt)
}

// ClearUser clears the "user" edge to the User entity.
func (m *OrderMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[order.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *OrderMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *OrderMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearGroup clears the "group" edge to the Group entity.
func (m *OrderMutation) ClearGroup() {
	m.clearedgroup = true
	m.clearedFields[order.FieldGroupID] = struct{}{}
}

// GroupCleared reports if the "group" edge to the Group entity was cleared.
func (m *OrderMutation) GroupCleared() bool {
	return m.clearedgroup
}

// GroupIDs returns the "group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) GroupIDs() (ids []int64) {
	if id := m.group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroup resets all changes to the "group" edge.
func (m *OrderMutation) ResetGroup() {
	m.group = nil
	m.clearedgroup = false
}

// ClearSubscription clears the "subscription" edge to the UserSubscription entity.
func (m *OrderMutation) ClearSubscription() {
	m.clearedsubscription = true
	m.clearedFields[order.FieldSubscriptionID] = struct{}{}
}

// SubscriptionCleared reports if the "subscription" edge to the UserSubscription entity was cleared.
func (m *OrderMutation) SubscriptionCleared() bool {
	return m.SubscriptionIDCleared() || m.clearedsubscription
}

// SubscriptionIDs returns the "subscription" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubscriptionID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) SubscriptionIDs() (ids []int64) {
	if id := m.subscription; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubscription resets all changes to the "subscription" edge.
func (m *OrderMutation) ResetSubscription() {
	m.subscription = nil
	m.clearedsubscription = false
}

// SetReferralRewardID sets the "referral_reward" edge to the ReferralReward entity by id.
func (m *OrderMutation) SetReferralRewardID(id int64) {
	m.referral_reward = &id
}

// ClearReferralReward clears the "referral_reward" edge to the ReferralReward entity.
func (m *OrderMutation) ClearReferralReward() {
	m.clearedreferral_reward = true
}

// ReferralRewardCleared reports if the "referral_reward" edge to the ReferralReward entity was cleared.
func (m *OrderMutation) ReferralRewardCleared() bool {
	return m.clearedreferral_reward
}

// ReferralRewardID returns the "referral_reward" edge ID in the mutation.
func (m *OrderMutation) ReferralRewardID() (id int64, exists bool) {
	if m.referral_reward != nil {
		return *m.referral_reward, true
	}
	return
}

// ReferralRewardIDs returns the "referral_reward" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReferralRewardID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) ReferralRewardIDs() (ids []int64) {
	if id := m.referral_reward; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReferralReward resets all changes to the "referral_reward" edge.
func (m *OrderMutation) ResetReferralReward() {
	m.referral_reward = nil
	m.clearedreferral_reward = false
}

// Where appends a list predicates to the OrderMutation builder.
func (m *OrderMutation) Where(ps ...predicate.Order) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Order, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Order).
func (m *OrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.order_no != nil {
		fields = append(fields, order.FieldOrderNo)
	}
	if m.trade_no != nil {
		fields = append(fields, order.FieldTradeNo)
	}
	if m.user != nil {
		fields = append(fields, order.FieldUserID)
	}
	if m.group != nil {
		fields = append(fields, order.FieldGroupID)
	}
	if m.amount != nil {
		fields = append(fields, order.FieldAmount)
	}
	if m.status != nil {
		fields = append(fields, order.FieldStatus)
	}
	if m.pay_type != nil {
		fields = append(fields, order.FieldPayType)
	}
	if m.paid_at != nil {
		fields = append(fields, order.FieldPaidAt)
	}
	if m.subscription != nil {
		fields = append(fields, order.FieldSubscriptionID)
	}
	if m.created_at != nil {
		fields = append(fields, order.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, order.FieldUpdatedAt)
	}
	if m.expired_at != nil {
		fields = append(fields, order.FieldExpiredAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case order.FieldOrderNo:
		return m.OrderNo()
	case order.FieldTradeNo:
		return m.TradeNo()
	case order.FieldUserID:
		return m.UserID()
	case order.FieldGroupID:
		return m.GroupID()
	case order.FieldAmount:
		return m.Amount()
	case order.FieldStatus:
		return m.Status()
	case order.FieldPayType:
		return m.PayType()
	case order.FieldPaidAt:
		return m.PaidAt()
	case order.FieldSubscriptionID:
		return m.SubscriptionID()
	case order.FieldCreatedAt:
		return m.CreatedAt()
	case order.FieldUpdatedAt:
		return m.UpdatedAt()
	case order.FieldExpiredAt:
		return m.ExpiredAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case order.FieldOrderNo:
		return m.OldOrderNo(ctx)
	case order.FieldTradeNo:
		return m.OldTradeNo(ctx)
	case order.FieldUserID:
		return m.OldUserID(ctx)
	case order.FieldGroupID:
		return m.OldGroupID(ctx)
	case order.FieldAmount:
		return m.OldAmount(ctx)
	case order.FieldStatus:
		return m.OldStatus(ctx)
	case order.FieldPayType:
		return m.OldPayType(ctx)
	case order.FieldPaidAt:
		return m.OldPaidAt(ctx)
	case order.FieldSubscriptionID:
		return m.OldSubscriptionID(ctx)
	case order.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case order.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case order.FieldExpiredAt:
		return m.OldExpiredAt(ctx)
	}
	return nil, fmt.Errorf("unknown Order field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case order.FieldOrderNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderNo(v)
		return nil
	case order.FieldTradeNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTradeNo(v)
		return nil
	case order.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case order.FieldGroupID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupID(v)
		return nil
	case order.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case order.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case order.FieldPayType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayType(v)
		return nil
	case order.FieldPaidAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaidAt(v)
		return nil
	case order.FieldSubscriptionID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscriptionID(v)
		return nil
	case order.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case order.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case order.FieldExpiredAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiredAt(v)
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, order.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case order.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case order.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Order numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(order.FieldTradeNo) {
		fields = append(fields, order.FieldTradeNo)
	}
	if m.FieldCleared(order.FieldPayType) {
		fields = append(fields, order.FieldPayType)
	}
	if m.FieldCleared(order.FieldPaidAt) {
		fields = append(fields, order.FieldPaidAt)
	}
	if m.FieldCleared(order.FieldSubscriptionID) {
		fields = append(fields, order.FieldSubscriptionID)
	}
	if m.FieldCleared(order.FieldExpiredAt) {
		fields = append(fields, order.FieldExpiredAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderMutation) ClearField(name string) error {
	switch name {
	case order.FieldTradeNo:
		m.ClearTradeNo()
		return nil
	case order.FieldPayType:
		m.ClearPayType()
		return nil
	case order.FieldPaidAt:
		m.ClearPaidAt()
		return nil
	case order.FieldSubscriptionID:
		m.ClearSubscriptionID()
		return nil
	case order.FieldExpiredAt:
		m.ClearExpiredAt()
		return nil
	}
	return fmt.Errorf("unknown Order nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderMutation) ResetField(name string) error {
	switch name {
	case order.FieldOrderNo:
		m.ResetOrderNo()
		return nil
	case order.FieldTradeNo:
		m.ResetTradeNo()
		return nil
	case order.FieldUserID:
		m.ResetUserID()
		return nil
	case order.FieldGroupID:
		m.ResetGroupID()
		return nil
	case order.FieldAmount:
		m.ResetAmount()
		return nil
	case order.FieldStatus:
		m.ResetStatus()
		return nil
	case order.FieldPayType:
		m.ResetPayType()
		return nil
	case order.FieldPaidAt:
		m.ResetPaidAt()
		return nil
	case order.FieldSubscriptionID:
		m.ResetSubscriptionID()
		return nil
	case order.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case order.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case order.FieldExpiredAt:
		m.ResetExpiredAt()
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.user != nil {
		edges = append(edges, order.EdgeUser)
	}
	if m.group != nil {
		edges = append(edges, order.EdgeGroup)
	}
	if m.subscription != nil {
		edges = append(edges, order.EdgeSubscription)
	}
	if m.referral_reward != nil {
		edges = append(edges, order.EdgeReferralReward)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case order.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeGroup:
		if id := m.group; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeSubscription:
		if id := m.subscription; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeReferralReward:
		if id := m.referral_reward; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareduser {
		edges = append(edges, order.EdgeUser)
	}
	if m.clearedgroup {
		edges = append(edges, order.EdgeGroup)
	}
	if m.clearedsubscription {
		edges = append(edges, order.EdgeSubscription)
	}
	if m.clearedreferral_reward {
		edges = append(edges, order.EdgeReferralReward)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderMutation) EdgeCleared(name string) bool {
	switch name {
	case order.EdgeUser:
		return m.cleareduser
	case order.EdgeGroup:
		return m.clearedgroup
	case order.EdgeSubscription:
		return m.clearedsubscription
	case order.EdgeReferralReward:
		return m.clearedreferral_reward
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderMutation) ClearEdge(name string) error {
	switch name {
	case order.EdgeUser:
		m.ClearUser()
		return nil
	case order.EdgeGroup:
		m.ClearGroup()
		return nil
	case order.EdgeSubscription:
		m.ClearSubscription()
		return nil
	case order.EdgeReferralReward:
		m.ClearReferralReward()
		return nil
	}
	return fmt.Errorf("unknown Order unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderMutation) ResetEdge(name string) error {
	switch name {
	case order.EdgeUser:
		m.ResetUser()
		return nil
	case order.EdgeGroup:
		m.ResetGroup()
		return nil
	case order.EdgeSubscription:
		m.ResetSubscription()
		return nil
	case order.EdgeReferralReward:
		m.ResetReferralReward()
		return nil
	}
	return fmt.Errorf("unknown Order edge %s", name)
}

// PromoCodeMutation represents an operation that mutates the PromoCode nodes in the graph.
type PromoCodeMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int64
	code                 *string
	bonus_amount         *float64
	addbonus_amount      *float64
	max_uses             *int
	addmax_uses          *int
	used_count           *int
	addused_count        *int
	status               *string
	expires_at           *time.Time
	notes                *string
	created_at           *time.Time
	updated_at           *time.Time
	clearedFields        map[string]struct{}
	usage_records        map[int64]struct{}
	removedusage_records map[int64]struct{}
	clearedusage_records bool
	done                 bool
	oldValue             func(context.Context) (*PromoCode, error)
	predicates           []predicate.PromoCode
}

var _ ent.Mutation = (*PromoCodeMutation)(nil)

// promocodeOption allows management of the mutation configuration using functional options.
type promocodeOption func(*PromoCodeMutation)

// newPromoCodeMutation creates new mutation for the PromoCode entity.
func newPromoCodeMutation(c config, op Op, opts ...promocodeOption) *PromoCodeMutation {
	m := &PromoCodeMutation{
		config:        c,
		op:            op,
		typ:           TypePromoCode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPromoCodeID sets the ID field of the mutation.
func withPromoCodeID(id int64) promocodeOption {
	return func(m *PromoCodeMutation) {
		var (
			err   error
			once  sync.Once
			value *PromoCode
		)
		m.oldValue = func(ctx context.Context) (*PromoCode, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PromoCode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPromoCode sets the old PromoCode of the mutation.
func withPromoCode(node *PromoCode) promocodeOption {
	return func(m *PromoCodeMutation) {
		m.oldValue = func(context.Context) (*PromoCode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PromoCodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PromoCodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PromoCodeMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PromoCodeMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PromoCode.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCode sets the "code" field.
func (m *PromoCodeMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *PromoCodeMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the PromoCode entity.
// If the PromoCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromoCodeMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *PromoCodeMutation) ResetCode() {
	m.code = nil
}

// SetBonusAmount sets the "bonus_amount" field.
func (m *PromoCodeMutation) SetBonusAmount(f float64) {
	m.bonus_amount = &f
	m.addbonus_amount = nil
}

// BonusAmount returns the value of the "bonus_amount" field in the mutation.
func (m *PromoCodeMutation) BonusAmount() (r float64, exists bool) {
	v := m.bonus_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldBonusAmount returns the old "bonus_amount" field's value of the PromoCode entity.
// If the PromoCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromoCodeMutation) OldBonusAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBonusAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBonusAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBonusAmount: %w", err)
	}
	return oldValue.BonusAmount, nil
}

// AddBonusAmount adds f to the "bonus_amount" field.
func (m *PromoCodeMutation) AddBonusAmount(f float64) {
	if m.addbonus_amount != nil {
		*m.addbonus_amount += f
	} else {
		m.addbonus_amount = &f
	}
}

// AddedBonusAmount returns the value that was added to the "bonus_amount" field in this mutation.
func (m *PromoCodeMutation) AddedBonusAmount() (r float64, exists bool) {
	v := m.addbonus_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetBonusAmount resets all changes to the "bonus_amount" field.
func (m *PromoCodeMutation) ResetBonusAmount() {
	m.bonus_amount = nil
	m.addbonus_amount = nil
}

// SetMaxUses sets the "max_uses" field.
func (m *PromoCodeMutation) SetMaxUses(i int) {
	m.max_uses = &i
	m.addmax_uses = nil
}

// MaxUses returns the value of the "max_uses" field in the mutation.
func (m *PromoCodeMutation) MaxUses() (r int, exists bool) {
	v := m.max_uses
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxUses returns the old "max_uses" field's value of the PromoCode entity.
// If the PromoCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromoCodeMutation) OldMaxUses(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxUses is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxUses requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxUses: %w", err)
	}
	return oldValue.MaxUses, nil
}

// AddMaxUses adds i to the "max_uses" field.
func (m *PromoCodeMutation) AddMaxUses(i int) {
	if m.addmax_uses != nil {
		*m.addmax_uses += i
	} else {
		m.addmax_uses = &i
	}
}

// AddedMaxUses returns the value that was added to the "max_uses" field in this mutation.
func (m *PromoCodeMutation) AddedMaxUses() (r int, exists bool) {
	v := m.addmax_uses
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxUses resets all changes to the "max_uses" field.
func (m *PromoCodeMutation) ResetMaxUses() {
	m.max_uses = nil
	m.addmax_uses = nil
}

// SetUsedCount sets the "used_count" field.
func (m *PromoCodeMutation) SetUsedCount(i int) {
	m.used_count = &i
	m.addused_count = nil
}

// UsedCount returns the value of the "used_count" field in the mutation.
func (m *PromoCodeMutation) UsedCount() (r int, exists bool) {
	v := m.used_count
	if v == nil {
		return
	}
	return *v, true
}

// OldUsedCount returns the old "used_count" field's value of the PromoCode entity.
// If the PromoCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromoCodeMutation) OldUsedCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsedCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsedCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsedCount: %w", err)
	}
	return oldValue.UsedCount, nil
}

// AddUsedCount adds i to the "used_count" field.
func (m *PromoCodeMutation) AddUsedCount(i int) {
	if m.addused_count != nil {
		*m.addused_count += i
	} else {
		m.addused_count = &i
	}
}

// AddedUsedCount returns the value that was added to the "used_count" field in this mutation.
func (m *PromoCodeMutation) AddedUsedCount() (r int, exists bool) {
	v := m.addused_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetUsedCount resets all changes to the "used_count" field.
func (m *PromoCodeMutation) ResetUsedCount() {
	m.used_count = nil
	m.addused_count = nil
}

// SetStatus sets the "status" field.
func (m *PromoCodeMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *PromoCodeMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the PromoCode entity.
// If the PromoCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromoCodeMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *PromoCodeMutation) ResetStatus() {
	m.status = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *PromoCodeMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *PromoCodeMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the PromoCode entity.
// If the PromoCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromoCodeMutation) OldExpiresAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *PromoCodeMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[promocode.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *PromoCodeMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[promocode.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *PromoCodeMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, promocode.FieldExpiresAt)
}

// SetNotes sets the "notes" field.
func (m *PromoCodeMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *PromoCodeMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the PromoCode entity.
// If the PromoCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromoCodeMutation) OldNotes(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *PromoCodeMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[promocode.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *PromoCodeMutation) NotesCleared() bool {
	_, ok := m.clearedFields[promocode.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *PromoCodeMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, promocode.FieldNotes)
}

// SetCreatedAt sets the "created_at" field.
func (m *PromoCodeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PromoCodeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PromoCode entity.
// If the PromoCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromoCodeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PromoCodeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PromoCodeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PromoCodeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PromoCode entity.
// If the PromoCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromoCodeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PromoCodeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddUsageRecordIDs adds the "usage_records" edge to the PromoCodeUsage entity by ids.
func (m *PromoCodeMutation) AddUsageRecordIDs(ids ...int64) {
	if m.usage_records == nil {
		m.usage_records = make(map[int64]struct{})
	}
	for i := range ids {
		m.usage_records[ids[i]] = struct{}{}
	}
}

// ClearUsageRecords clears the "usage_records" edge to the PromoCodeUsage entity.
func (m *PromoCodeMutation) ClearUsageRecords() {
	m.clearedusage_records = true
}

// UsageRecordsCleared reports if the "usage_records" edge to the PromoCodeUsage entity was cleared.
func (m *PromoCodeMutation) UsageRecordsCleared() bool {
	return m.clearedusage_records
}

// RemoveUsageRecordIDs removes the "usage_records" edge to the PromoCodeUsage entity by IDs.
func (m *PromoCodeMutation) RemoveUsageRecordIDs(ids ...int64) {
	if m.removedusage_records == nil {
		m.removedusage_records = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.usage_records, ids[i])
		m.removedusage_records[ids[i]] = struct{}{}
	}
}

// RemovedUsageRecords returns the removed IDs of the "usage_records" edge to the PromoCodeUsage entity.
func (m *PromoCodeMutation) RemovedUsageRecordsIDs() (ids []int64) {
	for id := range m.removedusage_records {
		ids = append(ids, id)
	}
	return
}

// UsageRecordsIDs returns the "usage_records" edge IDs in the mutation.
func (m *PromoCodeMutation) UsageRecordsIDs() (ids []int64) {
	for id := range m.usage_records {
		ids = append(ids, id)
	}
	return
}

// ResetUsageRecords resets all changes to the "usage_records" edge.
func (m *PromoCodeMutation) ResetUsageRecords() {
	m.usage_records = nil
	m.clearedusage_records = false
	m.removedusage_records = nil
}

// Where appends a list predicates to the PromoCodeMutation builder.
func (m *PromoCodeMutation) Where(ps ...predicate.PromoCode) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PromoCodeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PromoCodeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PromoCode, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PromoCodeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PromoCodeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PromoCode).
func (m *PromoCodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PromoCodeMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.code != nil {
		fields = append(fields, promocode.FieldCode)
	}
	if m.bonus_amount != nil {
		fields = append(fields, promocode.FieldBonusAmount)
	}
	if m.max_uses != nil {
		fields = append(fields, promocode.FieldMaxUses)
	}
	if m.used_count != nil {
		fields = append(fields, promocode.FieldUsedCount)
	}
	if m.status != nil {
		fields = append(fields, promocode.FieldStatus)
	}
	if m.expires_at != nil {
		fields = append(fields, promocode.FieldExpiresAt)
	}
	if m.notes != nil {
		fields = append(fields, promocode.FieldNotes)
	}
	if m.created_at != nil {
		fields = append(fields, promocode.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, promocode.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PromoCodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case promocode.FieldCode:
		return m.Code()
	case promocode.FieldBonusAmount:
		return m.BonusAmount()
	case promocode.FieldMaxUses:
		return m.MaxUses()
	case promocode.FieldUsedCount:
		return m.UsedCount()
	case promocode.FieldStatus:
		return m.Status()
	case promocode.FieldExpiresAt:
		return m.ExpiresAt()
	case promocode.FieldNotes:
		return m.Notes()
	case promocode.FieldCreatedAt:
		return m.CreatedAt()
	case promocode.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PromoCodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case promocode.FieldCode:
		return m.OldCode(ctx)
	case promocode.FieldBonusAmount:
		return m.OldBonusAmount(ctx)
	case promocode.FieldMaxUses:
		return m.OldMaxUses(ctx)
	case promocode.FieldUsedCount:
		return m.OldUsedCount(ctx)
	case promocode.FieldStatus:
		return m.OldStatus(ctx)
	case promocode.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case promocode.FieldNotes:
		return m.OldNotes(ctx)
	case promocode.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case promocode.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown PromoCode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromoCodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case promocode.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case promocode.FieldBonusAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBonusAmount(v)
		return nil
	case promocode.FieldMaxUses:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxUses(v)
		return nil
	case promocode.FieldUsedCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsedCount(v)
		return nil
	case promocode.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case promocode.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case promocode.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	case promocode.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case promocode.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PromoCode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PromoCodeMutation) AddedFields() []string {
	var fields []string
	if m.addbonus_amount != nil {
		fields = append(fields, promocode.FieldBonusAmount)
	}
	if m.addmax_uses != nil {
		fields = append(fields, promocode.FieldMaxUses)
	}
	if m.addused_count != nil {
		fields = append(fields, promocode.FieldUsedCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PromoCodeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case promocode.FieldBonusAmount:
		return m.AddedBonusAmount()
	case promocode.FieldMaxUses:
		return m.AddedMaxUses()
	case promocode.FieldUsedCount:
		return m.AddedUsedCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromoCodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case promocode.FieldBonusAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBonusAmount(v)
		return nil
	case promocode.FieldMaxUses:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxUses(v)
		return nil
	case promocode.FieldUsedCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUsedCount(v)
		return nil
	}
	return fmt.Errorf("unknown PromoCode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PromoCodeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(promocode.FieldExpiresAt) {
		fields = append(fields, promocode.FieldExpiresAt)
	}
	if m.FieldCleared(promocode.FieldNotes) {
		fields = append(fields, promocode.FieldNotes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PromoCodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PromoCodeMutation) ClearField(name string) error {
	switch name {
	case promocode.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	case promocode.FieldNotes:
		m.ClearNotes()
		return nil
	}
	return fmt.Errorf("unknown PromoCode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PromoCodeMutation) ResetField(name string) error {
	switch name {
	case promocode.FieldCode:
		m.ResetCode()
		return nil
	case promocode.FieldBonusAmount:
		m.ResetBonusAmount()
		return nil
	case promocode.FieldMaxUses:
		m.ResetMaxUses()
		return nil
	case promocode.FieldUsedCount:
		m.ResetUsedCount()
		return nil
	case promocode.FieldStatus:
		m.ResetStatus()
		return nil
	case promocode.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case promocode.FieldNotes:
		m.ResetNotes()
		return nil
	case promocode.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case promocode.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown PromoCode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PromoCodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.usage_records != nil {
		edges = append(edges, promocode.EdgeUsageRecords)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PromoCodeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case promocode.EdgeUsageRecords:
		ids := make([]ent.Value, 0, len(m.usage_records))
		for id := range m.usage_records {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PromoCodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedusage_records != nil {
		edges = append(edges, promocode.EdgeUsageRecords)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PromoCodeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case promocode.EdgeUsageRecords:
		ids := make([]ent.Value, 0, len(m.removedusage_records))
		for id := range m.removedusage_records {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PromoCodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedusage_records {
		edges = append(edges, promocode.EdgeUsageRecords)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PromoCodeMutation) EdgeCleared(name string) bool {
	switch name {
	case promocode.EdgeUsageRecords:
		return m.clearedusage_records
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PromoCodeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown PromoCode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PromoCodeMutation) ResetEdge(name string) error {
	switch name {
	case promocode.EdgeUsageRecords:
		m.ResetUsageRecords()
		return nil
	}
	return fmt.Errorf("unknown PromoCode edge %s", name)
}

// PromoCodeUsageMutation represents an operation that mutates the PromoCodeUsage nodes in the graph.
type PromoCodeUsageMutation struct {
	config
	op                Op
	typ               string
	id                *int64
	bonus_amount      *float64
	addbonus_amount   *float64
	used_at           *time.Time
	clearedFields     map[string]struct{}
	promo_code        *int64
	clearedpromo_code bool
	user              *int64
	cleareduser       bool
	done              bool
	oldValue          func(context.Context) (*PromoCodeUsage, error)
	predicates        []predicate.PromoCodeUsage
}

var _ ent.Mutation = (*PromoCodeUsageMutation)(nil)

// promocodeusageOption allows management of the mutation configuration using functional options.
type promocodeusageOption func(*PromoCodeUsageMutation)

// newPromoCodeUsageMutation creates new mutation for the PromoCodeUsage entity.
func newPromoCodeUsageMutation(c config, op Op, opts ...promocodeusageOption) *PromoCodeUsageMutation {
	m := &PromoCodeUsageMutation{
		config:        c,
		op:            op,
		typ:           TypePromoCodeUsage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPromoCodeUsageID sets the ID field of the mutation.
func withPromoCodeUsageID(id int64) promocodeusageOption {
	return func(m *PromoCodeUsageMutation) {
		var (
			err   error
			once  sync.Once
			value *PromoCodeUsage
		)
		m.oldValue = func(ctx context.Context) (*PromoCodeUsage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PromoCodeUsage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPromoCodeUsage sets the old PromoCodeUsage of the mutation.
func withPromoCodeUsage(node *PromoCodeUsage) promocodeusageOption {
	return func(m *PromoCodeUsageMutation) {
		m.oldValue = func(context.Context) (*PromoCodeUsage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PromoCodeUsageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PromoCodeUsageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PromoCodeUsageMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PromoCodeUsageMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PromoCodeUsage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPromoCodeID sets the "promo_code_id" field.
func (m *PromoCodeUsageMutation) SetPromoCodeID(i int64) {
	m.promo_code = &i
}

// PromoCodeID returns the value of the "promo_code_id" field in the mutation.
func (m *PromoCodeUsageMutation) PromoCodeID() (r int64, exists bool) {
	v := m.promo_code
	if v == nil {
		return
	}
	return *v, true
}

// OldPromoCodeID returns the old "promo_code_id" field's value of the PromoCodeUsage entity.
// If the PromoCodeUsage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromoCodeUsageMutation) OldPromoCodeID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPromoCodeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPromoCodeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPromoCodeID: %w", err)
	}
	return oldValue.PromoCodeID, nil
}

// ResetPromoCodeID resets all changes to the "promo_code_id" field.
func (m *PromoCodeUsageMutation) ResetPromoCodeID() {
	m.promo_code = nil
}

// SetUserID sets the "user_id" field.
func (m *PromoCodeUsageMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *PromoCodeUsageMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the PromoCodeUsage entity.
// If the PromoCodeUsage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromoCodeUsageMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *PromoCodeUsageMutation) ResetUserID() {
	m.user = nil
}

// SetBonusAmount sets the "bonus_amount" field.
func (m *PromoCodeUsageMutation) SetBonusAmount(f float64) {
	m.bonus_amount = &f
	m.addbonus_amount = nil
}

// BonusAmount returns the value of the "bonus_amount" field in the mutation.
func (m *PromoCodeUsageMutation) BonusAmount() (r float64, exists bool) {
	v := m.bonus_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldBonusAmount returns the old "bonus_amount" field's value of the PromoCodeUsage entity.
// If the PromoCodeUsage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromoCodeUsageMutation) OldBonusAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBonusAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBonusAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBonusAmount: %w", err)
	}
	return oldValue.BonusAmount, nil
}

// AddBonusAmount adds f to the "bonus_amount" field.
func (m *PromoCodeUsageMutation) AddBonusAmount(f float64) {
	if m.addbonus_amount != nil {
		*m.addbonus_amount += f
	} else {
		m.addbonus_amount = &f
	}
}

// AddedBonusAmount returns the value that was added to the "bonus_amount" field in this mutation.
func (m *PromoCodeUsageMutation) AddedBonusAmount() (r float64, exists bool) {
	v := m.addbonus_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetBonusAmount resets all changes to the "bonus_amount" field.
func (m *PromoCodeUsageMutation) ResetBonusAmount() {
	m.bonus_amount = nil
	m.addbonus_amount = nil
}

// SetUsedAt sets the "used_at" field.
func (m *PromoCodeUsageMutation) SetUsedAt(t time.Time) {
	m.used_at = &t
}

// UsedAt returns the value of the "used_at" field in the mutation.
func (m *PromoCodeUsageMutation) UsedAt() (r time.Time, exists bool) {
	v := m.used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUsedAt returns the old "used_at" field's value of the PromoCodeUsage entity.
// If the PromoCodeUsage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromoCodeUsageMutation) OldUsedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsedAt: %w", err)
	}
	return oldValue.UsedAt, nil
}

// ResetUsedAt resets all changes to the "used_at" field.
func (m *PromoCodeUsageMutation) ResetUsedAt() {
	m.used_at = nil
}

// ClearPromoCode clears the "promo_code" edge to the PromoCode entity.
func (m *PromoCodeUsageMutation) ClearPromoCode() {
	m.clearedpromo_code = true
	m.clearedFields[promocodeusage.FieldPromoCodeID] = struct{}{}
}

// PromoCodeCleared reports if the "promo_code" edge to the PromoCode entity was cleared.
func (m *PromoCodeUsageMutation) PromoCodeCleared() bool {
	return m.clearedpromo_code
}

// PromoCodeIDs returns the "promo_code" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PromoCodeID instead. It exists only for internal usage by the builders.
func (m *PromoCodeUsageMutation) PromoCodeIDs() (ids []int64) {
	if id := m.promo_code; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPromoCode resets all changes to the "promo_code" edge.
func (m *PromoCodeUsageMutation) ResetPromoCode() {
	m.promo_code = nil
	m.clearedpromo_code = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *PromoCodeUsageMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[promocodeusage.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *PromoCodeUsageMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *PromoCodeUsageMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *PromoCodeUsageMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the PromoCodeUsageMutation builder.
func (m *PromoCodeUsageMutation) Where(ps ...predicate.PromoCodeUsage) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PromoCodeUsageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PromoCodeUsageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PromoCodeUsage, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PromoCodeUsageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PromoCodeUsageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PromoCodeUsage).
func (m *PromoCodeUsageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PromoCodeUsageMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.promo_code != nil {
		fields = append(fields, promocodeusage.FieldPromoCodeID)
	}
	if m.user != nil {
		fields = append(fields, promocodeusage.FieldUserID)
	}
	if m.bonus_amount != nil {
		fields = append(fields, promocodeusage.FieldBonusAmount)
	}
	if m.used_at != nil {
		fields = append(fields, promocodeusage.FieldUsedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PromoCodeUsageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case promocodeusage.FieldPromoCodeID:
		return m.PromoCodeID()
	case promocodeusage.FieldUserID:
		return m.UserID()
	case promocodeusage.FieldBonusAmount:
		return m.BonusAmount()
	case promocodeusage.FieldUsedAt:
		return m.UsedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PromoCodeUsageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case promocodeusage.FieldPromoCodeID:
		return m.OldPromoCodeID(ctx)
	case promocodeusage.FieldUserID:
		return m.OldUserID(ctx)
	case promocodeusage.FieldBonusAmount:
		return m.OldBonusAmount(ctx)
	case promocodeusage.FieldUsedAt:
		return m.OldUsedAt(ctx)
	}
	return nil, fmt.Errorf("unknown PromoCodeUsage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromoCodeUsageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case promocodeusage.FieldPromoCodeID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPromoCodeID(v)
		return nil
	case promocodeusage.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case promocodeusage.FieldBonusAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBonusAmount(v)
		return nil
	case promocodeusage.FieldUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PromoCodeUsage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PromoCodeUsageMutation) AddedFields() []string {
	var fields []string
	if m.addbonus_amount != nil {
		fields = append(fields, promocodeusage.FieldBonusAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PromoCodeUsageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case promocodeusage.FieldBonusAmount:
		return m.AddedBonusAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromoCodeUsageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case promocodeusage.FieldBonusAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBonusAmount(v)
		return nil
	}
	return fmt.Errorf("unknown PromoCodeUsage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PromoCodeUsageMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PromoCodeUsageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PromoCodeUsageMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PromoCodeUsage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PromoCodeUsageMutation) ResetField(name string) error {
	switch name {
	case promocodeusage.FieldPromoCodeID:
		m.ResetPromoCodeID()
		return nil
	case promocodeusage.FieldUserID:
		m.ResetUserID()
		return nil
	case promocodeusage.FieldBonusAmount:
		m.ResetBonusAmount()
		return nil
	case promocodeusage.FieldUsedAt:
		m.ResetUsedAt()
		return nil
	}
	return fmt.Errorf("unknown PromoCodeUsage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PromoCodeUsageMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.promo_code != nil {
		edges = append(edges, promocodeusage.EdgePromoCode)
	}
	if m.user != nil {
		edges = append(edges, promocodeusage.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PromoCodeUsageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case promocodeusage.EdgePromoCode:
		if id := m.promo_code; id != nil {
			return []ent.Value{*id}
		}
	case promocodeusage.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PromoCodeUsageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PromoCodeUsageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PromoCodeUsageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedpromo_code {
		edges = append(edges, promocodeusage.EdgePromoCode)
	}
	if m.cleareduser {
		edges = append(edges, promocodeusage.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PromoCodeUsageMutation) EdgeCleared(name string) bool {
	switch name {
	case promocodeusage.EdgePromoCode:
		return m.clearedpromo_code
	case promocodeusage.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PromoCodeUsageMutation) ClearEdge(name string) error {
	switch name {
	case promocodeusage.EdgePromoCode:
		m.ClearPromoCode()
		return nil
	case promocodeusage.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown PromoCodeUsage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PromoCodeUsageMutation) ResetEdge(name string) error {
	switch name {
	case promocodeusage.EdgePromoCode:
		m.ResetPromoCode()
		return nil
	case promocodeusage.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown PromoCodeUsage edge %s", name)
}

// ProxyMutation represents an operation that mutates the Proxy nodes in the graph.
type ProxyMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *time.Time
	name            *string
	protocol        *string
	host            *string
	port            *int
	addport         *int
	username        *string
	password        *string
	status          *string
	clearedFields   map[string]struct{}
	accounts        map[int64]struct{}
	removedaccounts map[int64]struct{}
	clearedaccounts bool
	done            bool
	oldValue        func(context.Context) (*Proxy, error)
	predicates      []predicate.Proxy
}

var _ ent.Mutation = (*ProxyMutation)(nil)

// proxyOption allows management of the mutation configuration using functional options.
type proxyOption func(*ProxyMutation)

// newProxyMutation creates new mutation for the Proxy entity.
func newProxyMutation(c config, op Op, opts ...proxyOption) *ProxyMutation {
	m := &ProxyMutation{
		config:        c,
		op:            op,
		typ:           TypeProxy,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProxyID sets the ID field of the mutation.
func withProxyID(id int64) proxyOption {
	return func(m *ProxyMutation) {
		var (
			err   error
			once  sync.Once
			value *Proxy
		)
		m.oldValue = func(ctx context.Context) (*Proxy, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Proxy.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProxy sets the old Proxy of the mutation.
func withProxy(node *Proxy) proxyOption {
	return func(m *ProxyMutation) {
		m.oldValue = func(context.Context) (*Proxy, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProxyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProxyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProxyMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProxyMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Proxy.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProxyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProxyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProxyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProxyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProxyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProxyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ProxyMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ProxyMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ProxyMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[proxy.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ProxyMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[proxy.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ProxyMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, proxy.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *ProxyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProxyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProxyMutation) ResetName() {
	m.name = nil
}

// SetProtocol sets the "protocol" field.
func (m *ProxyMutation) SetProtocol(s string) {
	m.protocol = &s
}

// Protocol returns the value of the "protocol" field in the mutation.
func (m *ProxyMutation) Protocol() (r string, exists bool) {
	v := m.protocol
	if v == nil {
		return
	}
	return *v, true
}

// OldProtocol returns the old "protocol" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldProtocol(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProtocol is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProtocol requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProtocol: %w", err)
	}
	return oldValue.Protocol, nil
}

// ResetProtocol resets all changes to the "protocol" field.
func (m *ProxyMutation) ResetProtocol() {
	m.protocol = nil
}

// SetHost sets the "host" field.
func (m *ProxyMutation) SetHost(s string) {
	m.host = &s
}

// Host returns the value of the "host" field in the mutation.
func (m *ProxyMutation) Host() (r string, exists bool) {
	v := m.host
	if v == nil {
		return
	}
	return *v, true
}

// OldHost returns the old "host" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldHost(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHost: %w", err)
	}
	return oldValue.Host, nil
}

// ResetHost resets all changes to the "host" field.
func (m *ProxyMutation) ResetHost() {
	m.host = nil
}

// SetPort sets the "port" field.
func (m *ProxyMutation) SetPort(i int) {
	m.port = &i
	m.addport = nil
}

// Port returns the value of the "port" field in the mutation.
func (m *ProxyMutation) Port() (r int, exists bool) {
	v := m.port
	if v == nil {
		return
	}
	return *v, true
}

// OldPort returns the old "port" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldPort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPort: %w", err)
	}
	return oldValue.Port, nil
}

// AddPort adds i to the "port" field.
func (m *ProxyMutation) AddPort(i int) {
	if m.addport != nil {
		*m.addport += i
	} else {
		m.addport = &i
	}
}

// AddedPort returns the value that was added to the "port" field in this mutation.
func (m *ProxyMutation) AddedPort() (r int, exists bool) {
	v := m.addport
	if v == nil {
		return
	}
	return *v, true
}

// ResetPort resets all changes to the "port" field.
func (m *ProxyMutation) ResetPort() {
	m.port = nil
	m.addport = nil
}

// SetUsername sets the "username" field.
func (m *ProxyMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *ProxyMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldUsername(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ClearUsername clears the value of the "username" field.
func (m *ProxyMutation) ClearUsername() {
	m.username = nil
	m.clearedFields[proxy.FieldUsername] = struct{}{}
}

// UsernameCleared returns if the "username" field was cleared in this mutation.
func (m *ProxyMutation) UsernameCleared() bool {
	_, ok := m.clearedFields[proxy.FieldUsername]
	return ok
}

// ResetUsername resets all changes to the "username" field.
func (m *ProxyMutation) ResetUsername() {
	m.username = nil
	delete(m.clearedFields, proxy.FieldUsername)
}

// SetPassword sets the "password" field.
func (m *ProxyMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *ProxyMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldPassword(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ClearPassword clears the value of the "password" field.
func (m *ProxyMutation) ClearPassword() {
	m.password = nil
	m.clearedFields[proxy.FieldPassword] = struct{}{}
}

// PasswordCleared returns if the "password" field was cleared in this mutation.
func (m *ProxyMutation) PasswordCleared() bool {
	_, ok := m.clearedFields[proxy.FieldPassword]
	return ok
}

// ResetPassword resets all changes to the "password" field.
func (m *ProxyMutation) ResetPassword() {
	m.password = nil
	delete(m.clearedFields, proxy.FieldPassword)
}

// SetStatus sets the "status" field.
func (m *ProxyMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ProxyMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Proxy entity.
// If the Proxy object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProxyMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ProxyMutation) ResetStatus() {
	m.status = nil
}

// AddAccountIDs adds the "accounts" edge to the Account entity by ids.
func (m *ProxyMutation) AddAccountIDs(ids ...int64) {
	if m.accounts == nil {
		m.accounts = make(map[int64]struct{})
	}
	for i := range ids {
		m.accounts[ids[i]] = struct{}{}
	}
}

// ClearAccounts clears the "accounts" edge to the Account entity.
func (m *ProxyMutation) ClearAccounts() {
	m.clearedaccounts = true
}

// AccountsCleared reports if the "accounts" edge to the Account entity was cleared.
func (m *ProxyMutation) AccountsCleared() bool {
	return m.clearedaccounts
}

// RemoveAccountIDs removes the "accounts" edge to the Account entity by IDs.
func (m *ProxyMutation) RemoveAccountIDs(ids ...int64) {
	if m.removedaccounts == nil {
		m.removedaccounts = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.accounts, ids[i])
		m.removedaccounts[ids[i]] = struct{}{}
	}
}

// RemovedAccounts returns the removed IDs of the "accounts" edge to the Account entity.
func (m *ProxyMutation) RemovedAccountsIDs() (ids []int64) {
	for id := range m.removedaccounts {
		ids = append(ids, id)
	}
	return
}

// AccountsIDs returns the "accounts" edge IDs in the mutation.
func (m *ProxyMutation) AccountsIDs() (ids []int64) {
	for id := range m.accounts {
		ids = append(ids, id)
	}
	return
}

// ResetAccounts resets all changes to the "accounts" edge.
func (m *ProxyMutation) ResetAccounts() {
	m.accounts = nil
	m.clearedaccounts = false
	m.removedaccounts = nil
}

// Where appends a list predicates to the ProxyMutation builder.
func (m *ProxyMutation) Where(ps ...predicate.Proxy) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProxyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProxyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Proxy, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProxyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProxyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Proxy).
func (m *ProxyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProxyMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, proxy.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, proxy.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, proxy.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, proxy.FieldName)
	}
	if m.protocol != nil {
		fields = append(fields, proxy.FieldProtocol)
	}
	if m.host != nil {
		fields = append(fields, proxy.FieldHost)
	}
	if m.port != nil {
		fields = append(fields, proxy.FieldPort)
	}
	if m.username != nil {
		fields = append(fields, proxy.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, proxy.FieldPassword)
	}
	if m.status != nil {
		fields = append(fields, proxy.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProxyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case proxy.FieldCreatedAt:
		return m.CreatedAt()
	case proxy.FieldUpdatedAt:
		return m.UpdatedAt()
	case proxy.FieldDeletedAt:
		return m.DeletedAt()
	case proxy.FieldName:
		return m.Name()
	case proxy.FieldProtocol:
		return m.Protocol()
	case proxy.FieldHost:
		return m.Host()
	case proxy.FieldPort:
		return m.Port()
	case proxy.FieldUsername:
		return m.Username()
	case proxy.FieldPassword:
		return m.Password()
	case proxy.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProxyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case proxy.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case proxy.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case proxy.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case proxy.FieldName:
		return m.OldName(ctx)
	case proxy.FieldProtocol:
		return m.OldProtocol(ctx)
	case proxy.FieldHost:
		return m.OldHost(ctx)
	case proxy.FieldPort:
		return m.OldPort(ctx)
	case proxy.FieldUsername:
		return m.OldUsername(ctx)
	case proxy.FieldPassword:
		return m.OldPassword(ctx)
	case proxy.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Proxy field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProxyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case proxy.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case proxy.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case proxy.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case proxy.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case proxy.FieldProtocol:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProtocol(v)
		return nil
	case proxy.FieldHost:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHost(v)
		return nil
	case proxy.FieldPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPort(v)
		return nil
	case proxy.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case proxy.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case proxy.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Proxy field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProxyMutation) AddedFields() []string {
	var fields []string
	if m.addport != nil {
		fields = append(fields, proxy.FieldPort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProxyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case proxy.FieldPort:
		return m.AddedPort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProxyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case proxy.FieldPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPort(v)
		return nil
	}
	return fmt.Errorf("unknown Proxy numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProxyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(proxy.FieldDeletedAt) {
		fields = append(fields, proxy.FieldDeletedAt)
	}
	if m.FieldCleared(proxy.FieldUsername) {
		fields = append(fields, proxy.FieldUsername)
	}
	if m.FieldCleared(proxy.FieldPassword) {
		fields = append(fields, proxy.FieldPassword)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProxyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProxyMutation) ClearField(name string) error {
	switch name {
	case proxy.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case proxy.FieldUsername:
		m.ClearUsername()
		return nil
	case proxy.FieldPassword:
		m.ClearPassword()
		return nil
	}
	return fmt.Errorf("unknown Proxy nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProxyMutation) ResetField(name string) error {
	switch name {
	case proxy.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case proxy.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case proxy.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case proxy.FieldName:
		m.ResetName()
		return nil
	case proxy.FieldProtocol:
		m.ResetProtocol()
		return nil
	case proxy.FieldHost:
		m.ResetHost()
		return nil
	case proxy.FieldPort:
		m.ResetPort()
		return nil
	case proxy.FieldUsername:
		m.ResetUsername()
		return nil
	case proxy.FieldPassword:
		m.ResetPassword()
		return nil
	case proxy.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Proxy field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProxyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.accounts != nil {
		edges = append(edges, proxy.EdgeAccounts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProxyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case proxy.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.accounts))
		for id := range m.accounts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProxyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedaccounts != nil {
		edges = append(edges, proxy.EdgeAccounts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProxyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case proxy.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.removedaccounts))
		for id := range m.removedaccounts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProxyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedaccounts {
		edges = append(edges, proxy.EdgeAccounts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProxyMutation) EdgeCleared(name string) bool {
	switch name {
	case proxy.EdgeAccounts:
		return m.clearedaccounts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProxyMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Proxy unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProxyMutation) ResetEdge(name string) error {
	switch name {
	case proxy.EdgeAccounts:
		m.ResetAccounts()
		return nil
	}
	return fmt.Errorf("unknown Proxy edge %s", name)
}

// RechargeOrderMutation represents an operation that mutates the RechargeOrder nodes in the graph.
type RechargeOrderMutation struct {
	config
	op               Op
	typ              string
	id               *int64
	order_no         *string
	trade_no         *string
	amount           *float64
	addamount        *float64
	credit_amount    *float64
	addcredit_amount *float64
	multiplier       *float64
	addmultiplier    *float64
	status           *string
	pay_type         *string
	paid_at          *time.Time
	created_at       *time.Time
	updated_at       *time.Time
	expired_at       *time.Time
	clearedFields    map[string]struct{}
	user             *int64
	cleareduser      bool
	done             bool
	oldValue         func(context.Context) (*RechargeOrder, error)
	predicates       []predicate.RechargeOrder
}

var _ ent.Mutation = (*RechargeOrderMutation)(nil)

// rechargeorderOption allows management of the mutation configuration using functional options.
type rechargeorderOption func(*RechargeOrderMutation)

// newRechargeOrderMutation creates new mutation for the RechargeOrder entity.
func newRechargeOrderMutation(c config, op Op, opts ...rechargeorderOption) *RechargeOrderMutation {
	m := &RechargeOrderMutation{
		config:        c,
		op:            op,
		typ:           TypeRechargeOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRechargeOrderID sets the ID field of the mutation.
func withRechargeOrderID(id int64) rechargeorderOption {
	return func(m *RechargeOrderMutation) {
		var (
			err   error
			once  sync.Once
			value *RechargeOrder
		)
		m.oldValue = func(ctx context.Context) (*RechargeOrder, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RechargeOrder.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRechargeOrder sets the old RechargeOrder of the mutation.
func withRechargeOrder(node *RechargeOrder) rechargeorderOption {
	return func(m *RechargeOrderMutation) {
		m.oldValue = func(context.Context) (*RechargeOrder, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RechargeOrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RechargeOrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RechargeOrderMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RechargeOrderMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RechargeOrder.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOrderNo sets the "order_no" field.
func (m *RechargeOrderMutation) SetOrderNo(s string) {
	m.order_no = &s
}

// OrderNo returns the value of the "order_no" field in the mutation.
func (m *RechargeOrderMutation) OrderNo() (r string, exists bool) {
	v := m.order_no
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderNo returns the old "order_no" field's value of the RechargeOrder entity.
// If the RechargeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeOrderMutation) OldOrderNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderNo: %w", err)
	}
	return oldValue.OrderNo, nil
}

// ResetOrderNo resets all changes to the "order_no" field.
func (m *RechargeOrderMutation) ResetOrderNo() {
	m.order_no = nil
}

// SetTradeNo sets the "trade_no" field.
func (m *RechargeOrderMutation) SetTradeNo(s string) {
	m.trade_no = &s
}

// TradeNo returns the value of the "trade_no" field in the mutation.
func (m *RechargeOrderMutation) TradeNo() (r string, exists bool) {
	v := m.trade_no
	if v == nil {
		return
	}
	return *v, true
}

// OldTradeNo returns the old "trade_no" field's value of the RechargeOrder entity.
// If the RechargeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeOrderMutation) OldTradeNo(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTradeNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTradeNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTradeNo: %w", err)
	}
	return oldValue.TradeNo, nil
}

// ClearTradeNo clears the value of the "trade_no" field.
func (m *RechargeOrderMutation) ClearTradeNo() {
	m.trade_no = nil
	m.clearedFields[rechargeorder.FieldTradeNo] = struct{}{}
}

// TradeNoCleared returns if the "trade_no" field was cleared in this mutation.
func (m *RechargeOrderMutation) TradeNoCleared() bool {
	_, ok := m.clearedFields[rechargeorder.FieldTradeNo]
	return ok
}

// ResetTradeNo resets all changes to the "trade_no" field.
func (m *RechargeOrderMutation) ResetTradeNo() {
	m.trade_no = nil
	delete(m.clearedFields, rechargeorder.FieldTradeNo)
}

// SetUserID sets the "user_id" field.
func (m *RechargeOrderMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *RechargeOrderMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the RechargeOrder entity.
// If the RechargeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeOrderMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *RechargeOrderMutation) ResetUserID() {
	m.user = nil
}

// SetAmount sets the "amount" field.
func (m *RechargeOrderMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *RechargeOrderMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the RechargeOrder entity.
// If the RechargeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeOrderMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *RechargeOrderMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *RechargeOrderMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *RechargeOrderMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetCreditAmount sets the "credit_amount" field.
func (m *RechargeOrderMutation) SetCreditAmount(f float64) {
	m.credit_amount = &f
	m.addcredit_amount = nil
}

// CreditAmount returns the value of the "credit_amount" field in the mutation.
func (m *RechargeOrderMutation) CreditAmount() (r float64, exists bool) {
	v := m.credit_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldCreditAmount returns the old "credit_amount" field's value of the RechargeOrder entity.
// If the RechargeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeOrderMutation) OldCreditAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreditAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreditAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreditAmount: %w", err)
	}
	return oldValue.CreditAmount, nil
}

// AddCreditAmount adds f to the "credit_amount" field.
func (m *RechargeOrderMutation) AddCreditAmount(f float64) {
	if m.addcredit_amount != nil {
		*m.addcredit_amount += f
	} else {
		m.addcredit_amount = &f
	}
}

// AddedCreditAmount returns the value that was added to the "credit_amount" field in this mutation.
func (m *RechargeOrderMutation) AddedCreditAmount() (r float64, exists bool) {
	v := m.addcredit_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreditAmount resets all changes to the "credit_amount" field.
func (m *RechargeOrderMutation) ResetCreditAmount() {
	m.credit_amount = nil
	m.addcredit_amount = nil
}

// SetMultiplier sets the "multiplier" field.
func (m *RechargeOrderMutation) SetMultiplier(f float64) {
	m.multiplier = &f
	m.addmultiplier = nil
}

// Multiplier returns the value of the "multiplier" field in the mutation.
func (m *RechargeOrderMutation) Multiplier() (r float64, exists bool) {
	v := m.multiplier
	if v == nil {
		return
	}
	return *v, true
}

// OldMultiplier returns the old "multiplier" field's value of the RechargeOrder entity.
// If the RechargeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeOrderMutation) OldMultiplier(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMultiplier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMultiplier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMultiplier: %w", err)
	}
	return oldValue.Multiplier, nil
}

// AddMultiplier adds f to the "multiplier" field.
func (m *RechargeOrderMutation) AddMultiplier(f float64) {
	if m.addmultiplier != nil {
		*m.addmultiplier += f
	} else {
		m.addmultiplier = &f
	}
}

// AddedMultiplier returns the value that was added to the "multiplier" field in this mutation.
func (m *RechargeOrderMutation) AddedMultiplier() (r float64, exists bool) {
	v := m.addmultiplier
	if v == nil {
		return
	}
	return *v, true
}

// ResetMultiplier resets all changes to the "multiplier" field.
func (m *RechargeOrderMutation) ResetMultiplier() {
	m.multiplier = nil
	m.addmultiplier = nil
}

// SetStatus sets the "status" field.
func (m *RechargeOrderMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *RechargeOrderMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the RechargeOrder entity.
// If the RechargeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeOrderMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *RechargeOrderMutation) ResetStatus() {
	m.status = nil
}

// SetPayType sets the "pay_type" field.
func (m *RechargeOrderMutation) SetPayType(s string) {
	m.pay_type = &s
}

// PayType returns the value of the "pay_type" field in the mutation.
func (m *RechargeOrderMutation) PayType() (r string, exists bool) {
	v := m.pay_type
	if v == nil {
		return
	}
	return *v, true
}

// OldPayType returns the old "pay_type" field's value of the RechargeOrder entity.
// If the RechargeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeOrderMutation) OldPayType(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayType: %w", err)
	}
	return oldValue.PayType, nil
}

// ClearPayType clears the value of the "pay_type" field.
func (m *RechargeOrderMutation) ClearPayType() {
	m.pay_type = nil
	m.clearedFields[rechargeorder.FieldPayType] = struct{}{}
}

// PayTypeCleared returns if the "pay_type" field was cleared in this mutation.
func (m *RechargeOrderMutation) PayTypeCleared() bool {
	_, ok := m.clearedFields[rechargeorder.FieldPayType]
	return ok
}

// ResetPayType resets all changes to the "pay_type" field.
func (m *RechargeOrderMutation) ResetPayType() {
	m.pay_type = nil
	delete(m.clearedFields, rechargeorder.FieldPayType)
}

// SetPaidAt sets the "paid_at" field.
func (m *RechargeOrderMutation) SetPaidAt(t time.Time) {
	m.paid_at = &t
}

// PaidAt returns the value of the "paid_at" field in the mutation.
func (m *RechargeOrderMutation) PaidAt() (r time.Time, exists bool) {
	v := m.paid_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPaidAt returns the old "paid_at" field's value of the RechargeOrder entity.
// If the RechargeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeOrderMutation) OldPaidAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaidAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaidAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaidAt: %w", err)
	}
	return oldValue.PaidAt, nil
}

// ClearPaidAt clears the value of the "paid_at" field.
func (m *RechargeOrderMutation) ClearPaidAt() {
	m.paid_at = nil
	m.clearedFields[rechargeorder.FieldPaidAt] = struct{}{}
}

// PaidAtCleared returns if the "paid_at" field was cleared in this mutation.
func (m *RechargeOrderMutation) PaidAtCleared() bool {
	_, ok := m.clearedFields[rechargeorder.FieldPaidAt]
	return ok
}

// ResetPaidAt resets all changes to the "paid_at" field.
func (m *RechargeOrderMutation) ResetPaidAt() {
	m.paid_at = nil
	delete(m.clearedFields, rechargeorder.FieldPaidAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *RechargeOrderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RechargeOrderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RechargeOrder entity.
// If the RechargeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeOrderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RechargeOrderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RechargeOrderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RechargeOrderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RechargeOrder entity.
// If the RechargeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeOrderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RechargeOrderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetExpiredAt sets the "expired_at" field.
func (m *RechargeOrderMutation) SetExpiredAt(t time.Time) {
	m.expired_at = &t
}

// ExpiredAt returns the value of the "expired_at" field in the mutation.
func (m *RechargeOrderMutation) ExpiredAt() (r time.Time, exists bool) {
	v := m.expired_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiredAt returns the old "expired_at" field's value of the RechargeOrder entity.
// If the RechargeOrder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RechargeOrderMutation) OldExpiredAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiredAt: %w", err)
	}
	return oldValue.ExpiredAt, nil
}

// ClearExpiredAt clears the value of the "expired_at" field.
func (m *RechargeOrderMutation) ClearExpiredAt() {
	m.expired_at = nil
	m.clearedFields[rechargeorder.FieldExpiredAt] = struct{}{}
}

// ExpiredAtCleared returns if the "expired_at" field was cleared in this mutation.
func (m *RechargeOrderMutation) ExpiredAtCleared() bool {
	_, ok := m.clearedFields[rechargeorder.FieldExpiredAt]
	return ok
}

// ResetExpiredAt resets all changes to the "expired_at" field.
func (m *RechargeOrderMutation) ResetExpiredAt() {
	m.expired_at = nil
	delete(m.clearedFields, rechargeorder.FieldExpiredAt)
}

// ClearUser clears the "user" edge to the User entity.
func (m *RechargeOrderMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[rechargeorder.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *RechargeOrderMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *RechargeOrderMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *RechargeOrderMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the RechargeOrderMutation builder.
func (m *RechargeOrderMutation) Where(ps ...predicate.RechargeOrder) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RechargeOrderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RechargeOrderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RechargeOrder, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RechargeOrderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RechargeOrderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RechargeOrder).
func (m *RechargeOrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RechargeOrderMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.order_no != nil {
		fields = append(fields, rechargeorder.FieldOrderNo)
	}
	if m.trade_no != nil {
		fields = append(fields, rechargeorder.FieldTradeNo)
	}
	if m.user != nil {
		fields = append(fields, rechargeorder.FieldUserID)
	}
	if m.amount != nil {
		fields = append(fields, rechargeorder.FieldAmount)
	}
	if m.credit_amount != nil {
		fields = append(fields, rechargeorder.FieldCreditAmount)
	}
	if m.multiplier != nil {
		fields = append(fields, rechargeorder.FieldMultiplier)
	}
	if m.status != nil {
		fields = append(fields, rechargeorder.FieldStatus)
	}
	if m.pay_type != nil {
		fields = append(fields, rechargeorder.FieldPayType)
	}
	if m.paid_at != nil {
		fields = append(fields, rechargeorder.FieldPaidAt)
	}
	if m.created_at != nil {
		fields = append(fields, rechargeorder.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, rechargeorder.FieldUpdatedAt)
	}
	if m.expired_at != nil {
		fields = append(fields, rechargeorder.FieldExpiredAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RechargeOrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case rechargeorder.FieldOrderNo:
		return m.OrderNo()
	case rechargeorder.FieldTradeNo:
		return m.TradeNo()
	case rechargeorder.FieldUserID:
		return m.UserID()
	case rechargeorder.FieldAmount:
		return m.Amount()
	case rechargeorder.FieldCreditAmount:
		return m.CreditAmount()
	case rechargeorder.FieldMultiplier:
		return m.Multiplier()
	case rechargeorder.FieldStatus:
		return m.Status()
	case rechargeorder.FieldPayType:
		return m.PayType()
	case rechargeorder.FieldPaidAt:
		return m.PaidAt()
	case rechargeorder.FieldCreatedAt:
		return m.CreatedAt()
	case rechargeorder.FieldUpdatedAt:
		return m.UpdatedAt()
	case rechargeorder.FieldExpiredAt:
		return m.ExpiredAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RechargeOrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case rechargeorder.FieldOrderNo:
		return m.OldOrderNo(ctx)
	case rechargeorder.FieldTradeNo:
		return m.OldTradeNo(ctx)
	case rechargeorder.FieldUserID:
		return m.OldUserID(ctx)
	case rechargeorder.FieldAmount:
		return m.OldAmount(ctx)
	case rechargeorder.FieldCreditAmount:
		return m.OldCreditAmount(ctx)
	case rechargeorder.FieldMultiplier:
		return m.OldMultiplier(ctx)
	case rechargeorder.FieldStatus:
		return m.OldStatus(ctx)
	case rechargeorder.FieldPayType:
		return m.OldPayType(ctx)
	case rechargeorder.FieldPaidAt:
		return m.OldPaidAt(ctx)
	case rechargeorder.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case rechargeorder.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case rechargeorder.FieldExpiredAt:
		return m.OldExpiredAt(ctx)
	}
	return nil, fmt.Errorf("unknown RechargeOrder field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RechargeOrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case rechargeorder.FieldOrderNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderNo(v)
		return nil
	case rechargeorder.FieldTradeNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTradeNo(v)
		return nil
	case rechargeorder.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case rechargeorder.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case rechargeorder.FieldCreditAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreditAmount(v)
		return nil
	case rechargeorder.FieldMultiplier:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMultiplier(v)
		return nil
	case rechargeorder.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case rechargeorder.FieldPayType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayType(v)
		return nil
	case rechargeorder.FieldPaidAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaidAt(v)
		return nil
	case rechargeorder.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case rechargeorder.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case rechargeorder.FieldExpiredAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiredAt(v)
		return nil
	}
	return fmt.Errorf("unknown RechargeOrder field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RechargeOrderMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, rechargeorder.FieldAmount)
	}
	if m.addcredit_amount != nil {
		fields = append(fields, rechargeorder.FieldCreditAmount)
	}
	if m.addmultiplier != nil {
		fields = append(fields, rechargeorder.FieldMultiplier)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RechargeOrderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case rechargeorder.FieldAmount:
		return m.AddedAmount()
	case rechargeorder.FieldCreditAmount:
		return m.AddedCreditAmount()
	case rechargeorder.FieldMultiplier:
		return m.AddedMultiplier()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RechargeOrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case rechargeorder.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case rechargeorder.FieldCreditAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreditAmount(v)
		return nil
	case rechargeorder.FieldMultiplier:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMultiplier(v)
		return nil
	}
	return fmt.Errorf("unknown RechargeOrder numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RechargeOrderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(rechargeorder.FieldTradeNo) {
		fields = append(fields, rechargeorder.FieldTradeNo)
	}
	if m.FieldCleared(rechargeorder.FieldPayType) {
		fields = append(fields, rechargeorder.FieldPayType)
	}
	if m.FieldCleared(rechargeorder.FieldPaidAt) {
		fields = append(fields, rechargeorder.FieldPaidAt)
	}
	if m.FieldCleared(rechargeorder.FieldExpiredAt) {
		fields = append(fields, rechargeorder.FieldExpiredAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RechargeOrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RechargeOrderMutation) ClearField(name string) error {
	switch name {
	case rechargeorder.FieldTradeNo:
		m.ClearTradeNo()
		return nil
	case rechargeorder.FieldPayType:
		m.ClearPayType()
		return nil
	case rechargeorder.FieldPaidAt:
		m.ClearPaidAt()
		return nil
	case rechargeorder.FieldExpiredAt:
		m.ClearExpiredAt()
		return nil
	}
	return fmt.Errorf("unknown RechargeOrder nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RechargeOrderMutation) ResetField(name string) error {
	switch name {
	case rechargeorder.FieldOrderNo:
		m.ResetOrderNo()
		return nil
	case rechargeorder.FieldTradeNo:
		m.ResetTradeNo()
		return nil
	case rechargeorder.FieldUserID:
		m.ResetUserID()
		return nil
	case rechargeorder.FieldAmount:
		m.ResetAmount()
		return nil
	case rechargeorder.FieldCreditAmount:
		m.ResetCreditAmount()
		return nil
	case rechargeorder.FieldMultiplier:
		m.ResetMultiplier()
		return nil
	case rechargeorder.FieldStatus:
		m.ResetStatus()
		return nil
	case rechargeorder.FieldPayType:
		m.ResetPayType()
		return nil
	case rechargeorder.FieldPaidAt:
		m.ResetPaidAt()
		return nil
	case rechargeorder.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case rechargeorder.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case rechargeorder.FieldExpiredAt:
		m.ResetExpiredAt()
		return nil
	}
	return fmt.Errorf("unknown RechargeOrder field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RechargeOrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, rechargeorder.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RechargeOrderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case rechargeorder.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RechargeOrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RechargeOrderMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RechargeOrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, rechargeorder.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RechargeOrderMutation) EdgeCleared(name string) bool {
	switch name {
	case rechargeorder.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RechargeOrderMutation) ClearEdge(name string) error {
	switch name {
	case rechargeorder.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown RechargeOrder unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RechargeOrderMutation) ResetEdge(name string) error {
	switch name {
	case rechargeorder.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown RechargeOrder edge %s", name)
}

// RedeemCodeMutation represents an operation that mutates the RedeemCode nodes in the graph.
type RedeemCodeMutation struct {
	config
	op               Op
	typ              string
	id               *int64
	code             *string
	_type            *string
	value            *float64
	addvalue         *float64
	status           *string
	used_at          *time.Time
	notes            *string
	created_at       *time.Time
	validity_days    *int
	addvalidity_days *int
	owner_id         *int64
	addowner_id      *int64
	clearedFields    map[string]struct{}
	user             *int64
	cleareduser      bool
	group            *int64
	clearedgroup     bool
	done             bool
	oldValue         func(context.Context) (*RedeemCode, error)
	predicates       []predicate.RedeemCode
}

var _ ent.Mutation = (*RedeemCodeMutation)(nil)

// redeemcodeOption allows management of the mutation configuration using functional options.
type redeemcodeOption func(*RedeemCodeMutation)

// newRedeemCodeMutation creates new mutation for the RedeemCode entity.
func newRedeemCodeMutation(c config, op Op, opts ...redeemcodeOption) *RedeemCodeMutation {
	m := &RedeemCodeMutation{
		config:        c,
		op:            op,
		typ:           TypeRedeemCode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRedeemCodeID sets the ID field of the mutation.
func withRedeemCodeID(id int64) redeemcodeOption {
	return func(m *RedeemCodeMutation) {
		var (
			err   error
			once  sync.Once
			value *RedeemCode
		)
		m.oldValue = func(ctx context.Context) (*RedeemCode, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RedeemCode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRedeemCode sets the old RedeemCode of the mutation.
func withRedeemCode(node *RedeemCode) redeemcodeOption {
	return func(m *RedeemCodeMutation) {
		m.oldValue = func(context.Context) (*RedeemCode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RedeemCodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RedeemCodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RedeemCodeMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RedeemCodeMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RedeemCode.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCode sets the "code" field.
func (m *RedeemCodeMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *RedeemCodeMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the RedeemCode entity.
// If the RedeemCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RedeemCodeMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *RedeemCodeMutation) ResetCode() {
	m.code = nil
}

// SetType sets the "type" field.
func (m *RedeemCodeMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *RedeemCodeMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the RedeemCode entity.
// If the RedeemCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RedeemCodeMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *RedeemCodeMutation) ResetType() {
	m._type = nil
}

// SetValue sets the "value" field.
func (m *RedeemCodeMutation) SetValue(f float64) {
	m.value = &f
	m.addvalue = nil
}

// Value returns the value of the "value" field in the mutation.
func (m *RedeemCodeMutation) Value() (r float64, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the RedeemCode entity.
// If the RedeemCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RedeemCodeMutation) OldValue(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// AddValue adds f to the "value" field.
func (m *RedeemCodeMutation) AddValue(f float64) {
	if m.addvalue != nil {
		*m.addvalue += f
	} else {
		m.addvalue = &f
	}
}

// AddedValue returns the value that was added to the "value" field in this mutation.
func (m *RedeemCodeMutation) AddedValue() (r float64, exists bool) {
	v := m.addvalue
	if v == nil {
		return
	}
	return *v, true
}

// ResetValue resets all changes to the "value" field.
func (m *RedeemCodeMutation) ResetValue() {
	m.value = nil
	m.addvalue = nil
}

// SetStatus sets the "status" field.
func (m *RedeemCodeMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *RedeemCodeMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the RedeemCode entity.
// If the RedeemCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RedeemCodeMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *RedeemCodeMutation) ResetStatus() {
	m.status = nil
}

// SetUsedBy sets the "used_by" field.
func (m *RedeemCodeMutation) SetUsedBy(i int64) {
	m.user = &i
}

// UsedBy returns the value of the "used_by" field in the mutation.
func (m *RedeemCodeMutation) UsedBy() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUsedBy returns the old "used_by" field's value of the RedeemCode entity.
// If the RedeemCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RedeemCodeMutation) OldUsedBy(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsedBy: %w", err)
	}
	return oldValue.UsedBy, nil
}

// ClearUsedBy clears the value of the "used_by" field.
func (m *RedeemCodeMutation) ClearUsedBy() {
	m.user = nil
	m.clearedFields[redeemcode.FieldUsedBy] = struct{}{}
}

// UsedByCleared returns if the "used_by" field was cleared in this mutation.
func (m *RedeemCodeMutation) UsedByCleared() bool {
	_, ok := m.clearedFields[redeemcode.FieldUsedBy]
	return ok
}

// ResetUsedBy resets all changes to the "used_by" field.
func (m *RedeemCodeMutation) ResetUsedBy() {
	m.user = nil
	delete(m.clearedFields, redeemcode.FieldUsedBy)
}

// SetUsedAt sets the "used_at" field.
func (m *RedeemCodeMutation) SetUsedAt(t time.Time) {
	m.used_at = &t
}

// UsedAt returns the value of the "used_at" field in the mutation.
func (m *RedeemCodeMutation) UsedAt() (r time.Time, exists bool) {
	v := m.used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUsedAt returns the old "used_at" field's value of the RedeemCode entity.
// If the RedeemCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RedeemCodeMutation) OldUsedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsedAt: %w", err)
	}
	return oldValue.UsedAt, nil
}

// ClearUsedAt clears the value of the "used_at" field.
func (m *RedeemCodeMutation) ClearUsedAt() {
	m.used_at = nil
	m.clearedFields[redeemcode.FieldUsedAt] = struct{}{}
}

// UsedAtCleared returns if the "used_at" field was cleared in this mutation.
func (m *RedeemCodeMutation) UsedAtCleared() bool {
	_, ok := m.clearedFields[redeemcode.FieldUsedAt]
	return ok
}

// ResetUsedAt resets all changes to the "used_at" field.
func (m *RedeemCodeMutation) ResetUsedAt() {
	m.used_at = nil
	delete(m.clearedFields, redeemcode.FieldUsedAt)
}

// SetNotes sets the "notes" field.
func (m *RedeemCodeMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *RedeemCodeMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the RedeemCode entity.
// If the RedeemCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RedeemCodeMutation) OldNotes(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *RedeemCodeMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[redeemcode.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *RedeemCodeMutation) NotesCleared() bool {
	_, ok := m.clearedFields[redeemcode.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *RedeemCodeMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, redeemcode.FieldNotes)
}

// SetCreatedAt sets the "created_at" field.
func (m *RedeemCodeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RedeemCodeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RedeemCode entity.
// If the RedeemCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RedeemCodeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RedeemCodeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetGroupID sets the "group_id" field.
func (m *RedeemCodeMutation) SetGroupID(i int64) {
	m.group = &i
}

// GroupID returns the value of the "group_id" field in the mutation.
func (m *RedeemCodeMutation) GroupID() (r int64, exists bool) {
	v := m.group
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupID returns the old "group_id" field's value of the RedeemCode entity.
// If the RedeemCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RedeemCodeMutation) OldGroupID(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupID: %w", err)
	}
	return oldValue.GroupID, nil
}

// ClearGroupID clears the value of the "group_id" field.
func (m *RedeemCodeMutation) ClearGroupID() {
	m.group = nil
	m.clearedFields[redeemcode.FieldGroupID] = struct{}{}
}

// GroupIDCleared returns if the "group_id" field was cleared in this mutation.
func (m *RedeemCodeMutation) GroupIDCleared() bool {
	_, ok := m.clearedFields[redeemcode.FieldGroupID]
	return ok
}

// ResetGroupID resets all changes to the "group_id" field.
func (m *RedeemCodeMutation) ResetGroupID() {
	m.group = nil
	delete(m.clearedFields, redeemcode.FieldGroupID)
}

// SetValidityDays sets the "validity_days" field.
func (m *RedeemCodeMutation) SetValidityDays(i int) {
	m.validity_days = &i
	m.addvalidity_days = nil
}

// ValidityDays returns the value of the "validity_days" field in the mutation.
func (m *RedeemCodeMutation) ValidityDays() (r int, exists bool) {
	v := m.validity_days
	if v == nil {
		return
	}
	return *v, true
}

// OldValidityDays returns the old "validity_days" field's value of the RedeemCode entity.
// If the RedeemCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RedeemCodeMutation) OldValidityDays(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidityDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidityDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidityDays: %w", err)
	}
	return oldValue.ValidityDays, nil
}

// AddValidityDays adds i to the "validity_days" field.
func (m *RedeemCodeMutation) AddValidityDays(i int) {
	if m.addvalidity_days != nil {
		*m.addvalidity_days += i
	} else {
		m.addvalidity_days = &i
	}
}

// AddedValidityDays returns the value that was added to the "validity_days" field in this mutation.
func (m *RedeemCodeMutation) AddedValidityDays() (r int, exists bool) {
	v := m.addvalidity_days
	if v == nil {
		return
	}
	return *v, true
}

// ResetValidityDays resets all changes to the "validity_days" field.
func (m *RedeemCodeMutation) ResetValidityDays() {
	m.validity_days = nil
	m.addvalidity_days = nil
}

// SetOwnerID sets the "owner_id" field.
func (m *RedeemCodeMutation) SetOwnerID(i int64) {
	m.owner_id = &i
	m.addowner_id = nil
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *RedeemCodeMutation) OwnerID() (r int64, exists bool) {
	v := m.owner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the RedeemCode entity.
// If the RedeemCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RedeemCodeMutation) OldOwnerID(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// AddOwnerID adds i to the "owner_id" field.
func (m *RedeemCodeMutation) AddOwnerID(i int64) {
	if m.addowner_id != nil {
		*m.addowner_id += i
	} else {
		m.addowner_id = &i
	}
}

// AddedOwnerID returns the value that was added to the "owner_id" field in this mutation.
func (m *RedeemCodeMutation) AddedOwnerID() (r int64, exists bool) {
	v := m.addowner_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearOwnerID clears the value of the "owner_id" field.
func (m *RedeemCodeMutation) ClearOwnerID() {
	m.owner_id = nil
	m.addowner_id = nil
	m.clearedFields[redeemcode.FieldOwnerID] = struct{}{}
}

// OwnerIDCleared returns if the "owner_id" field was cleared in this mutation.
func (m *RedeemCodeMutation) OwnerIDCleared() bool {
	_, ok := m.clearedFields[redeemcode.FieldOwnerID]
	return ok
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *RedeemCodeMutation) ResetOwnerID() {
	m.owner_id = nil
	m.addowner_id = nil
	delete(m.clearedFields, redeemcode.FieldOwnerID)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *RedeemCodeMutation) SetUserID(id int64) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *RedeemCodeMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[redeemcode.FieldUsedBy] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *RedeemCodeMutation) UserCleared() bool {
	return m.UsedByCleared() || m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *RedeemCodeMutation) UserID() (id int64, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *RedeemCodeMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *RedeemCodeMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearGroup clears the "group" edge to the Group entity.
func (m *RedeemCodeMutation) ClearGroup() {
	m.clearedgroup = true
	m.clearedFields[redeemcode.FieldGroupID] = struct{}{}
}

// GroupCleared reports if the "group" edge to the Group entity was cleared.
func (m *RedeemCodeMutation) GroupCleared() bool {
	return m.GroupIDCleared() || m.clearedgroup
}

// GroupIDs returns the "group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupID instead. It exists only for internal usage by the builders.
func (m *RedeemCodeMutation) GroupIDs() (ids []int64) {
	if id := m.group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroup resets all changes to the "group" edge.
func (m *RedeemCodeMutation) ResetGroup() {
	m.group = nil
	m.clearedgroup = false
}

// Where appends a list predicates to the RedeemCodeMutation builder.
func (m *RedeemCodeMutation) Where(ps ...predicate.RedeemCode) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RedeemCodeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RedeemCodeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RedeemCode, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RedeemCodeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RedeemCodeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RedeemCode).
func (m *RedeemCodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RedeemCodeMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.code != nil {
		fields = append(fields, redeemcode.FieldCode)
	}
	if m._type != nil {
		fields = append(fields, redeemcode.FieldType)
	}
	if m.value != nil {
		fields = append(fields, redeemcode.FieldValue)
	}
	if m.status != nil {
		fields = append(fields, redeemcode.FieldStatus)
	}
	if m.user != nil {
		fields = append(fields, redeemcode.FieldUsedBy)
	}
	if m.used_at != nil {
		fields = append(fields, redeemcode.FieldUsedAt)
	}
	if m.notes != nil {
		fields = append(fields, redeemcode.FieldNotes)
	}
	if m.created_at != nil {
		fields = append(fields, redeemcode.FieldCreatedAt)
	}
	if m.group != nil {
		fields = append(fields, redeemcode.FieldGroupID)
	}
	if m.validity_days != nil {
		fields = append(fields, redeemcode.FieldValidityDays)
	}
	if m.owner_id != nil {
		fields = append(fields, redeemcode.FieldOwnerID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RedeemCodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case redeemcode.FieldCode:
		return m.Code()
	case redeemcode.FieldType:
		return m.GetType()
	case redeemcode.FieldValue:
		return m.Value()
	case redeemcode.FieldStatus:
		return m.Status()
	case redeemcode.FieldUsedBy:
		return m.UsedBy()
	case redeemcode.FieldUsedAt:
		return m.UsedAt()
	case redeemcode.FieldNotes:
		return m.Notes()
	case redeemcode.FieldCreatedAt:
		return m.CreatedAt()
	case redeemcode.FieldGroupID:
		return m.GroupID()
	case redeemcode.FieldValidityDays:
		return m.ValidityDays()
	case redeemcode.FieldOwnerID:
		return m.OwnerID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RedeemCodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case redeemcode.FieldCode:
		return m.OldCode(ctx)
	case redeemcode.FieldType:
		return m.OldType(ctx)
	case redeemcode.FieldValue:
		return m.OldValue(ctx)
	case redeemcode.FieldStatus:
		return m.OldStatus(ctx)
	case redeemcode.FieldUsedBy:
		return m.OldUsedBy(ctx)
	case redeemcode.FieldUsedAt:
		return m.OldUsedAt(ctx)
	case redeemcode.FieldNotes:
		return m.OldNotes(ctx)
	case redeemcode.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case redeemcode.FieldGroupID:
		return m.OldGroupID(ctx)
	case redeemcode.FieldValidityDays:
		return m.OldValidityDays(ctx)
	case redeemcode.FieldOwnerID:
		return m.OldOwnerID(ctx)
	}
	return nil, fmt.Errorf("unknown RedeemCode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RedeemCodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case redeemcode.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case redeemcode.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case redeemcode.FieldValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case redeemcode.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case redeemcode.FieldUsedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsedBy(v)
		return nil
	case redeemcode.FieldUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsedAt(v)
		return nil
	case redeemcode.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	case redeemcode.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case redeemcode.FieldGroupID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupID(v)
		return nil
	case redeemcode.FieldValidityDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidityDays(v)
		return nil
	case redeemcode.FieldOwnerID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	}
	return fmt.Errorf("unknown RedeemCode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RedeemCodeMutation) AddedFields() []string {
	var fields []string
	if m.addvalue != nil {
		fields = append(fields, redeemcode.FieldValue)
	}
	if m.addvalidity_days != nil {
		fields = append(fields, redeemcode.FieldValidityDays)
	}
	if m.addowner_id != nil {
		fields = append(fields, redeemcode.FieldOwnerID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RedeemCodeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case redeemcode.FieldValue:
		return m.AddedValue()
	case redeemcode.FieldValidityDays:
		return m.AddedValidityDays()
	case redeemcode.FieldOwnerID:
		return m.AddedOwnerID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RedeemCodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case redeemcode.FieldValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValue(v)
		return nil
	case redeemcode.FieldValidityDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValidityDays(v)
		return nil
	case redeemcode.FieldOwnerID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOwnerID(v)
		return nil
	}
	return fmt.Errorf("unknown RedeemCode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RedeemCodeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(redeemcode.FieldUsedBy) {
		fields = append(fields, redeemcode.FieldUsedBy)
	}
	if m.FieldCleared(redeemcode.FieldUsedAt) {
		fields = append(fields, redeemcode.FieldUsedAt)
	}
	if m.FieldCleared(redeemcode.FieldNotes) {
		fields = append(fields, redeemcode.FieldNotes)
	}
	if m.FieldCleared(redeemcode.FieldGroupID) {
		fields = append(fields, redeemcode.FieldGroupID)
	}
	if m.FieldCleared(redeemcode.FieldOwnerID) {
		fields = append(fields, redeemcode.FieldOwnerID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RedeemCodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RedeemCodeMutation) ClearField(name string) error {
	switch name {
	case redeemcode.FieldUsedBy:
		m.ClearUsedBy()
		return nil
	case redeemcode.FieldUsedAt:
		m.ClearUsedAt()
		return nil
	case redeemcode.FieldNotes:
		m.ClearNotes()
		return nil
	case redeemcode.FieldGroupID:
		m.ClearGroupID()
		return nil
	case redeemcode.FieldOwnerID:
		m.ClearOwnerID()
		return nil
	}
	return fmt.Errorf("unknown RedeemCode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RedeemCodeMutation) ResetField(name string) error {
	switch name {
	case redeemcode.FieldCode:
		m.ResetCode()
		return nil
	case redeemcode.FieldType:
		m.ResetType()
		return nil
	case redeemcode.FieldValue:
		m.ResetValue()
		return nil
	case redeemcode.FieldStatus:
		m.ResetStatus()
		return nil
	case redeemcode.FieldUsedBy:
		m.ResetUsedBy()
		return nil
	case redeemcode.FieldUsedAt:
		m.ResetUsedAt()
		return nil
	case redeemcode.FieldNotes:
		m.ResetNotes()
		return nil
	case redeemcode.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case redeemcode.FieldGroupID:
		m.ResetGroupID()
		return nil
	case redeemcode.FieldValidityDays:
		m.ResetValidityDays()
		return nil
	case redeemcode.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	}
	return fmt.Errorf("unknown RedeemCode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RedeemCodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, redeemcode.EdgeUser)
	}
	if m.group != nil {
		edges = append(edges, redeemcode.EdgeGroup)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RedeemCodeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case redeemcode.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case redeemcode.EdgeGroup:
		if id := m.group; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RedeemCodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RedeemCodeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RedeemCodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, redeemcode.EdgeUser)
	}
	if m.clearedgroup {
		edges = append(edges, redeemcode.EdgeGroup)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RedeemCodeMutation) EdgeCleared(name string) bool {
	switch name {
	case redeemcode.EdgeUser:
		return m.cleareduser
	case redeemcode.EdgeGroup:
		return m.clearedgroup
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RedeemCodeMutation) ClearEdge(name string) error {
	switch name {
	case redeemcode.EdgeUser:
		m.ClearUser()
		return nil
	case redeemcode.EdgeGroup:
		m.ClearGroup()
		return nil
	}
	return fmt.Errorf("unknown RedeemCode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RedeemCodeMutation) ResetEdge(name string) error {
	switch name {
	case redeemcode.EdgeUser:
		m.ResetUser()
		return nil
	case redeemcode.EdgeGroup:
		m.ResetGroup()
		return nil
	}
	return fmt.Errorf("unknown RedeemCode edge %s", name)
}

// ReferralRewardMutation represents an operation that mutates the ReferralReward nodes in the graph.
type ReferralRewardMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int64
	created_at           *time.Time
	updated_at           *time.Time
	referrer_reward      *float64
	addreferrer_reward   *float64
	invitee_reward       *float64
	addinvitee_reward    *float64
	skip_referrer_reason *string
	clearedFields        map[string]struct{}
	referrer             *int64
	clearedreferrer      bool
	invitee              *int64
	clearedinvitee       bool
	trigger_order        *int64
	clearedtrigger_order bool
	done                 bool
	oldValue             func(context.Context) (*ReferralReward, error)
	predicates           []predicate.ReferralReward
}

var _ ent.Mutation = (*ReferralRewardMutation)(nil)

// referralrewardOption allows management of the mutation configuration using functional options.
type referralrewardOption func(*ReferralRewardMutation)

// newReferralRewardMutation creates new mutation for the ReferralReward entity.
func newReferralRewardMutation(c config, op Op, opts ...referralrewardOption) *ReferralRewardMutation {
	m := &ReferralRewardMutation{
		config:        c,
		op:            op,
		typ:           TypeReferralReward,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReferralRewardID sets the ID field of the mutation.
func withReferralRewardID(id int64) referralrewardOption {
	return func(m *ReferralRewardMutation) {
		var (
			err   error
			once  sync.Once
			value *ReferralReward
		)
		m.oldValue = func(ctx context.Context) (*ReferralReward, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ReferralReward.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReferralReward sets the old ReferralReward of the mutation.
func withReferralReward(node *ReferralReward) referralrewardOption {
	return func(m *ReferralRewardMutation) {
		m.oldValue = func(context.Context) (*ReferralReward, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReferralRewardMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReferralRewardMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReferralRewardMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReferralRewardMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ReferralReward.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ReferralRewardMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ReferralRewardMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ReferralReward entity.
// If the ReferralReward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReferralRewardMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ReferralRewardMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ReferralRewardMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ReferralRewardMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ReferralReward entity.
// If the ReferralReward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReferralRewardMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ReferralRewardMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetReferrerID sets the "referrer_id" field.
func (m *ReferralRewardMutation) SetReferrerID(i int64) {
	m.referrer = &i
}

// ReferrerID returns the value of the "referrer_id" field in the mutation.
func (m *ReferralRewardMutation) ReferrerID() (r int64, exists bool) {
	v := m.referrer
	if v == nil {
		return
	}
	return *v, true
}

// OldReferrerID returns the old "referrer_id" field's value of the ReferralReward entity.
// If the ReferralReward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReferralRewardMutation) OldReferrerID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferrerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferrerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferrerID: %w", err)
	}
	return oldValue.ReferrerID, nil
}

// ResetReferrerID resets all changes to the "referrer_id" field.
func (m *ReferralRewardMutation) ResetReferrerID() {
	m.referrer = nil
}

// SetInviteeID sets the "invitee_id" field.
func (m *ReferralRewardMutation) SetInviteeID(i int64) {
	m.invitee = &i
}

// InviteeID returns the value of the "invitee_id" field in the mutation.
func (m *ReferralRewardMutation) InviteeID() (r int64, exists bool) {
	v := m.invitee
	if v == nil {
		return
	}
	return *v, true
}

// OldInviteeID returns the old "invitee_id" field's value of the ReferralReward entity.
// If the ReferralReward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReferralRewardMutation) OldInviteeID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInviteeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInviteeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInviteeID: %w", err)
	}
	return oldValue.InviteeID, nil
}

// ResetInviteeID resets all changes to the "invitee_id" field.
func (m *ReferralRewardMutation) ResetInviteeID() {
	m.invitee = nil
}

// SetTriggerOrderID sets the "trigger_order_id" field.
func (m *ReferralRewardMutation) SetTriggerOrderID(i int64) {
	m.trigger_order = &i
}

// TriggerOrderID returns the value of the "trigger_order_id" field in the mutation.
func (m *ReferralRewardMutation) TriggerOrderID() (r int64, exists bool) {
	v := m.trigger_order
	if v == nil {
		return
	}
	return *v, true
}

// OldTriggerOrderID returns the old "trigger_order_id" field's value of the ReferralReward entity.
// If the ReferralReward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReferralRewardMutation) OldTriggerOrderID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTriggerOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTriggerOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTriggerOrderID: %w", err)
	}
	return oldValue.TriggerOrderID, nil
}

// ResetTriggerOrderID resets all changes to the "trigger_order_id" field.
func (m *ReferralRewardMutation) ResetTriggerOrderID() {
	m.trigger_order = nil
}

// SetReferrerReward sets the "referrer_reward" field.
func (m *ReferralRewardMutation) SetReferrerReward(f float64) {
	m.referrer_reward = &f
	m.addreferrer_reward = nil
}

// ReferrerReward returns the value of the "referrer_reward" field in the mutation.
func (m *ReferralRewardMutation) ReferrerReward() (r float64, exists bool) {
	v := m.referrer_reward
	if v == nil {
		return
	}
	return *v, true
}

// OldReferrerReward returns the old "referrer_reward" field's value of the ReferralReward entity.
// If the ReferralReward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReferralRewardMutation) OldReferrerReward(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferrerReward is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferrerReward requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferrerReward: %w", err)
	}
	return oldValue.ReferrerReward, nil
}

// AddReferrerReward adds f to the "referrer_reward" field.
func (m *ReferralRewardMutation) AddReferrerReward(f float64) {
	if m.addreferrer_reward != nil {
		*m.addreferrer_reward += f
	} else {
		m.addreferrer_reward = &f
	}
}

// AddedReferrerReward returns the value that was added to the "referrer_reward" field in this mutation.
func (m *ReferralRewardMutation) AddedReferrerReward() (r float64, exists bool) {
	v := m.addreferrer_reward
	if v == nil {
		return
	}
	return *v, true
}

// ResetReferrerReward resets all changes to the "referrer_reward" field.
func (m *ReferralRewardMutation) ResetReferrerReward() {
	m.referrer_reward = nil
	m.addreferrer_reward = nil
}

// SetInviteeReward sets the "invitee_reward" field.
func (m *ReferralRewardMutation) SetInviteeReward(f float64) {
	m.invitee_reward = &f
	m.addinvitee_reward = nil
}

// InviteeReward returns the value of the "invitee_reward" field in the mutation.
func (m *ReferralRewardMutation) InviteeReward() (r float64, exists bool) {
	v := m.invitee_reward
	if v == nil {
		return
	}
	return *v, true
}

// OldInviteeReward returns the old "invitee_reward" field's value of the ReferralReward entity.
// If the ReferralReward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReferralRewardMutation) OldInviteeReward(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInviteeReward is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInviteeReward requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInviteeReward: %w", err)
	}
	return oldValue.InviteeReward, nil
}

// AddInviteeReward adds f to the "invitee_reward" field.
func (m *ReferralRewardMutation) AddInviteeReward(f float64) {
	if m.addinvitee_reward != nil {
		*m.addinvitee_reward += f
	} else {
		m.addinvitee_reward = &f
	}
}

// AddedInviteeReward returns the value that was added to the "invitee_reward" field in this mutation.
func (m *ReferralRewardMutation) AddedInviteeReward() (r float64, exists bool) {
	v := m.addinvitee_reward
	if v == nil {
		return
	}
	return *v, true
}

// ResetInviteeReward resets all changes to the "invitee_reward" field.
func (m *ReferralRewardMutation) ResetInviteeReward() {
	m.invitee_reward = nil
	m.addinvitee_reward = nil
}

// SetSkipReferrerReason sets the "skip_referrer_reason" field.
func (m *ReferralRewardMutation) SetSkipReferrerReason(s string) {
	m.skip_referrer_reason = &s
}

// SkipReferrerReason returns the value of the "skip_referrer_reason" field in the mutation.
func (m *ReferralRewardMutation) SkipReferrerReason() (r string, exists bool) {
	v := m.skip_referrer_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldSkipReferrerReason returns the old "skip_referrer_reason" field's value of the ReferralReward entity.
// If the ReferralReward object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReferralRewardMutation) OldSkipReferrerReason(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSkipReferrerReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSkipReferrerReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkipReferrerReason: %w", err)
	}
	return oldValue.SkipReferrerReason, nil
}

// ClearSkipReferrerReason clears the value of the "skip_referrer_reason" field.
func (m *ReferralRewardMutation) ClearSkipReferrerReason() {
	m.skip_referrer_reason = nil
	m.clearedFields[referralreward.FieldSkipReferrerReason] = struct{}{}
}

// SkipReferrerReasonCleared returns if the "skip_referrer_reason" field was cleared in this mutation.
func (m *ReferralRewardMutation) SkipReferrerReasonCleared() bool {
	_, ok := m.clearedFields[referralreward.FieldSkipReferrerReason]
	return ok
}

// ResetSkipReferrerReason resets all changes to the "skip_referrer_reason" field.
func (m *ReferralRewardMutation) ResetSkipReferrerReason() {
	m.skip_referrer_reason = nil
	delete(m.clearedFields, referralreward.FieldSkipReferrerReason)
}

// ClearReferrer clears the "referrer" edge to the User entity.
func (m *ReferralRewardMutation) ClearReferrer() {
	m.clearedreferrer = true
	m.clearedFields[referralreward.FieldReferrerID] = struct{}{}
}

// ReferrerCleared reports if the "referrer" edge to the User entity was cleared.
func (m *ReferralRewardMutation) ReferrerCleared() bool {
	return m.clearedreferrer
}

// ReferrerIDs returns the "referrer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReferrerID instead. It exists only for internal usage by the builders.
func (m *ReferralRewardMutation) ReferrerIDs() (ids []int64) {
	if id := m.referrer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReferrer resets all changes to the "referrer" edge.
func (m *ReferralRewardMutation) ResetReferrer() {
	m.referrer = nil
	m.clearedreferrer = false
}

// ClearInvitee clears the "invitee" edge to the User entity.
func (m *ReferralRewardMutation) ClearInvitee() {
	m.clearedinvitee = true
	m.clearedFields[referralreward.FieldInviteeID] = struct{}{}
}

// InviteeCleared reports if the "invitee" edge to the User entity was cleared.
func (m *ReferralRewardMutation) InviteeCleared() bool {
	return m.clearedinvitee
}

// InviteeIDs returns the "invitee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InviteeID instead. It exists only for internal usage by the builders.
func (m *ReferralRewardMutation) InviteeIDs() (ids []int64) {
	if id := m.invitee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInvitee resets all changes to the "invitee" edge.
func (m *ReferralRewardMutation) ResetInvitee() {
	m.invitee = nil
	m.clearedinvitee = false
}

// ClearTriggerOrder clears the "trigger_order" edge to the Order entity.
func (m *ReferralRewardMutation) ClearTriggerOrder() {
	m.clearedtrigger_order = true
	m.clearedFields[referralreward.FieldTriggerOrderID] = struct{}{}
}

// TriggerOrderCleared reports if the "trigger_order" edge to the Order entity was cleared.
func (m *ReferralRewardMutation) TriggerOrderCleared() bool {
	return m.clearedtrigger_order
}

// TriggerOrderIDs returns the "trigger_order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TriggerOrderID instead. It exists only for internal usage by the builders.
func (m *ReferralRewardMutation) TriggerOrderIDs() (ids []int64) {
	if id := m.trigger_order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTriggerOrder resets all changes to the "trigger_order" edge.
func (m *ReferralRewardMutation) ResetTriggerOrder() {
	m.trigger_order = nil
	m.clearedtrigger_order = false
}

// Where appends a list predicates to the ReferralRewardMutation builder.
func (m *ReferralRewardMutation) Where(ps ...predicate.ReferralReward) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ReferralRewardMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ReferralRewardMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ReferralReward, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ReferralRewardMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ReferralRewardMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ReferralReward).
func (m *ReferralRewardMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReferralRewardMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, referralreward.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, referralreward.FieldUpdatedAt)
	}
	if m.referrer != nil {
		fields = append(fields, referralreward.FieldReferrerID)
	}
	if m.invitee != nil {
		fields = append(fields, referralreward.FieldInviteeID)
	}
	if m.trigger_order != nil {
		fields = append(fields, referralreward.FieldTriggerOrderID)
	}
	if m.referrer_reward != nil {
		fields = append(fields, referralreward.FieldReferrerReward)
	}
	if m.invitee_reward != nil {
		fields = append(fields, referralreward.FieldInviteeReward)
	}
	if m.skip_referrer_reason != nil {
		fields = append(fields, referralreward.FieldSkipReferrerReason)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReferralRewardMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case referralreward.FieldCreatedAt:
		return m.CreatedAt()
	case referralreward.FieldUpdatedAt:
		return m.UpdatedAt()
	case referralreward.FieldReferrerID:
		return m.ReferrerID()
	case referralreward.FieldInviteeID:
		return m.InviteeID()
	case referralreward.FieldTriggerOrderID:
		return m.TriggerOrderID()
	case referralreward.FieldReferrerReward:
		return m.ReferrerReward()
	case referralreward.FieldInviteeReward:
		return m.InviteeReward()
	case referralreward.FieldSkipReferrerReason:
		return m.SkipReferrerReason()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReferralRewardMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case referralreward.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case referralreward.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case referralreward.FieldReferrerID:
		return m.OldReferrerID(ctx)
	case referralreward.FieldInviteeID:
		return m.OldInviteeID(ctx)
	case referralreward.FieldTriggerOrderID:
		return m.OldTriggerOrderID(ctx)
	case referralreward.FieldReferrerReward:
		return m.OldReferrerReward(ctx)
	case referralreward.FieldInviteeReward:
		return m.OldInviteeReward(ctx)
	case referralreward.FieldSkipReferrerReason:
		return m.OldSkipReferrerReason(ctx)
	}
	return nil, fmt.Errorf("unknown ReferralReward field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReferralRewardMutation) SetField(name string, value ent.Value) error {
	switch name {
	case referralreward.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case referralreward.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case referralreward.FieldReferrerID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferrerID(v)
		return nil
	case referralreward.FieldInviteeID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInviteeID(v)
		return nil
	case referralreward.FieldTriggerOrderID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTriggerOrderID(v)
		return nil
	case referralreward.FieldReferrerReward:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferrerReward(v)
		return nil
	case referralreward.FieldInviteeReward:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInviteeReward(v)
		return nil
	case referralreward.FieldSkipReferrerReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkipReferrerReason(v)
		return nil
	}
	return fmt.Errorf("unknown ReferralReward field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReferralRewardMutation) AddedFields() []string {
	var fields []string
	if m.addreferrer_reward != nil {
		fields = append(fields, referralreward.FieldReferrerReward)
	}
	if m.addinvitee_reward != nil {
		fields = append(fields, referralreward.FieldInviteeReward)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReferralRewardMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case referralreward.FieldReferrerReward:
		return m.AddedReferrerReward()
	case referralreward.FieldInviteeReward:
		return m.AddedInviteeReward()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReferralRewardMutation) AddField(name string, value ent.Value) error {
	switch name {
	case referralreward.FieldReferrerReward:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReferrerReward(v)
		return nil
	case referralreward.FieldInviteeReward:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInviteeReward(v)
		return nil
	}
	return fmt.Errorf("unknown ReferralReward numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReferralRewardMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(referralreward.FieldSkipReferrerReason) {
		fields = append(fields, referralreward.FieldSkipReferrerReason)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReferralRewardMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReferralRewardMutation) ClearField(name string) error {
	switch name {
	case referralreward.FieldSkipReferrerReason:
		m.ClearSkipReferrerReason()
		return nil
	}
	return fmt.Errorf("unknown ReferralReward nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReferralRewardMutation) ResetField(name string) error {
	switch name {
	case referralreward.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case referralreward.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case referralreward.FieldReferrerID:
		m.ResetReferrerID()
		return nil
	case referralreward.FieldInviteeID:
		m.ResetInviteeID()
		return nil
	case referralreward.FieldTriggerOrderID:
		m.ResetTriggerOrderID()
		return nil
	case referralreward.FieldReferrerReward:
		m.ResetReferrerReward()
		return nil
	case referralreward.FieldInviteeReward:
		m.ResetInviteeReward()
		return nil
	case referralreward.FieldSkipReferrerReason:
		m.ResetSkipReferrerReason()
		return nil
	}
	return fmt.Errorf("unknown ReferralReward field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReferralRewardMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.referrer != nil {
		edges = append(edges, referralreward.EdgeReferrer)
	}
	if m.invitee != nil {
		edges = append(edges, referralreward.EdgeInvitee)
	}
	if m.trigger_order != nil {
		edges = append(edges, referralreward.EdgeTriggerOrder)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReferralRewardMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case referralreward.EdgeReferrer:
		if id := m.referrer; id != nil {
			return []ent.Value{*id}
		}
	case referralreward.EdgeInvitee:
		if id := m.invitee; id != nil {
			return []ent.Value{*id}
		}
	case referralreward.EdgeTriggerOrder:
		if id := m.trigger_order; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReferralRewardMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReferralRewardMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReferralRewardMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedreferrer {
		edges = append(edges, referralreward.EdgeReferrer)
	}
	if m.clearedinvitee {
		edges = append(edges, referralreward.EdgeInvitee)
	}
	if m.clearedtrigger_order {
		edges = append(edges, referralreward.EdgeTriggerOrder)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReferralRewardMutation) EdgeCleared(name string) bool {
	switch name {
	case referralreward.EdgeReferrer:
		return m.clearedreferrer
	case referralreward.EdgeInvitee:
		return m.clearedinvitee
	case referralreward.EdgeTriggerOrder:
		return m.clearedtrigger_order
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReferralRewardMutation) ClearEdge(name string) error {
	switch name {
	case referralreward.EdgeReferrer:
		m.ClearReferrer()
		return nil
	case referralreward.EdgeInvitee:
		m.ClearInvitee()
		return nil
	case referralreward.EdgeTriggerOrder:
		m.ClearTriggerOrder()
		return nil
	}
	return fmt.Errorf("unknown ReferralReward unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReferralRewardMutation) ResetEdge(name string) error {
	switch name {
	case referralreward.EdgeReferrer:
		m.ResetReferrer()
		return nil
	case referralreward.EdgeInvitee:
		m.ResetInvitee()
		return nil
	case referralreward.EdgeTriggerOrder:
		m.ResetTriggerOrder()
		return nil
	}
	return fmt.Errorf("unknown ReferralReward edge %s", name)
}

// ResellerDomainMutation represents an operation that mutates the ResellerDomain nodes in the graph.
type ResellerDomainMutation struct {
	config
	op               Op
	typ              string
	id               *int64
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	domain           *string
	site_name        *string
	site_logo        *string
	brand_color      *string
	custom_css       *string
	subtitle         *string
	home_content     *string
	home_template    *string
	doc_url          *string
	purchase_enabled *bool
	purchase_url     *string
	default_locale   *string
	seo_title        *string
	seo_description  *string
	seo_keywords     *string
	login_redirect   *string
	verify_token     *string
	verified         *bool
	verified_at      *time.Time
	clearedFields    map[string]struct{}
	reseller         *int64
	clearedreseller  bool
	done             bool
	oldValue         func(context.Context) (*ResellerDomain, error)
	predicates       []predicate.ResellerDomain
}

var _ ent.Mutation = (*ResellerDomainMutation)(nil)

// resellerdomainOption allows management of the mutation configuration using functional options.
type resellerdomainOption func(*ResellerDomainMutation)

// newResellerDomainMutation creates new mutation for the ResellerDomain entity.
func newResellerDomainMutation(c config, op Op, opts ...resellerdomainOption) *ResellerDomainMutation {
	m := &ResellerDomainMutation{
		config:        c,
		op:            op,
		typ:           TypeResellerDomain,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResellerDomainID sets the ID field of the mutation.
func withResellerDomainID(id int64) resellerdomainOption {
	return func(m *ResellerDomainMutation) {
		var (
			err   error
			once  sync.Once
			value *ResellerDomain
		)
		m.oldValue = func(ctx context.Context) (*ResellerDomain, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ResellerDomain.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResellerDomain sets the old ResellerDomain of the mutation.
func withResellerDomain(node *ResellerDomain) resellerdomainOption {
	return func(m *ResellerDomainMutation) {
		m.oldValue = func(context.Context) (*ResellerDomain, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResellerDomainMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResellerDomainMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ResellerDomainMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ResellerDomainMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ResellerDomain.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ResellerDomainMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ResellerDomainMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ResellerDomain entity.
// If the ResellerDomain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResellerDomainMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ResellerDomainMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ResellerDomainMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ResellerDomainMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ResellerDomain entity.
// If the ResellerDomain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResellerDomainMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ResellerDomainMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ResellerDomainMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ResellerDomainMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the ResellerDomain entity.
// If the ResellerDomain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResellerDomainMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ResellerDomainMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[resellerdomain.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ResellerDomainMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[resellerdomain.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ResellerDomainMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, resellerdomain.FieldDeletedAt)
}

// SetResellerID sets the "reseller_id" field.
func (m *ResellerDomainMutation) SetResellerID(i int64) {
	m.reseller = &i
}

// ResellerID returns the value of the "reseller_id" field in the mutation.
func (m *ResellerDomainMutation) ResellerID() (r int64, exists bool) {
	v := m.reseller
	if v == nil {
		return
	}
	return *v, true
}

// OldResellerID returns the old "reseller_id" field's value of the ResellerDomain entity.
// If the ResellerDomain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResellerDomainMutation) OldResellerID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResellerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResellerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResellerID: %w", err)
	}
	return oldValue.ResellerID, nil
}

// ResetResellerID resets all changes to the "reseller_id" field.
func (m *ResellerDomainMutation) ResetResellerID() {
	m.reseller = nil
}

// SetDomain sets the "domain" field.
func (m *ResellerDomainMutation) SetDomain(s string) {
	m.domain = &s
}

// Domain returns the value of the "domain" field in the mutation.
func (m *ResellerDomainMutation) Domain() (r string, exists bool) {
	v := m.domain
	if v == nil {
		return
	}
	return *v, true
}

// OldDomain returns the old "domain" field's value of the ResellerDomain entity.
// If the ResellerDomain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResellerDomainMutation) OldDomain(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDomain is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDomain requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDomain: %w", err)
	}
	return oldValue.Domain, nil
}

// ResetDomain resets all changes to the "domain" field.
func (m *ResellerDomainMutation) ResetDomain() {
	m.domain = nil
}

// SetSiteName sets the "site_name" field.
func (m *ResellerDomainMutation) SetSiteName(s string) {
	m.site_name = &s
}

// SiteName returns the value of the "site_name" field in the mutation.
func (m *ResellerDomainMutation) SiteName() (r string, exists bool) {
	v := m.site_name
	if v == nil {
		return
	}
	return *v, true
}

// OldSiteName returns the old "site_name" field's value of the ResellerDomain entity.
// If the ResellerDomain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResellerDomainMutation) OldSiteName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSiteName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSiteName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSiteName: %w", err)
	}
	return oldValue.SiteName, nil
}

// ResetSiteName resets all changes to the "site_name" field.
func (m *ResellerDomainMutation) ResetSiteName() {
	m.site_name = nil
}

// SetSiteLogo sets the "site_logo" field.
func (m *ResellerDomainMutation) SetSiteLogo(s string) {
	m.site_logo = &s
}

// SiteLogo returns the value of the "site_logo" field in the mutation.
func (m *ResellerDomainMutation) SiteLogo() (r string, exists bool) {
	v := m.site_logo
	if v == nil {
		return
	}
	return *v, true
}

// OldSiteLogo returns the old "site_logo" field's value of the ResellerDomain entity.
// If the ResellerDomain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResellerDomainMutation) OldSiteLogo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSiteLogo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSiteLogo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSiteLogo: %w", err)
	}
	return oldValue.SiteLogo, nil
}

// ResetSiteLogo resets all changes to the "site_logo" field.
func (m *ResellerDomainMutation) ResetSiteLogo() {
	m.site_logo = nil
}

// SetBrandColor sets the "brand_color" field.
func (m *ResellerDomainMutation) SetBrandColor(s string) {
	m.brand_color = &s
}

// BrandColor returns the value of the "brand_color" field in the mutation.
func (m *ResellerDomainMutation) BrandColor() (r string, exists bool) {
	v := m.brand_color
	if v == nil {
		return
	}
	return *v, true
}

// OldBrandColor returns the old "brand_color" field's value of the ResellerDomain entity.
// If the ResellerDomain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResellerDomainMutation) OldBrandColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBrandColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBrandColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrandColor: %w", err)
	}
	return oldValue.BrandColor, nil
}

// ResetBrandColor resets all changes to the "brand_color" field.
func (m *ResellerDomainMutation) ResetBrandColor() {
	m.brand_color = nil
}

// SetCustomCSS sets the "custom_css" field.
func (m *ResellerDomainMutation) SetCustomCSS(s string) {
	m.custom_css = &s
}

// CustomCSS returns the value of the "custom_css" field in the mutation.
func (m *ResellerDomainMutation) CustomCSS() (r string, exists bool) {
	v := m.custom_css
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomCSS returns the old "custom_css" field's value of the ResellerDomain entity.
// If the ResellerDomain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResellerDomainMutation) OldCustomCSS(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomCSS is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomCSS requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomCSS: %w", err)
	}
	return oldValue.CustomCSS, nil
}

// ResetCustomCSS resets all changes to the "custom_css" field.
func (m *ResellerDomainMutation) ResetCustomCSS() {
	m.custom_css = nil
}

// SetSubtitle sets the "subtitle" field.
func (m *ResellerDomainMutation) SetSubtitle(s string) {
	m.subtitle = &s
}

// Subtitle returns the value of the "subtitle" field in the mutation.
func (m *ResellerDomainMutation) Subtitle() (r string, exists bool) {
	v := m.subtitle
	if v == nil {
		return
	}
	return *v, true
}

// OldSubtitle returns the old "subtitle" field's value of the ResellerDomain entity.
// If the ResellerDomain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResellerDomainMutation) OldSubtitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubtitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubtitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubtitle: %w", err)
	}
	return oldValue.Subtitle, nil
}

// ResetSubtitle resets all changes to the "subtitle" field.
func (m *ResellerDomainMutation) ResetSubtitle() {
	m.subtitle = nil
}

// SetHomeContent sets the "home_content" field.
func (m *ResellerDomainMutation) SetHomeContent(s string) {
	m.home_content = &s
}

// HomeContent returns the value of the "home_content" field in the mutation.
func (m *ResellerDomainMutation) HomeContent() (r string, exists bool) {
	v := m.home_content
	if v == nil {
		return
	}
	return *v, true
}

// OldHomeContent returns the old "home_content" field's value of the ResellerDomain entity.
// If the ResellerDomain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResellerDomainMutation) OldHomeContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHomeContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHomeContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHomeContent: %w", err)
	}
	return oldValue.HomeContent, nil
}

// ResetHomeContent resets all changes to the "home_content" field.
func (m *ResellerDomainMutation) ResetHomeContent() {
	m.home_content = nil
}

// SetHomeTemplate sets the "home_template" field.
func (m *ResellerDomainMutation) SetHomeTemplate(s string) {
	m.home_template = &s
}

// HomeTemplate returns the value of the "home_template" field in the mutation.
func (m *ResellerDomainMutation) HomeTemplate() (r string, exists bool) {
	v := m.home_template
	if v == nil {
		return
	}
	return *v, true
}

// OldHomeTemplate returns the old "home_template" field's value of the ResellerDomain entity.
// If the ResellerDomain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResellerDomainMutation) OldHomeTemplate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHomeTemplate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHomeTemplate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHomeTemplate: %w", err)
	}
	return oldValue.HomeTemplate, nil
}

// ResetHomeTemplate resets all changes to the "home_template" field.
func (m *ResellerDomainMutation) ResetHomeTemplate() {
	m.home_template = nil
}

// SetDocURL sets the "doc_url" field.
func (m *ResellerDomainMutation) SetDocURL(s string) {
	m.doc_url = &s
}

// DocURL returns the value of the "doc_url" field in the mutation.
func (m *ResellerDomainMutation) DocURL() (r string, exists bool) {
	v := m.doc_url
	if v == nil {
		return
	}
	return *v, true
}

// OldDocURL returns the old "doc_url" field's value of the ResellerDomain entity.
// If the ResellerDomain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResellerDomainMutation) OldDocURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDocURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDocURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDocURL: %w", err)
	}
	return oldValue.DocURL, nil
}

// ResetDocURL resets all changes to the "doc_url" field.
func (m *ResellerDomainMutation) ResetDocURL() {
	m.doc_url = nil
}

// SetPurchaseEnabled sets the "purchase_enabled" field.
func (m *ResellerDomainMutation) SetPurchaseEnabled(b bool) {
	m.purchase_enabled = &b
}

// PurchaseEnabled returns the value of the "purchase_enabled" field in the mutation.
func (m *ResellerDomainMutation) PurchaseEnabled() (r bool, exists bool) {
	v := m.purchase_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldPurchaseEnabled returns the old "purchase_enabled" field's value of the ResellerDomain entity.
// If the ResellerDomain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResellerDomainMutation) OldPurchaseEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPurchaseEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPurchaseEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPurchaseEnabled: %w", err)
	}
	return oldValue.PurchaseEnabled, nil
}

// ResetPurchaseEnabled resets all changes to the "purchase_enabled" field.
func (m *ResellerDomainMutation) ResetPurchaseEnabled() {
	m.purchase_enabled = nil
}

// SetPurchaseURL sets the "purchase_url" field.
func (m *ResellerDomainMutation) SetPurchaseURL(s string) {
	m.purchase_url = &s
}

// PurchaseURL returns the value of the "purchase_url" field in the mutation.
func (m *ResellerDomainMutation) PurchaseURL() (r string, exists bool) {
	v := m.purchase_url
	if v == nil {
		return
	}
	return *v, true
}

// OldPurchaseURL returns the old "purchase_url" field's value of the ResellerDomain entity.
// If the ResellerDomain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResellerDomainMutation) OldPurchaseURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPurchaseURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPurchaseURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPurchaseURL: %w", err)
	}
	return oldValue.PurchaseURL, nil
}

// ResetPurchaseURL resets all changes to the "purchase_url" field.
func (m *ResellerDomainMutation) ResetPurchaseURL() {
	m.purchase_url = nil
}

// SetDefaultLocale sets the "default_locale" field.
func (m *ResellerDomainMutation) SetDefaultLocale(s string) {
	m.default_locale = &s
}

// DefaultLocale returns the value of the "default_locale" field in the mutation.
func (m *ResellerDomainMutation) DefaultLocale() (r string, exists bool) {
	v := m.default_locale
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultLocale returns the old "default_locale" field's value of the ResellerDomain entity.
// If the ResellerDomain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResellerDomainMutation) OldDefaultLocale(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultLocale is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultLocale requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultLocale: %w", err)
	}
	return oldValue.DefaultLocale, nil
}

// ResetDefaultLocale resets all changes to the "default_locale" field.
func (m *ResellerDomainMutation) ResetDefaultLocale() {
	m.default_locale = nil
}

// SetSeoTitle sets the "seo_title" field.
func (m *ResellerDomainMutation) SetSeoTitle(s string) {
	m.seo_title = &s
}

// SeoTitle returns the value of the "seo_title" field in the mutation.
func (m *ResellerDomainMutation) SeoTitle() (r string, exists bool) {
	v := m.seo_title
	if v == nil {
		return
	}
	return *v, true
}

// OldSeoTitle returns the old "seo_title" field's value of the ResellerDomain entity.
// If the ResellerDomain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResellerDomainMutation) OldSeoTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeoTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeoTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeoTitle: %w", err)
	}
	return oldValue.SeoTitle, nil
}

// ResetSeoTitle resets all changes to the "seo_title" field.
func (m *ResellerDomainMutation) ResetSeoTitle() {
	m.seo_title = nil
}

// SetSeoDescription sets the "seo_description" field.
func (m *ResellerDomainMutation) SetSeoDescription(s string) {
	m.seo_description = &s
}

// SeoDescription returns the value of the "seo_description" field in the mutation.
func (m *ResellerDomainMutation) SeoDescription() (r string, exists bool) {
	v := m.seo_description
	if v == nil {
		return
	}
	return *v, true
}

// OldSeoDescription returns the old "seo_description" field's value of the ResellerDomain entity.
// If the ResellerDomain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResellerDomainMutation) OldSeoDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeoDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeoDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeoDescription: %w", err)
	}
	return oldValue.SeoDescription, nil
}

// ResetSeoDescription resets all changes to the "seo_description" field.
func (m *ResellerDomainMutation) ResetSeoDescription() {
	m.seo_description = nil
}

// SetSeoKeywords sets the "seo_keywords" field.
func (m *ResellerDomainMutation) SetSeoKeywords(s string) {
	m.seo_keywords = &s
}

// SeoKeywords returns the value of the "seo_keywords" field in the mutation.
func (m *ResellerDomainMutation) SeoKeywords() (r string, exists bool) {
	v := m.seo_keywords
	if v == nil {
		return
	}
	return *v, true
}

// OldSeoKeywords returns the old "seo_keywords" field's value of the ResellerDomain entity.
// If the ResellerDomain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResellerDomainMutation) OldSeoKeywords(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeoKeywords is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeoKeywords requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeoKeywords: %w", err)
	}
	return oldValue.SeoKeywords, nil
}

// ResetSeoKeywords resets all changes to the "seo_keywords" field.
func (m *ResellerDomainMutation) ResetSeoKeywords() {
	m.seo_keywords = nil
}

// SetLoginRedirect sets the "login_redirect" field.
func (m *ResellerDomainMutation) SetLoginRedirect(s string) {
	m.login_redirect = &s
}

// LoginRedirect returns the value of the "login_redirect" field in the mutation.
func (m *ResellerDomainMutation) LoginRedirect() (r string, exists bool) {
	v := m.login_redirect
	if v == nil {
		return
	}
	return *v, true
}

// OldLoginRedirect returns the old "login_redirect" field's value of the ResellerDomain entity.
// If the ResellerDomain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResellerDomainMutation) OldLoginRedirect(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLoginRedirect is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLoginRedirect requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLoginRedirect: %w", err)
	}
	return oldValue.LoginRedirect, nil
}

// ResetLoginRedirect resets all changes to the "login_redirect" field.
func (m *ResellerDomainMutation) ResetLoginRedirect() {
	m.login_redirect = nil
}

// SetVerifyToken sets the "verify_token" field.
func (m *ResellerDomainMutation) SetVerifyToken(s string) {
	m.verify_token = &s
}

// VerifyToken returns the value of the "verify_token" field in the mutation.
func (m *ResellerDomainMutation) VerifyToken() (r string, exists bool) {
	v := m.verify_token
	if v == nil {
		return
	}
	return *v, true
}

// OldVerifyToken returns the old "verify_token" field's value of the ResellerDomain entity.
// If the ResellerDomain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResellerDomainMutation) OldVerifyToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVerifyToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVerifyToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerifyToken: %w", err)
	}
	return oldValue.VerifyToken, nil
}

// ResetVerifyToken resets all changes to the "verify_token" field.
func (m *ResellerDomainMutation) ResetVerifyToken() {
	m.verify_token = nil
}

// SetVerified sets the "verified" field.
func (m *ResellerDomainMutation) SetVerified(b bool) {
	m.verified = &b
}

// Verified returns the value of the "verified" field in the mutation.
func (m *ResellerDomainMutation) Verified() (r bool, exists bool) {
	v := m.verified
	if v == nil {
		return
	}
	return *v, true
}

// OldVerified returns the old "verified" field's value of the ResellerDomain entity.
// If the ResellerDomain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResellerDomainMutation) OldVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerified: %w", err)
	}
	return oldValue.Verified, nil
}

// ResetVerified resets all changes to the "verified" field.
func (m *ResellerDomainMutation) ResetVerified() {
	m.verified = nil
}

// SetVerifiedAt sets the "verified_at" field.
func (m *ResellerDomainMutation) SetVerifiedAt(t time.Time) {
	m.verified_at = &t
}

// VerifiedAt returns the value of the "verified_at" field in the mutation.
func (m *ResellerDomainMutation) VerifiedAt() (r time.Time, exists bool) {
	v := m.verified_at
	if v == nil {
		return
	}
	return *v, true
}

// OldVerifiedAt returns the old "verified_at" field's value of the ResellerDomain entity.
// If the ResellerDomain object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResellerDomainMutation) OldVerifiedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVerifiedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVerifiedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerifiedAt: %w", err)
	}
	return oldValue.VerifiedAt, nil
}

// ClearVerifiedAt clears the value of the "verified_at" field.
func (m *ResellerDomainMutation) ClearVerifiedAt() {
	m.verified_at = nil
	m.clearedFields[resellerdomain.FieldVerifiedAt] = struct{}{}
}

// VerifiedAtCleared returns if the "verified_at" field was cleared in this mutation.
func (m *ResellerDomainMutation) VerifiedAtCleared() bool {
	_, ok := m.clearedFields[resellerdomain.FieldVerifiedAt]
	return ok
}

// ResetVerifiedAt resets all changes to the "verified_at" field.
func (m *ResellerDomainMutation) ResetVerifiedAt() {
	m.verified_at = nil
	delete(m.clearedFields, resellerdomain.FieldVerifiedAt)
}

// ClearReseller clears the "reseller" edge to the User entity.
func (m *ResellerDomainMutation) ClearReseller() {
	m.clearedreseller = true
	m.clearedFields[resellerdomain.FieldResellerID] = struct{}{}
}

// ResellerCleared reports if the "reseller" edge to the User entity was cleared.
func (m *ResellerDomainMutation) ResellerCleared() bool {
	return m.clearedreseller
}

// ResellerIDs returns the "reseller" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ResellerID instead. It exists only for internal usage by the builders.
func (m *ResellerDomainMutation) ResellerIDs() (ids []int64) {
	if id := m.reseller; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReseller resets all changes to the "reseller" edge.
func (m *ResellerDomainMutation) ResetReseller() {
	m.reseller = nil
	m.clearedreseller = false
}

// Where appends a list predicates to the ResellerDomainMutation builder.
func (m *ResellerDomainMutation) Where(ps ...predicate.ResellerDomain) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ResellerDomainMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ResellerDomainMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ResellerDomain, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ResellerDomainMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ResellerDomainMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ResellerDomain).
func (m *ResellerDomainMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ResellerDomainMutation) Fields() []string {
	fields := make([]string, 0, 23)
	if m.created_at != nil {
		fields = append(fields, resellerdomain.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, resellerdomain.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, resellerdomain.FieldDeletedAt)
	}
	if m.reseller != nil {
		fields = append(fields, resellerdomain.FieldResellerID)
	}
	if m.domain != nil {
		fields = append(fields, resellerdomain.FieldDomain)
	}
	if m.site_name != nil {
		fields = append(fields, resellerdomain.FieldSiteName)
	}
	if m.site_logo != nil {
		fields = append(fields, resellerdomain.FieldSiteLogo)
	}
	if m.brand_color != nil {
		fields = append(fields, resellerdomain.FieldBrandColor)
	}
	if m.custom_css != nil {
		fields = append(fields, resellerdomain.FieldCustomCSS)
	}
	if m.subtitle != nil {
		fields = append(fields, resellerdomain.FieldSubtitle)
	}
	if m.home_content != nil {
		fields = append(fields, resellerdomain.FieldHomeContent)
	}
	if m.home_template != nil {
		fields = append(fields, resellerdomain.FieldHomeTemplate)
	}
	if m.doc_url != nil {
		fields = append(fields, resellerdomain.FieldDocURL)
	}
	if m.purchase_enabled != nil {
		fields = append(fields, resellerdomain.FieldPurchaseEnabled)
	}
	if m.purchase_url != nil {
		fields = append(fields, resellerdomain.FieldPurchaseURL)
	}
	if m.default_locale != nil {
		fields = append(fields, resellerdomain.FieldDefaultLocale)
	}
	if m.seo_title != nil {
		fields = append(fields, resellerdomain.FieldSeoTitle)
	}
	if m.seo_description != nil {
		fields = append(fields, resellerdomain.FieldSeoDescription)
	}
	if m.seo_keywords != nil {
		fields = append(fields, resellerdomain.FieldSeoKeywords)
	}
	if m.login_redirect != nil {
		fields = append(fields, resellerdomain.FieldLoginRedirect)
	}
	if m.verify_token != nil {
		fields = append(fields, resellerdomain.FieldVerifyToken)
	}
	if m.verified != nil {
		fields = append(fields, resellerdomain.FieldVerified)
	}
	if m.verified_at != nil {
		fields = append(fields, resellerdomain.FieldVerifiedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ResellerDomainMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case resellerdomain.FieldCreatedAt:
		return m.CreatedAt()
	case resellerdomain.FieldUpdatedAt:
		return m.UpdatedAt()
	case resellerdomain.FieldDeletedAt:
		return m.DeletedAt()
	case resellerdomain.FieldResellerID:
		return m.ResellerID()
	case resellerdomain.FieldDomain:
		return m.Domain()
	case resellerdomain.FieldSiteName:
		return m.SiteName()
	case resellerdomain.FieldSiteLogo:
		return m.SiteLogo()
	case resellerdomain.FieldBrandColor:
		return m.BrandColor()
	case resellerdomain.FieldCustomCSS:
		return m.CustomCSS()
	case resellerdomain.FieldSubtitle:
		return m.Subtitle()
	case resellerdomain.FieldHomeContent:
		return m.HomeContent()
	case resellerdomain.FieldHomeTemplate:
		return m.HomeTemplate()
	case resellerdomain.FieldDocURL:
		return m.DocURL()
	case resellerdomain.FieldPurchaseEnabled:
		return m.PurchaseEnabled()
	case resellerdomain.FieldPurchaseURL:
		return m.PurchaseURL()
	case resellerdomain.FieldDefaultLocale:
		return m.DefaultLocale()
	case resellerdomain.FieldSeoTitle:
		return m.SeoTitle()
	case resellerdomain.FieldSeoDescription:
		return m.SeoDescription()
	case resellerdomain.FieldSeoKeywords:
		return m.SeoKeywords()
	case resellerdomain.FieldLoginRedirect:
		return m.LoginRedirect()
	case resellerdomain.FieldVerifyToken:
		return m.VerifyToken()
	case resellerdomain.FieldVerified:
		return m.Verified()
	case resellerdomain.FieldVerifiedAt:
		return m.VerifiedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ResellerDomainMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case resellerdomain.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case resellerdomain.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case resellerdomain.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case resellerdomain.FieldResellerID:
		return m.OldResellerID(ctx)
	case resellerdomain.FieldDomain:
		return m.OldDomain(ctx)
	case resellerdomain.FieldSiteName:
		return m.OldSiteName(ctx)
	case resellerdomain.FieldSiteLogo:
		return m.OldSiteLogo(ctx)
	case resellerdomain.FieldBrandColor:
		return m.OldBrandColor(ctx)
	case resellerdomain.FieldCustomCSS:
		return m.OldCustomCSS(ctx)
	case resellerdomain.FieldSubtitle:
		return m.OldSubtitle(ctx)
	case resellerdomain.FieldHomeContent:
		return m.OldHomeContent(ctx)
	case resellerdomain.FieldHomeTemplate:
		return m.OldHomeTemplate(ctx)
	case resellerdomain.FieldDocURL:
		return m.OldDocURL(ctx)
	case resellerdomain.FieldPurchaseEnabled:
		return m.OldPurchaseEnabled(ctx)
	case resellerdomain.FieldPurchaseURL:
		return m.OldPurchaseURL(ctx)
	case resellerdomain.FieldDefaultLocale:
		return m.OldDefaultLocale(ctx)
	case resellerdomain.FieldSeoTitle:
		return m.OldSeoTitle(ctx)
	case resellerdomain.FieldSeoDescription:
		return m.OldSeoDescription(ctx)
	case resellerdomain.FieldSeoKeywords:
		return m.OldSeoKeywords(ctx)
	case resellerdomain.FieldLoginRedirect:
		return m.OldLoginRedirect(ctx)
	case resellerdomain.FieldVerifyToken:
		return m.OldVerifyToken(ctx)
	case resellerdomain.FieldVerified:
		return m.OldVerified(ctx)
	case resellerdomain.FieldVerifiedAt:
		return m.OldVerifiedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ResellerDomain field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResellerDomainMutation) SetField(name string, value ent.Value) error {
	switch name {
	case resellerdomain.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case resellerdomain.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case resellerdomain.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case resellerdomain.FieldResellerID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResellerID(v)
		return nil
	case resellerdomain.FieldDomain:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDomain(v)
		return nil
	case resellerdomain.FieldSiteName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSiteName(v)
		return nil
	case resellerdomain.FieldSiteLogo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSiteLogo(v)
		return nil
	case resellerdomain.FieldBrandColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrandColor(v)
		return nil
	case resellerdomain.FieldCustomCSS:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomCSS(v)
		return nil
	case resellerdomain.FieldSubtitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubtitle(v)
		return nil
	case resellerdomain.FieldHomeContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHomeContent(v)
		return nil
	case resellerdomain.FieldHomeTemplate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHomeTemplate(v)
		return nil
	case resellerdomain.FieldDocURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDocURL(v)
		return nil
	case resellerdomain.FieldPurchaseEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPurchaseEnabled(v)
		return nil
	case resellerdomain.FieldPurchaseURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPurchaseURL(v)
		return nil
	case resellerdomain.FieldDefaultLocale:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultLocale(v)
		return nil
	case resellerdomain.FieldSeoTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeoTitle(v)
		return nil
	case resellerdomain.FieldSeoDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeoDescription(v)
		return nil
	case resellerdomain.FieldSeoKeywords:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeoKeywords(v)
		return nil
	case resellerdomain.FieldLoginRedirect:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLoginRedirect(v)
		return nil
	case resellerdomain.FieldVerifyToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerifyToken(v)
		return nil
	case resellerdomain.FieldVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerified(v)
		return nil
	case resellerdomain.FieldVerifiedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerifiedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ResellerDomain field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ResellerDomainMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ResellerDomainMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResellerDomainMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ResellerDomain numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ResellerDomainMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(resellerdomain.FieldDeletedAt) {
		fields = append(fields, resellerdomain.FieldDeletedAt)
	}
	if m.FieldCleared(resellerdomain.FieldVerifiedAt) {
		fields = append(fields, resellerdomain.FieldVerifiedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ResellerDomainMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResellerDomainMutation) ClearField(name string) error {
	switch name {
	case resellerdomain.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case resellerdomain.FieldVerifiedAt:
		m.ClearVerifiedAt()
		return nil
	}
	return fmt.Errorf("unknown ResellerDomain nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ResellerDomainMutation) ResetField(name string) error {
	switch name {
	case resellerdomain.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case resellerdomain.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case resellerdomain.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case resellerdomain.FieldResellerID:
		m.ResetResellerID()
		return nil
	case resellerdomain.FieldDomain:
		m.ResetDomain()
		return nil
	case resellerdomain.FieldSiteName:
		m.ResetSiteName()
		return nil
	case resellerdomain.FieldSiteLogo:
		m.ResetSiteLogo()
		return nil
	case resellerdomain.FieldBrandColor:
		m.ResetBrandColor()
		return nil
	case resellerdomain.FieldCustomCSS:
		m.ResetCustomCSS()
		return nil
	case resellerdomain.FieldSubtitle:
		m.ResetSubtitle()
		return nil
	case resellerdomain.FieldHomeContent:
		m.ResetHomeContent()
		return nil
	case resellerdomain.FieldHomeTemplate:
		m.ResetHomeTemplate()
		return nil
	case resellerdomain.FieldDocURL:
		m.ResetDocURL()
		return nil
	case resellerdomain.FieldPurchaseEnabled:
		m.ResetPurchaseEnabled()
		return nil
	case resellerdomain.FieldPurchaseURL:
		m.ResetPurchaseURL()
		return nil
	case resellerdomain.FieldDefaultLocale:
		m.ResetDefaultLocale()
		return nil
	case resellerdomain.FieldSeoTitle:
		m.ResetSeoTitle()
		return nil
	case resellerdomain.FieldSeoDescription:
		m.ResetSeoDescription()
		return nil
	case resellerdomain.FieldSeoKeywords:
		m.ResetSeoKeywords()
		return nil
	case resellerdomain.FieldLoginRedirect:
		m.ResetLoginRedirect()
		return nil
	case resellerdomain.FieldVerifyToken:
		m.ResetVerifyToken()
		return nil
	case resellerdomain.FieldVerified:
		m.ResetVerified()
		return nil
	case resellerdomain.FieldVerifiedAt:
		m.ResetVerifiedAt()
		return nil
	}
	return fmt.Errorf("unknown ResellerDomain field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ResellerDomainMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.reseller != nil {
		edges = append(edges, resellerdomain.EdgeReseller)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ResellerDomainMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case resellerdomain.EdgeReseller:
		if id := m.reseller; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ResellerDomainMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ResellerDomainMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ResellerDomainMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedreseller {
		edges = append(edges, resellerdomain.EdgeReseller)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ResellerDomainMutation) EdgeCleared(name string) bool {
	switch name {
	case resellerdomain.EdgeReseller:
		return m.clearedreseller
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ResellerDomainMutation) ClearEdge(name string) error {
	switch name {
	case resellerdomain.EdgeReseller:
		m.ClearReseller()
		return nil
	}
	return fmt.Errorf("unknown ResellerDomain unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ResellerDomainMutation) ResetEdge(name string) error {
	switch name {
	case resellerdomain.EdgeReseller:
		m.ResetReseller()
		return nil
	}
	return fmt.Errorf("unknown ResellerDomain edge %s", name)
}

// ResellerSettingMutation represents an operation that mutates the ResellerSetting nodes in the graph.
type ResellerSettingMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	reseller_id    *int64
	addreseller_id *int64
	key            *string
	value          *string
	created_at     *time.Time
	updated_at     *time.Time
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*ResellerSetting, error)
	predicates     []predicate.ResellerSetting
}

var _ ent.Mutation = (*ResellerSettingMutation)(nil)

// resellersettingOption allows management of the mutation configuration using functional options.
type resellersettingOption func(*ResellerSettingMutation)

// newResellerSettingMutation creates new mutation for the ResellerSetting entity.
func newResellerSettingMutation(c config, op Op, opts ...resellersettingOption) *ResellerSettingMutation {
	m := &ResellerSettingMutation{
		config:        c,
		op:            op,
		typ:           TypeResellerSetting,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResellerSettingID sets the ID field of the mutation.
func withResellerSettingID(id int64) resellersettingOption {
	return func(m *ResellerSettingMutation) {
		var (
			err   error
			once  sync.Once
			value *ResellerSetting
		)
		m.oldValue = func(ctx context.Context) (*ResellerSetting, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ResellerSetting.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResellerSetting sets the old ResellerSetting of the mutation.
func withResellerSetting(node *ResellerSetting) resellersettingOption {
	return func(m *ResellerSettingMutation) {
		m.oldValue = func(context.Context) (*ResellerSetting, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResellerSettingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResellerSettingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ResellerSettingMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ResellerSettingMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ResellerSetting.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetResellerID sets the "reseller_id" field.
func (m *ResellerSettingMutation) SetResellerID(i int64) {
	m.reseller_id = &i
	m.addreseller_id = nil
}

// ResellerID returns the value of the "reseller_id" field in the mutation.
func (m *ResellerSettingMutation) ResellerID() (r int64, exists bool) {
	v := m.reseller_id
	if v == nil {
		return
	}
	return *v, true
}

// OldResellerID returns the old "reseller_id" field's value of the ResellerSetting entity.
// If the ResellerSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResellerSettingMutation) OldResellerID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResellerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResellerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResellerID: %w", err)
	}
	return oldValue.ResellerID, nil
}

// AddResellerID adds i to the "reseller_id" field.
func (m *ResellerSettingMutation) AddResellerID(i int64) {
	if m.addreseller_id != nil {
		*m.addreseller_id += i
	} else {
		m.addreseller_id = &i
	}
}

// AddedResellerID returns the value that was added to the "reseller_id" field in this mutation.
func (m *ResellerSettingMutation) AddedResellerID() (r int64, exists bool) {
	v := m.addreseller_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetResellerID resets all changes to the "reseller_id" field.
func (m *ResellerSettingMutation) ResetResellerID() {
	m.reseller_id = nil
	m.addreseller_id = nil
}

// SetKey sets the "key" field.
func (m *ResellerSettingMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *ResellerSettingMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the ResellerSetting entity.
// If the ResellerSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResellerSettingMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *ResellerSettingMutation) ResetKey() {
	m.key = nil
}

// SetValue sets the "value" field.
func (m *ResellerSettingMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *ResellerSettingMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the ResellerSetting entity.
// If the ResellerSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResellerSettingMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *ResellerSettingMutation) ResetValue() {
	m.value = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ResellerSettingMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ResellerSettingMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ResellerSetting entity.
// If the ResellerSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResellerSettingMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ResellerSettingMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ResellerSettingMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ResellerSettingMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ResellerSetting entity.
// If the ResellerSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ResellerSettingMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ResellerSettingMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ResellerSettingMutation builder.
func (m *ResellerSettingMutation) Where(ps ...predicate.ResellerSetting) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ResellerSettingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ResellerSettingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ResellerSetting, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ResellerSettingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ResellerSettingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ResellerSetting).
func (m *ResellerSettingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ResellerSettingMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.reseller_id != nil {
		fields = append(fields, resellersetting.FieldResellerID)
	}
	if m.key != nil {
		fields = append(fields, resellersetting.FieldKey)
	}
	if m.value != nil {
		fields = append(fields, resellersetting.FieldValue)
	}
	if m.created_at != nil {
		fields = append(fields, resellersetting.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, resellersetting.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ResellerSettingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case resellersetting.FieldResellerID:
		return m.ResellerID()
	case resellersetting.FieldKey:
		return m.Key()
	case resellersetting.FieldValue:
		return m.Value()
	case resellersetting.FieldCreatedAt:
		return m.CreatedAt()
	case resellersetting.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ResellerSettingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case resellersetting.FieldResellerID:
		return m.OldResellerID(ctx)
	case resellersetting.FieldKey:
		return m.OldKey(ctx)
	case resellersetting.FieldValue:
		return m.OldValue(ctx)
	case resellersetting.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case resellersetting.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ResellerSetting field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResellerSettingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case resellersetting.FieldResellerID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResellerID(v)
		return nil
	case resellersetting.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case resellersetting.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case resellersetting.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case resellersetting.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ResellerSetting field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ResellerSettingMutation) AddedFields() []string {
	var fields []string
	if m.addreseller_id != nil {
		fields = append(fields, resellersetting.FieldResellerID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ResellerSettingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case resellersetting.FieldResellerID:
		return m.AddedResellerID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResellerSettingMutation) AddField(name string, value ent.Value) error {
	switch name {
	case resellersetting.FieldResellerID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResellerID(v)
		return nil
	}
	return fmt.Errorf("unknown ResellerSetting numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ResellerSettingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ResellerSettingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResellerSettingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ResellerSetting nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ResellerSettingMutation) ResetField(name string) error {
	switch name {
	case resellersetting.FieldResellerID:
		m.ResetResellerID()
		return nil
	case resellersetting.FieldKey:
		m.ResetKey()
		return nil
	case resellersetting.FieldValue:
		m.ResetValue()
		return nil
	case resellersetting.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case resellersetting.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ResellerSetting field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ResellerSettingMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ResellerSettingMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ResellerSettingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ResellerSettingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ResellerSettingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ResellerSettingMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ResellerSettingMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ResellerSetting unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ResellerSettingMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ResellerSetting edge %s", name)
}

// SettingMutation represents an operation that mutates the Setting nodes in the graph.
type SettingMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	key           *string
	value         *string
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Setting, error)
	predicates    []predicate.Setting
}

var _ ent.Mutation = (*SettingMutation)(nil)

// settingOption allows management of the mutation configuration using functional options.
type settingOption func(*SettingMutation)

// newSettingMutation creates new mutation for the Setting entity.
func newSettingMutation(c config, op Op, opts ...settingOption) *SettingMutation {
	m := &SettingMutation{
		config:        c,
		op:            op,
		typ:           TypeSetting,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSettingID sets the ID field of the mutation.
func withSettingID(id int64) settingOption {
	return func(m *SettingMutation) {
		var (
			err   error
			once  sync.Once
			value *Setting
		)
		m.oldValue = func(ctx context.Context) (*Setting, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Setting.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSetting sets the old Setting of the mutation.
func withSetting(node *Setting) settingOption {
	return func(m *SettingMutation) {
		m.oldValue = func(context.Context) (*Setting, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SettingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SettingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SettingMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SettingMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Setting.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetKey sets the "key" field.
func (m *SettingMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *SettingMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *SettingMutation) ResetKey() {
	m.key = nil
}

// SetValue sets the "value" field.
func (m *SettingMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *SettingMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *SettingMutation) ResetValue() {
	m.value = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SettingMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SettingMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SettingMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the SettingMutation builder.
func (m *SettingMutation) Where(ps ...predicate.Setting) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SettingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SettingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Setting, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SettingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SettingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Setting).
func (m *SettingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SettingMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.key != nil {
		fields = append(fields, setting.FieldKey)
	}
	if m.value != nil {
		fields = append(fields, setting.FieldValue)
	}
	if m.updated_at != nil {
		fields = append(fields, setting.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SettingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case setting.FieldKey:
		return m.Key()
	case setting.FieldValue:
		return m.Value()
	case setting.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SettingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case setting.FieldKey:
		return m.OldKey(ctx)
	case setting.FieldValue:
		return m.OldValue(ctx)
	case setting.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Setting field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case setting.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case setting.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case setting.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Setting field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SettingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SettingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Setting numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SettingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SettingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SettingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Setting nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SettingMutation) ResetField(name string) error {
	switch name {
	case setting.FieldKey:
		m.ResetKey()
		return nil
	case setting.FieldValue:
		m.ResetValue()
		return nil
	case setting.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Setting field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SettingMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SettingMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SettingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SettingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SettingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SettingMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SettingMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Setting unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SettingMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Setting edge %s", name)
}

// UsageCleanupTaskMutation represents an operation that mutates the UsageCleanupTask nodes in the graph.
type UsageCleanupTaskMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	created_at      *time.Time
	updated_at      *time.Time
	status          *string
	filters         *json.RawMessage
	appendfilters   json.RawMessage
	created_by      *int64
	addcreated_by   *int64
	deleted_rows    *int64
	adddeleted_rows *int64
	error_message   *string
	canceled_by     *int64
	addcanceled_by  *int64
	canceled_at     *time.Time
	started_at      *time.Time
	finished_at     *time.Time
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*UsageCleanupTask, error)
	predicates      []predicate.UsageCleanupTask
}

var _ ent.Mutation = (*UsageCleanupTaskMutation)(nil)

// usagecleanuptaskOption allows management of the mutation configuration using functional options.
type usagecleanuptaskOption func(*UsageCleanupTaskMutation)

// newUsageCleanupTaskMutation creates new mutation for the UsageCleanupTask entity.
func newUsageCleanupTaskMutation(c config, op Op, opts ...usagecleanuptaskOption) *UsageCleanupTaskMutation {
	m := &UsageCleanupTaskMutation{
		config:        c,
		op:            op,
		typ:           TypeUsageCleanupTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUsageCleanupTaskID sets the ID field of the mutation.
func withUsageCleanupTaskID(id int64) usagecleanuptaskOption {
	return func(m *UsageCleanupTaskMutation) {
		var (
			err   error
			once  sync.Once
			value *UsageCleanupTask
		)
		m.oldValue = func(ctx context.Context) (*UsageCleanupTask, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UsageCleanupTask.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUsageCleanupTask sets the old UsageCleanupTask of the mutation.
func withUsageCleanupTask(node *UsageCleanupTask) usagecleanuptaskOption {
	return func(m *UsageCleanupTaskMutation) {
		m.oldValue = func(context.Context) (*UsageCleanupTask, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UsageCleanupTaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UsageCleanupTaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UsageCleanupTaskMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UsageCleanupTaskMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UsageCleanupTask.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UsageCleanupTaskMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UsageCleanupTaskMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UsageCleanupTask entity.
// If the UsageCleanupTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageCleanupTaskMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UsageCleanupTaskMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UsageCleanupTaskMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UsageCleanupTaskMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UsageCleanupTask entity.
// If the UsageCleanupTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageCleanupTaskMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UsageCleanupTaskMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *UsageCleanupTaskMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *UsageCleanupTaskMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the UsageCleanupTask entity.
// If the UsageCleanupTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageCleanupTaskMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *UsageCleanupTaskMutation) ResetStatus() {
	m.status = nil
}

// SetFilters sets the "filters" field.
func (m *UsageCleanupTaskMutation) SetFilters(jm json.RawMessage) {
	m.filters = &jm
	m.appendfilters = nil
}

// Filters returns the value of the "filters" field in the mutation.
func (m *UsageCleanupTaskMutation) Filters() (r json.RawMessage, exists bool) {
	v := m.filters
	if v == nil {
		return
	}
	return *v, true
}

// OldFilters returns the old "filters" field's value of the UsageCleanupTask entity.
// If the UsageCleanupTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageCleanupTaskMutation) OldFilters(ctx context.Context) (v json.RawMessage, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilters is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilters requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilters: %w", err)
	}
	return oldValue.Filters, nil
}

// AppendFilters adds jm to the "filters" field.
func (m *UsageCleanupTaskMutation) AppendFilters(jm json.RawMessage) {
	m.appendfilters = append(m.appendfilters, jm...)
}

// AppendedFilters returns the list of values that were appended to the "filters" field in this mutation.
func (m *UsageCleanupTaskMutation) AppendedFilters() (json.RawMessage, bool) {
	if len(m.appendfilters) == 0 {
		return nil, false
	}
	return m.appendfilters, true
}

// ResetFilters resets all changes to the "filters" field.
func (m *UsageCleanupTaskMutation) ResetFilters() {
	m.filters = nil
	m.appendfilters = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *UsageCleanupTaskMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *UsageCleanupTaskMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the UsageCleanupTask entity.
// If the UsageCleanupTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageCleanupTaskMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *UsageCleanupTaskMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *UsageCleanupTaskMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *UsageCleanupTaskMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
}

// SetDeletedRows sets the "deleted_rows" field.
func (m *UsageCleanupTaskMutation) SetDeletedRows(i int64) {
	m.deleted_rows = &i
	m.adddeleted_rows = nil
}

// DeletedRows returns the value of the "deleted_rows" field in the mutation.
func (m *UsageCleanupTaskMutation) DeletedRows() (r int64, exists bool) {
	v := m.deleted_rows
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedRows returns the old "deleted_rows" field's value of the UsageCleanupTask entity.
// If the UsageCleanupTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageCleanupTaskMutation) OldDeletedRows(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedRows is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedRows requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedRows: %w", err)
	}
	return oldValue.DeletedRows, nil
}

// AddDeletedRows adds i to the "deleted_rows" field.
func (m *UsageCleanupTaskMutation) AddDeletedRows(i int64) {
	if m.adddeleted_rows != nil {
		*m.adddeleted_rows += i
	} else {
		m.adddeleted_rows = &i
	}
}

// AddedDeletedRows returns the value that was added to the "deleted_rows" field in this mutation.
func (m *UsageCleanupTaskMutation) AddedDeletedRows() (r int64, exists bool) {
	v := m.adddeleted_rows
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeletedRows resets all changes to the "deleted_rows" field.
func (m *UsageCleanupTaskMutation) ResetDeletedRows() {
	m.deleted_rows = nil
	m.adddeleted_rows = nil
}

// SetErrorMessage sets the "error_message" field.
func (m *UsageCleanupTaskMutation) SetErrorMessage(s string) {
	m.error_message = &s
}

// ErrorMessage returns the value of the "error_message" field in the mutation.
func (m *UsageCleanupTaskMutation) ErrorMessage() (r string, exists bool) {
	v := m.error_message
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "error_message" field's value of the UsageCleanupTask entity.
// If the UsageCleanupTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageCleanupTaskMutation) OldErrorMessage(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "error_message" field.
func (m *UsageCleanupTaskMutation) ClearErrorMessage() {
	m.error_message = nil
	m.clearedFields[usagecleanuptask.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "error_message" field was cleared in this mutation.
func (m *UsageCleanupTaskMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[usagecleanuptask.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "error_message" field.
func (m *UsageCleanupTaskMutation) ResetErrorMessage() {
	m.error_message = nil
	delete(m.clearedFields, usagecleanuptask.FieldErrorMessage)
}

// SetCanceledBy sets the "canceled_by" field.
func (m *UsageCleanupTaskMutation) SetCanceledBy(i int64) {
	m.canceled_by = &i
	m.addcanceled_by = nil
}

// CanceledBy returns the value of the "canceled_by" field in the mutation.
func (m *UsageCleanupTaskMutation) CanceledBy() (r int64, exists bool) {
	v := m.canceled_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCanceledBy returns the old "canceled_by" field's value of the UsageCleanupTask entity.
// If the UsageCleanupTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageCleanupTaskMutation) OldCanceledBy(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCanceledBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCanceledBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCanceledBy: %w", err)
	}
	return oldValue.CanceledBy, nil
}

// AddCanceledBy adds i to the "canceled_by" field.
func (m *UsageCleanupTaskMutation) AddCanceledBy(i int64) {
	if m.addcanceled_by != nil {
		*m.addcanceled_by += i
	} else {
		m.addcanceled_by = &i
	}
}

// AddedCanceledBy returns the value that was added to the "canceled_by" field in this mutation.
func (m *UsageCleanupTaskMutation) AddedCanceledBy() (r int64, exists bool) {
	v := m.addcanceled_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCanceledBy clears the value of the "canceled_by" field.
func (m *UsageCleanupTaskMutation) ClearCanceledBy() {
	m.canceled_by = nil
	m.addcanceled_by = nil
	m.clearedFields[usagecleanuptask.FieldCanceledBy] = struct{}{}
}

// CanceledByCleared returns if the "canceled_by" field was cleared in this mutation.
func (m *UsageCleanupTaskMutation) CanceledByCleared() bool {
	_, ok := m.clearedFields[usagecleanuptask.FieldCanceledBy]
	return ok
}

// ResetCanceledBy resets all changes to the "canceled_by" field.
func (m *UsageCleanupTaskMutation) ResetCanceledBy() {
	m.canceled_by = nil
	m.addcanceled_by = nil
	delete(m.clearedFields, usagecleanuptask.FieldCanceledBy)
}

// SetCanceledAt sets the "canceled_at" field.
func (m *UsageCleanupTaskMutation) SetCanceledAt(t time.Time) {
	m.canceled_at = &t
}

// CanceledAt returns the value of the "canceled_at" field in the mutation.
func (m *UsageCleanupTaskMutation) CanceledAt() (r time.Time, exists bool) {
	v := m.canceled_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCanceledAt returns the old "canceled_at" field's value of the UsageCleanupTask entity.
// If the UsageCleanupTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageCleanupTaskMutation) OldCanceledAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCanceledAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCanceledAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCanceledAt: %w", err)
	}
	return oldValue.CanceledAt, nil
}

// ClearCanceledAt clears the value of the "canceled_at" field.
func (m *UsageCleanupTaskMutation) ClearCanceledAt() {
	m.canceled_at = nil
	m.clearedFields[usagecleanuptask.FieldCanceledAt] = struct{}{}
}

// CanceledAtCleared returns if the "canceled_at" field was cleared in this mutation.
func (m *UsageCleanupTaskMutation) CanceledAtCleared() bool {
	_, ok := m.clearedFields[usagecleanuptask.FieldCanceledAt]
	return ok
}

// ResetCanceledAt resets all changes to the "canceled_at" field.
func (m *UsageCleanupTaskMutation) ResetCanceledAt() {
	m.canceled_at = nil
	delete(m.clearedFields, usagecleanuptask.FieldCanceledAt)
}

// SetStartedAt sets the "started_at" field.
func (m *UsageCleanupTaskMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *UsageCleanupTaskMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the UsageCleanupTask entity.
// If the UsageCleanupTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageCleanupTaskMutation) OldStartedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ClearStartedAt clears the value of the "started_at" field.
func (m *UsageCleanupTaskMutation) ClearStartedAt() {
	m.started_at = nil
	m.clearedFields[usagecleanuptask.FieldStartedAt] = struct{}{}
}

// StartedAtCleared returns if the "started_at" field was cleared in this mutation.
func (m *UsageCleanupTaskMutation) StartedAtCleared() bool {
	_, ok := m.clearedFields[usagecleanuptask.FieldStartedAt]
	return ok
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *UsageCleanupTaskMutation) ResetStartedAt() {
	m.started_at = nil
	delete(m.clearedFields, usagecleanuptask.FieldStartedAt)
}

// SetFinishedAt sets the "finished_at" field.
func (m *UsageCleanupTaskMutation) SetFinishedAt(t time.Time) {
	m.finished_at = &t
}

// FinishedAt returns the value of the "finished_at" field in the mutation.
func (m *UsageCleanupTaskMutation) FinishedAt() (r time.Time, exists bool) {
	v := m.finished_at
	if v == nil {
		return
	}
	return *v, true
}

// OldFinishedAt returns the old "finished_at" field's value of the UsageCleanupTask entity.
// If the UsageCleanupTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageCleanupTaskMutation) OldFinishedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinishedAt: %w", err)
	}
	return oldValue.FinishedAt, nil
}

// ClearFinishedAt clears the value of the "finished_at" field.
func (m *UsageCleanupTaskMutation) ClearFinishedAt() {
	m.finished_at = nil
	m.clearedFields[usagecleanuptask.FieldFinishedAt] = struct{}{}
}

// FinishedAtCleared returns if the "finished_at" field was cleared in this mutation.
func (m *UsageCleanupTaskMutation) FinishedAtCleared() bool {
	_, ok := m.clearedFields[usagecleanuptask.FieldFinishedAt]
	return ok
}

// ResetFinishedAt resets all changes to the "finished_at" field.
func (m *UsageCleanupTaskMutation) ResetFinishedAt() {
	m.finished_at = nil
	delete(m.clearedFields, usagecleanuptask.FieldFinishedAt)
}

// Where appends a list predicates to the UsageCleanupTaskMutation builder.
func (m *UsageCleanupTaskMutation) Where(ps ...predicate.UsageCleanupTask) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UsageCleanupTaskMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UsageCleanupTaskMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UsageCleanupTask, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UsageCleanupTaskMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UsageCleanupTaskMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UsageCleanupTask).
func (m *UsageCleanupTaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UsageCleanupTaskMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, usagecleanuptask.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, usagecleanuptask.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, usagecleanuptask.FieldStatus)
	}
	if m.filters != nil {
		fields = append(fields, usagecleanuptask.FieldFilters)
	}
	if m.created_by != nil {
		fields = append(fields, usagecleanuptask.FieldCreatedBy)
	}
	if m.deleted_rows != nil {
		fields = append(fields, usagecleanuptask.FieldDeletedRows)
	}
	if m.error_message != nil {
		fields = append(fields, usagecleanuptask.FieldErrorMessage)
	}
	if m.canceled_by != nil {
		fields = append(fields, usagecleanuptask.FieldCanceledBy)
	}
	if m.canceled_at != nil {
		fields = append(fields, usagecleanuptask.FieldCanceledAt)
	}
	if m.started_at != nil {
		fields = append(fields, usagecleanuptask.FieldStartedAt)
	}
	if m.finished_at != nil {
		fields = append(fields, usagecleanuptask.FieldFinishedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UsageCleanupTaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usagecleanuptask.FieldCreatedAt:
		return m.CreatedAt()
	case usagecleanuptask.FieldUpdatedAt:
		return m.UpdatedAt()
	case usagecleanuptask.FieldStatus:
		return m.Status()
	case usagecleanuptask.FieldFilters:
		return m.Filters()
	case usagecleanuptask.FieldCreatedBy:
		return m.CreatedBy()
	case usagecleanuptask.FieldDeletedRows:
		return m.DeletedRows()
	case usagecleanuptask.FieldErrorMessage:
		return m.ErrorMessage()
	case usagecleanuptask.FieldCanceledBy:
		return m.CanceledBy()
	case usagecleanuptask.FieldCanceledAt:
		return m.CanceledAt()
	case usagecleanuptask.FieldStartedAt:
		return m.StartedAt()
	case usagecleanuptask.FieldFinishedAt:
		return m.FinishedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UsageCleanupTaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usagecleanuptask.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case usagecleanuptask.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case usagecleanuptask.FieldStatus:
		return m.OldStatus(ctx)
	case usagecleanuptask.FieldFilters:
		return m.OldFilters(ctx)
	case usagecleanuptask.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case usagecleanuptask.FieldDeletedRows:
		return m.OldDeletedRows(ctx)
	case usagecleanuptask.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case usagecleanuptask.FieldCanceledBy:
		return m.OldCanceledBy(ctx)
	case usagecleanuptask.FieldCanceledAt:
		return m.OldCanceledAt(ctx)
	case usagecleanuptask.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case usagecleanuptask.FieldFinishedAt:
		return m.OldFinishedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UsageCleanupTask field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UsageCleanupTaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usagecleanuptask.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case usagecleanuptask.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case usagecleanuptask.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case usagecleanuptask.FieldFilters:
		v, ok := value.(json.RawMessage)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilters(v)
		return nil
	case usagecleanuptask.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case usagecleanuptask.FieldDeletedRows:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedRows(v)
		return nil
	case usagecleanuptask.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case usagecleanuptask.FieldCanceledBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCanceledBy(v)
		return nil
	case usagecleanuptask.FieldCanceledAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCanceledAt(v)
		return nil
	case usagecleanuptask.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case usagecleanuptask.FieldFinishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinishedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UsageCleanupTask field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UsageCleanupTaskMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, usagecleanuptask.FieldCreatedBy)
	}
	if m.adddeleted_rows != nil {
		fields = append(fields, usagecleanuptask.FieldDeletedRows)
	}
	if m.addcanceled_by != nil {
		fields = append(fields, usagecleanuptask.FieldCanceledBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UsageCleanupTaskMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case usagecleanuptask.FieldCreatedBy:
		return m.AddedCreatedBy()
	case usagecleanuptask.FieldDeletedRows:
		return m.AddedDeletedRows()
	case usagecleanuptask.FieldCanceledBy:
		return m.AddedCanceledBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UsageCleanupTaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	case usagecleanuptask.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case usagecleanuptask.FieldDeletedRows:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedRows(v)
		return nil
	case usagecleanuptask.FieldCanceledBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCanceledBy(v)
		return nil
	}
	return fmt.Errorf("unknown UsageCleanupTask numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UsageCleanupTaskMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(usagecleanuptask.FieldErrorMessage) {
		fields = append(fields, usagecleanuptask.FieldErrorMessage)
	}
	if m.FieldCleared(usagecleanuptask.FieldCanceledBy) {
		fields = append(fields, usagecleanuptask.FieldCanceledBy)
	}
	if m.FieldCleared(usagecleanuptask.FieldCanceledAt) {
		fields = append(fields, usagecleanuptask.FieldCanceledAt)
	}
	if m.FieldCleared(usagecleanuptask.FieldStartedAt) {
		fields = append(fields, usagecleanuptask.FieldStartedAt)
	}
	if m.FieldCleared(usagecleanuptask.FieldFinishedAt) {
		fields = append(fields, usagecleanuptask.FieldFinishedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UsageCleanupTaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UsageCleanupTaskMutation) ClearField(name string) error {
	switch name {
	case usagecleanuptask.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	case usagecleanuptask.FieldCanceledBy:
		m.ClearCanceledBy()
		return nil
	case usagecleanuptask.FieldCanceledAt:
		m.ClearCanceledAt()
		return nil
	case usagecleanuptask.FieldStartedAt:
		m.ClearStartedAt()
		return nil
	case usagecleanuptask.FieldFinishedAt:
		m.ClearFinishedAt()
		return nil
	}
	return fmt.Errorf("unknown UsageCleanupTask nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UsageCleanupTaskMutation) ResetField(name string) error {
	switch name {
	case usagecleanuptask.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case usagecleanuptask.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case usagecleanuptask.FieldStatus:
		m.ResetStatus()
		return nil
	case usagecleanuptask.FieldFilters:
		m.ResetFilters()
		return nil
	case usagecleanuptask.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case usagecleanuptask.FieldDeletedRows:
		m.ResetDeletedRows()
		return nil
	case usagecleanuptask.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case usagecleanuptask.FieldCanceledBy:
		m.ResetCanceledBy()
		return nil
	case usagecleanuptask.FieldCanceledAt:
		m.ResetCanceledAt()
		return nil
	case usagecleanuptask.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case usagecleanuptask.FieldFinishedAt:
		m.ResetFinishedAt()
		return nil
	}
	return fmt.Errorf("unknown UsageCleanupTask field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UsageCleanupTaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UsageCleanupTaskMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UsageCleanupTaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UsageCleanupTaskMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UsageCleanupTaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UsageCleanupTaskMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UsageCleanupTaskMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UsageCleanupTask unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UsageCleanupTaskMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UsageCleanupTask edge %s", name)
}

// UsageLogMutation represents an operation that mutates the UsageLog nodes in the graph.
type UsageLogMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int64
	request_id                  *string
	model                       *string
	input_tokens                *int
	addinput_tokens             *int
	output_tokens               *int
	addoutput_tokens            *int
	cache_creation_tokens       *int
	addcache_creation_tokens    *int
	cache_read_tokens           *int
	addcache_read_tokens        *int
	cache_creation_5m_tokens    *int
	addcache_creation_5m_tokens *int
	cache_creation_1h_tokens    *int
	addcache_creation_1h_tokens *int
	input_cost                  *float64
	addinput_cost               *float64
	output_cost                 *float64
	addoutput_cost              *float64
	cache_creation_cost         *float64
	addcache_creation_cost      *float64
	cache_read_cost             *float64
	addcache_read_cost          *float64
	total_cost                  *float64
	addtotal_cost               *float64
	actual_cost                 *float64
	addactual_cost              *float64
	rate_multiplier             *float64
	addrate_multiplier          *float64
	account_rate_multiplier     *float64
	addaccount_rate_multiplier  *float64
	billing_type                *int8
	addbilling_type             *int8
	stream                      *bool
	duration_ms                 *int
	addduration_ms              *int
	first_token_ms              *int
	addfirst_token_ms           *int
	user_agent                  *string
	ip_address                  *string
	image_count                 *int
	addimage_count              *int
	image_size                  *string
	created_at                  *time.Time
	clearedFields               map[string]struct{}
	user                        *int64
	cleareduser                 bool
	api_key                     *int64
	clearedapi_key              bool
	account                     *int64
	clearedaccount              bool
	group                       *int64
	clearedgroup                bool
	subscription                *int64
	clearedsubscription         bool
	done                        bool
	oldValue                    func(context.Context) (*UsageLog, error)
	predicates                  []predicate.UsageLog
}

var _ ent.Mutation = (*UsageLogMutation)(nil)

// usagelogOption allows management of the mutation configuration using functional options.
type usagelogOption func(*UsageLogMutation)

// newUsageLogMutation creates new mutation for the UsageLog entity.
func newUsageLogMutation(c config, op Op, opts ...usagelogOption) *UsageLogMutation {
	m := &UsageLogMutation{
		config:        c,
		op:            op,
		typ:           TypeUsageLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUsageLogID sets the ID field of the mutation.
func withUsageLogID(id int64) usagelogOption {
	return func(m *UsageLogMutation) {
		var (
			err   error
			once  sync.Once
			value *UsageLog
		)
		m.oldValue = func(ctx context.Context) (*UsageLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UsageLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUsageLog sets the old UsageLog of the mutation.
func withUsageLog(node *UsageLog) usagelogOption {
	return func(m *UsageLogMutation) {
		m.oldValue = func(context.Context) (*UsageLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UsageLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UsageLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UsageLogMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UsageLogMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UsageLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *UsageLogMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UsageLogMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UsageLogMutation) ResetUserID() {
	m.user = nil
}

// SetAPIKeyID sets the "api_key_id" field.
func (m *UsageLogMutation) SetAPIKeyID(i int64) {
	m.api_key = &i
}

// APIKeyID returns the value of the "api_key_id" field in the mutation.
func (m *UsageLogMutation) APIKeyID() (r int64, exists bool) {
	v := m.api_key
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIKeyID returns the old "api_key_id" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldAPIKeyID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPIKeyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPIKeyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIKeyID: %w", err)
	}
	return oldValue.APIKeyID, nil
}

// ResetAPIKeyID resets all changes to the "api_key_id" field.
func (m *UsageLogMutation) ResetAPIKeyID() {
	m.api_key = nil
}

// SetAccountID sets the "account_id" field.
func (m *UsageLogMutation) SetAccountID(i int64) {
	m.account = &i
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *UsageLogMutation) AccountID() (r int64, exists bool) {
	v := m.account
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldAccountID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *UsageLogMutation) ResetAccountID() {
	m.account = nil
}

// SetRequestID sets the "request_id" field.
func (m *UsageLogMutation) SetRequestID(s string) {
	m.request_id = &s
}

// RequestID returns the value of the "request_id" field in the mutation.
func (m *UsageLogMutation) RequestID() (r string, exists bool) {
	v := m.request_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestID returns the old "request_id" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldRequestID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestID: %w", err)
	}
	return oldValue.RequestID, nil
}

// ResetRequestID resets all changes to the "request_id" field.
func (m *UsageLogMutation) ResetRequestID() {
	m.request_id = nil
}

// SetModel sets the "model" field.
func (m *UsageLogMutation) SetModel(s string) {
	m.model = &s
}

// Model returns the value of the "model" field in the mutation.
func (m *UsageLogMutation) Model() (r string, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// ResetModel resets all changes to the "model" field.
func (m *UsageLogMutation) ResetModel() {
	m.model = nil
}

// SetGroupID sets the "group_id" field.
func (m *UsageLogMutation) SetGroupID(i int64) {
	m.group = &i
}

// GroupID returns the value of the "group_id" field in the mutation.
func (m *UsageLogMutation) GroupID() (r int64, exists bool) {
	v := m.group
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupID returns the old "group_id" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldGroupID(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupID: %w", err)
	}
	return oldValue.GroupID, nil
}

// ClearGroupID clears the value of the "group_id" field.
func (m *UsageLogMutation) ClearGroupID() {
	m.group = nil
	m.clearedFields[usagelog.FieldGroupID] = struct{}{}
}

// GroupIDCleared returns if the "group_id" field was cleared in this mutation.
func (m *UsageLogMutation) GroupIDCleared() bool {
	_, ok := m.clearedFields[usagelog.FieldGroupID]
	return ok
}

// ResetGroupID resets all changes to the "group_id" field.
func (m *UsageLogMutation) ResetGroupID() {
	m.group = nil
	delete(m.clearedFields, usagelog.FieldGroupID)
}

// SetSubscriptionID sets the "subscription_id" field.
func (m *UsageLogMutation) SetSubscriptionID(i int64) {
	m.subscription = &i
}

// SubscriptionID returns the value of the "subscription_id" field in the mutation.
func (m *UsageLogMutation) SubscriptionID() (r int64, exists bool) {
	v := m.subscription
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscriptionID returns the old "subscription_id" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldSubscriptionID(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscriptionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscriptionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscriptionID: %w", err)
	}
	return oldValue.SubscriptionID, nil
}

// ClearSubscriptionID clears the value of the "subscription_id" field.
func (m *UsageLogMutation) ClearSubscriptionID() {
	m.subscription = nil
	m.clearedFields[usagelog.FieldSubscriptionID] = struct{}{}
}

// SubscriptionIDCleared returns if the "subscription_id" field was cleared in this mutation.
func (m *UsageLogMutation) SubscriptionIDCleared() bool {
	_, ok := m.clearedFields[usagelog.FieldSubscriptionID]
	return ok
}

// ResetSubscriptionID resets all changes to the "subscription_id" field.
func (m *UsageLogMutation) ResetSubscriptionID() {
	m.subscription = nil
	delete(m.clearedFields, usagelog.FieldSubscriptionID)
}

// SetInputTokens sets the "input_tokens" field.
func (m *UsageLogMutation) SetInputTokens(i int) {
	m.input_tokens = &i
	m.addinput_tokens = nil
}

// InputTokens returns the value of the "input_tokens" field in the mutation.
func (m *UsageLogMutation) InputTokens() (r int, exists bool) {
	v := m.input_tokens
	if v == nil {
		return
	}
	return *v, true
}

// OldInputTokens returns the old "input_tokens" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldInputTokens(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInputTokens is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInputTokens requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInputTokens: %w", err)
	}
	return oldValue.InputTokens, nil
}

// AddInputTokens adds i to the "input_tokens" field.
func (m *UsageLogMutation) AddInputTokens(i int) {
	if m.addinput_tokens != nil {
		*m.addinput_tokens += i
	} else {
		m.addinput_tokens = &i
	}
}

// AddedInputTokens returns the value that was added to the "input_tokens" field in this mutation.
func (m *UsageLogMutation) AddedInputTokens() (r int, exists bool) {
	v := m.addinput_tokens
	if v == nil {
		return
	}
	return *v, true
}

// ResetInputTokens resets all changes to the "input_tokens" field.
func (m *UsageLogMutation) ResetInputTokens() {
	m.input_tokens = nil
	m.addinput_tokens = nil
}

// SetOutputTokens sets the "output_tokens" field.
func (m *UsageLogMutation) SetOutputTokens(i int) {
	m.output_tokens = &i
	m.addoutput_tokens = nil
}

// OutputTokens returns the value of the "output_tokens" field in the mutation.
func (m *UsageLogMutation) OutputTokens() (r int, exists bool) {
	v := m.output_tokens
	if v == nil {
		return
	}
	return *v, true
}

// OldOutputTokens returns the old "output_tokens" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldOutputTokens(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutputTokens is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutputTokens requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutputTokens: %w", err)
	}
	return oldValue.OutputTokens, nil
}

// AddOutputTokens adds i to the "output_tokens" field.
func (m *UsageLogMutation) AddOutputTokens(i int) {
	if m.addoutput_tokens != nil {
		*m.addoutput_tokens += i
	} else {
		m.addoutput_tokens = &i
	}
}

// AddedOutputTokens returns the value that was added to the "output_tokens" field in this mutation.
func (m *UsageLogMutation) AddedOutputTokens() (r int, exists bool) {
	v := m.addoutput_tokens
	if v == nil {
		return
	}
	return *v, true
}

// ResetOutputTokens resets all changes to the "output_tokens" field.
func (m *UsageLogMutation) ResetOutputTokens() {
	m.output_tokens = nil
	m.addoutput_tokens = nil
}

// SetCacheCreationTokens sets the "cache_creation_tokens" field.
func (m *UsageLogMutation) SetCacheCreationTokens(i int) {
	m.cache_creation_tokens = &i
	m.addcache_creation_tokens = nil
}

// CacheCreationTokens returns the value of the "cache_creation_tokens" field in the mutation.
func (m *UsageLogMutation) CacheCreationTokens() (r int, exists bool) {
	v := m.cache_creation_tokens
	if v == nil {
		return
	}
	return *v, true
}

// OldCacheCreationTokens returns the old "cache_creation_tokens" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldCacheCreationTokens(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCacheCreationTokens is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCacheCreationTokens requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCacheCreationTokens: %w", err)
	}
	return oldValue.CacheCreationTokens, nil
}

// AddCacheCreationTokens adds i to the "cache_creation_tokens" field.
func (m *UsageLogMutation) AddCacheCreationTokens(i int) {
	if m.addcache_creation_tokens != nil {
		*m.addcache_creation_tokens += i
	} else {
		m.addcache_creation_tokens = &i
	}
}

// AddedCacheCreationTokens returns the value that was added to the "cache_creation_tokens" field in this mutation.
func (m *UsageLogMutation) AddedCacheCreationTokens() (r int, exists bool) {
	v := m.addcache_creation_tokens
	if v == nil {
		return
	}
	return *v, true
}

// ResetCacheCreationTokens resets all changes to the "cache_creation_tokens" field.
func (m *UsageLogMutation) ResetCacheCreationTokens() {
	m.cache_creation_tokens = nil
	m.addcache_creation_tokens = nil
}

// SetCacheReadTokens sets the "cache_read_tokens" field.
func (m *UsageLogMutation) SetCacheReadTokens(i int) {
	m.cache_read_tokens = &i
	m.addcache_read_tokens = nil
}

// CacheReadTokens returns the value of the "cache_read_tokens" field in the mutation.
func (m *UsageLogMutation) CacheReadTokens() (r int, exists bool) {
	v := m.cache_read_tokens
	if v == nil {
		return
	}
	return *v, true
}

// OldCacheReadTokens returns the old "cache_read_tokens" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldCacheReadTokens(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCacheReadTokens is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCacheReadTokens requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCacheReadTokens: %w", err)
	}
	return oldValue.CacheReadTokens, nil
}

// AddCacheReadTokens adds i to the "cache_read_tokens" field.
func (m *UsageLogMutation) AddCacheReadTokens(i int) {
	if m.addcache_read_tokens != nil {
		*m.addcache_read_tokens += i
	} else {
		m.addcache_read_tokens = &i
	}
}

// AddedCacheReadTokens returns the value that was added to the "cache_read_tokens" field in this mutation.
func (m *UsageLogMutation) AddedCacheReadTokens() (r int, exists bool) {
	v := m.addcache_read_tokens
	if v == nil {
		return
	}
	return *v, true
}

// ResetCacheReadTokens resets all changes to the "cache_read_tokens" field.
func (m *UsageLogMutation) ResetCacheReadTokens() {
	m.cache_read_tokens = nil
	m.addcache_read_tokens = nil
}

// SetCacheCreation5mTokens sets the "cache_creation_5m_tokens" field.
func (m *UsageLogMutation) SetCacheCreation5mTokens(i int) {
	m.cache_creation_5m_tokens = &i
	m.addcache_creation_5m_tokens = nil
}

// CacheCreation5mTokens returns the value of the "cache_creation_5m_tokens" field in the mutation.
func (m *UsageLogMutation) CacheCreation5mTokens() (r int, exists bool) {
	v := m.cache_creation_5m_tokens
	if v == nil {
		return
	}
	return *v, true
}

// OldCacheCreation5mTokens returns the old "cache_creation_5m_tokens" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldCacheCreation5mTokens(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCacheCreation5mTokens is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCacheCreation5mTokens requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCacheCreation5mTokens: %w", err)
	}
	return oldValue.CacheCreation5mTokens, nil
}

// AddCacheCreation5mTokens adds i to the "cache_creation_5m_tokens" field.
func (m *UsageLogMutation) AddCacheCreation5mTokens(i int) {
	if m.addcache_creation_5m_tokens != nil {
		*m.addcache_creation_5m_tokens += i
	} else {
		m.addcache_creation_5m_tokens = &i
	}
}

// AddedCacheCreation5mTokens returns the value that was added to the "cache_creation_5m_tokens" field in this mutation.
func (m *UsageLogMutation) AddedCacheCreation5mTokens() (r int, exists bool) {
	v := m.addcache_creation_5m_tokens
	if v == nil {
		return
	}
	return *v, true
}

// ResetCacheCreation5mTokens resets all changes to the "cache_creation_5m_tokens" field.
func (m *UsageLogMutation) ResetCacheCreation5mTokens() {
	m.cache_creation_5m_tokens = nil
	m.addcache_creation_5m_tokens = nil
}

// SetCacheCreation1hTokens sets the "cache_creation_1h_tokens" field.
func (m *UsageLogMutation) SetCacheCreation1hTokens(i int) {
	m.cache_creation_1h_tokens = &i
	m.addcache_creation_1h_tokens = nil
}

// CacheCreation1hTokens returns the value of the "cache_creation_1h_tokens" field in the mutation.
func (m *UsageLogMutation) CacheCreation1hTokens() (r int, exists bool) {
	v := m.cache_creation_1h_tokens
	if v == nil {
		return
	}
	return *v, true
}

// OldCacheCreation1hTokens returns the old "cache_creation_1h_tokens" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldCacheCreation1hTokens(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCacheCreation1hTokens is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCacheCreation1hTokens requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCacheCreation1hTokens: %w", err)
	}
	return oldValue.CacheCreation1hTokens, nil
}

// AddCacheCreation1hTokens adds i to the "cache_creation_1h_tokens" field.
func (m *UsageLogMutation) AddCacheCreation1hTokens(i int) {
	if m.addcache_creation_1h_tokens != nil {
		*m.addcache_creation_1h_tokens += i
	} else {
		m.addcache_creation_1h_tokens = &i
	}
}

// AddedCacheCreation1hTokens returns the value that was added to the "cache_creation_1h_tokens" field in this mutation.
func (m *UsageLogMutation) AddedCacheCreation1hTokens() (r int, exists bool) {
	v := m.addcache_creation_1h_tokens
	if v == nil {
		return
	}
	return *v, true
}

// ResetCacheCreation1hTokens resets all changes to the "cache_creation_1h_tokens" field.
func (m *UsageLogMutation) ResetCacheCreation1hTokens() {
	m.cache_creation_1h_tokens = nil
	m.addcache_creation_1h_tokens = nil
}

// SetInputCost sets the "input_cost" field.
func (m *UsageLogMutation) SetInputCost(f float64) {
	m.input_cost = &f
	m.addinput_cost = nil
}

// InputCost returns the value of the "input_cost" field in the mutation.
func (m *UsageLogMutation) InputCost() (r float64, exists bool) {
	v := m.input_cost
	if v == nil {
		return
	}
	return *v, true
}

// OldInputCost returns the old "input_cost" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldInputCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInputCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInputCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInputCost: %w", err)
	}
	return oldValue.InputCost, nil
}

// AddInputCost adds f to the "input_cost" field.
func (m *UsageLogMutation) AddInputCost(f float64) {
	if m.addinput_cost != nil {
		*m.addinput_cost += f
	} else {
		m.addinput_cost = &f
	}
}

// AddedInputCost returns the value that was added to the "input_cost" field in this mutation.
func (m *UsageLogMutation) AddedInputCost() (r float64, exists bool) {
	v := m.addinput_cost
	if v == nil {
		return
	}
	return *v, true
}

// ResetInputCost resets all changes to the "input_cost" field.
func (m *UsageLogMutation) ResetInputCost() {
	m.input_cost = nil
	m.addinput_cost = nil
}

// SetOutputCost sets the "output_cost" field.
func (m *UsageLogMutation) SetOutputCost(f float64) {
	m.output_cost = &f
	m.addoutput_cost = nil
}

// OutputCost returns the value of the "output_cost" field in the mutation.
func (m *UsageLogMutation) OutputCost() (r float64, exists bool) {
	v := m.output_cost
	if v == nil {
		return
	}
	return *v, true
}

// OldOutputCost returns the old "output_cost" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldOutputCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutputCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutputCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutputCost: %w", err)
	}
	return oldValue.OutputCost, nil
}

// AddOutputCost adds f to the "output_cost" field.
func (m *UsageLogMutation) AddOutputCost(f float64) {
	if m.addoutput_cost != nil {
		*m.addoutput_cost += f
	} else {
		m.addoutput_cost = &f
	}
}

// AddedOutputCost returns the value that was added to the "output_cost" field in this mutation.
func (m *UsageLogMutation) AddedOutputCost() (r float64, exists bool) {
	v := m.addoutput_cost
	if v == nil {
		return
	}
	return *v, true
}

// ResetOutputCost resets all changes to the "output_cost" field.
func (m *UsageLogMutation) ResetOutputCost() {
	m.output_cost = nil
	m.addoutput_cost = nil
}

// SetCacheCreationCost sets the "cache_creation_cost" field.
func (m *UsageLogMutation) SetCacheCreationCost(f float64) {
	m.cache_creation_cost = &f
	m.addcache_creation_cost = nil
}

// CacheCreationCost returns the value of the "cache_creation_cost" field in the mutation.
func (m *UsageLogMutation) CacheCreationCost() (r float64, exists bool) {
	v := m.cache_creation_cost
	if v == nil {
		return
	}
	return *v, true
}

// OldCacheCreationCost returns the old "cache_creation_cost" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldCacheCreationCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCacheCreationCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCacheCreationCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCacheCreationCost: %w", err)
	}
	return oldValue.CacheCreationCost, nil
}

// AddCacheCreationCost adds f to the "cache_creation_cost" field.
func (m *UsageLogMutation) AddCacheCreationCost(f float64) {
	if m.addcache_creation_cost != nil {
		*m.addcache_creation_cost += f
	} else {
		m.addcache_creation_cost = &f
	}
}

// AddedCacheCreationCost returns the value that was added to the "cache_creation_cost" field in this mutation.
func (m *UsageLogMutation) AddedCacheCreationCost() (r float64, exists bool) {
	v := m.addcache_creation_cost
	if v == nil {
		return
	}
	return *v, true
}

// ResetCacheCreationCost resets all changes to the "cache_creation_cost" field.
func (m *UsageLogMutation) ResetCacheCreationCost() {
	m.cache_creation_cost = nil
	m.addcache_creation_cost = nil
}

// SetCacheReadCost sets the "cache_read_cost" field.
func (m *UsageLogMutation) SetCacheReadCost(f float64) {
	m.cache_read_cost = &f
	m.addcache_read_cost = nil
}

// CacheReadCost returns the value of the "cache_read_cost" field in the mutation.
func (m *UsageLogMutation) CacheReadCost() (r float64, exists bool) {
	v := m.cache_read_cost
	if v == nil {
		return
	}
	return *v, true
}

// OldCacheReadCost returns the old "cache_read_cost" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldCacheReadCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCacheReadCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCacheReadCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCacheReadCost: %w", err)
	}
	return oldValue.CacheReadCost, nil
}

// AddCacheReadCost adds f to the "cache_read_cost" field.
func (m *UsageLogMutation) AddCacheReadCost(f float64) {
	if m.addcache_read_cost != nil {
		*m.addcache_read_cost += f
	} else {
		m.addcache_read_cost = &f
	}
}

// AddedCacheReadCost returns the value that was added to the "cache_read_cost" field in this mutation.
func (m *UsageLogMutation) AddedCacheReadCost() (r float64, exists bool) {
	v := m.addcache_read_cost
	if v == nil {
		return
	}
	return *v, true
}

// ResetCacheReadCost resets all changes to the "cache_read_cost" field.
func (m *UsageLogMutation) ResetCacheReadCost() {
	m.cache_read_cost = nil
	m.addcache_read_cost = nil
}

// SetTotalCost sets the "total_cost" field.
func (m *UsageLogMutation) SetTotalCost(f float64) {
	m.total_cost = &f
	m.addtotal_cost = nil
}

// TotalCost returns the value of the "total_cost" field in the mutation.
func (m *UsageLogMutation) TotalCost() (r float64, exists bool) {
	v := m.total_cost
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalCost returns the old "total_cost" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldTotalCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalCost: %w", err)
	}
	return oldValue.TotalCost, nil
}

// AddTotalCost adds f to the "total_cost" field.
func (m *UsageLogMutation) AddTotalCost(f float64) {
	if m.addtotal_cost != nil {
		*m.addtotal_cost += f
	} else {
		m.addtotal_cost = &f
	}
}

// AddedTotalCost returns the value that was added to the "total_cost" field in this mutation.
func (m *UsageLogMutation) AddedTotalCost() (r float64, exists bool) {
	v := m.addtotal_cost
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalCost resets all changes to the "total_cost" field.
func (m *UsageLogMutation) ResetTotalCost() {
	m.total_cost = nil
	m.addtotal_cost = nil
}

// SetActualCost sets the "actual_cost" field.
func (m *UsageLogMutation) SetActualCost(f float64) {
	m.actual_cost = &f
	m.addactual_cost = nil
}

// ActualCost returns the value of the "actual_cost" field in the mutation.
func (m *UsageLogMutation) ActualCost() (r float64, exists bool) {
	v := m.actual_cost
	if v == nil {
		return
	}
	return *v, true
}

// OldActualCost returns the old "actual_cost" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldActualCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActualCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActualCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActualCost: %w", err)
	}
	return oldValue.ActualCost, nil
}

// AddActualCost adds f to the "actual_cost" field.
func (m *UsageLogMutation) AddActualCost(f float64) {
	if m.addactual_cost != nil {
		*m.addactual_cost += f
	} else {
		m.addactual_cost = &f
	}
}

// AddedActualCost returns the value that was added to the "actual_cost" field in this mutation.
func (m *UsageLogMutation) AddedActualCost() (r float64, exists bool) {
	v := m.addactual_cost
	if v == nil {
		return
	}
	return *v, true
}

// ResetActualCost resets all changes to the "actual_cost" field.
func (m *UsageLogMutation) ResetActualCost() {
	m.actual_cost = nil
	m.addactual_cost = nil
}

// SetRateMultiplier sets the "rate_multiplier" field.
func (m *UsageLogMutation) SetRateMultiplier(f float64) {
	m.rate_multiplier = &f
	m.addrate_multiplier = nil
}

// RateMultiplier returns the value of the "rate_multiplier" field in the mutation.
func (m *UsageLogMutation) RateMultiplier() (r float64, exists bool) {
	v := m.rate_multiplier
	if v == nil {
		return
	}
	return *v, true
}

// OldRateMultiplier returns the old "rate_multiplier" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldRateMultiplier(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRateMultiplier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRateMultiplier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRateMultiplier: %w", err)
	}
	return oldValue.RateMultiplier, nil
}

// AddRateMultiplier adds f to the "rate_multiplier" field.
func (m *UsageLogMutation) AddRateMultiplier(f float64) {
	if m.addrate_multiplier != nil {
		*m.addrate_multiplier += f
	} else {
		m.addrate_multiplier = &f
	}
}

// AddedRateMultiplier returns the value that was added to the "rate_multiplier" field in this mutation.
func (m *UsageLogMutation) AddedRateMultiplier() (r float64, exists bool) {
	v := m.addrate_multiplier
	if v == nil {
		return
	}
	return *v, true
}

// ResetRateMultiplier resets all changes to the "rate_multiplier" field.
func (m *UsageLogMutation) ResetRateMultiplier() {
	m.rate_multiplier = nil
	m.addrate_multiplier = nil
}

// SetAccountRateMultiplier sets the "account_rate_multiplier" field.
func (m *UsageLogMutation) SetAccountRateMultiplier(f float64) {
	m.account_rate_multiplier = &f
	m.addaccount_rate_multiplier = nil
}

// AccountRateMultiplier returns the value of the "account_rate_multiplier" field in the mutation.
func (m *UsageLogMutation) AccountRateMultiplier() (r float64, exists bool) {
	v := m.account_rate_multiplier
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountRateMultiplier returns the old "account_rate_multiplier" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldAccountRateMultiplier(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountRateMultiplier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountRateMultiplier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountRateMultiplier: %w", err)
	}
	return oldValue.AccountRateMultiplier, nil
}

// AddAccountRateMultiplier adds f to the "account_rate_multiplier" field.
func (m *UsageLogMutation) AddAccountRateMultiplier(f float64) {
	if m.addaccount_rate_multiplier != nil {
		*m.addaccount_rate_multiplier += f
	} else {
		m.addaccount_rate_multiplier = &f
	}
}

// AddedAccountRateMultiplier returns the value that was added to the "account_rate_multiplier" field in this mutation.
func (m *UsageLogMutation) AddedAccountRateMultiplier() (r float64, exists bool) {
	v := m.addaccount_rate_multiplier
	if v == nil {
		return
	}
	return *v, true
}

// ClearAccountRateMultiplier clears the value of the "account_rate_multiplier" field.
func (m *UsageLogMutation) ClearAccountRateMultiplier() {
	m.account_rate_multiplier = nil
	m.addaccount_rate_multiplier = nil
	m.clearedFields[usagelog.FieldAccountRateMultiplier] = struct{}{}
}

// AccountRateMultiplierCleared returns if the "account_rate_multiplier" field was cleared in this mutation.
func (m *UsageLogMutation) AccountRateMultiplierCleared() bool {
	_, ok := m.clearedFields[usagelog.FieldAccountRateMultiplier]
	return ok
}

// ResetAccountRateMultiplier resets all changes to the "account_rate_multiplier" field.
func (m *UsageLogMutation) ResetAccountRateMultiplier() {
	m.account_rate_multiplier = nil
	m.addaccount_rate_multiplier = nil
	delete(m.clearedFields, usagelog.FieldAccountRateMultiplier)
}

// SetBillingType sets the "billing_type" field.
func (m *UsageLogMutation) SetBillingType(i int8) {
	m.billing_type = &i
	m.addbilling_type = nil
}

// BillingType returns the value of the "billing_type" field in the mutation.
func (m *UsageLogMutation) BillingType() (r int8, exists bool) {
	v := m.billing_type
	if v == nil {
		return
	}
	return *v, true
}

// OldBillingType returns the old "billing_type" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldBillingType(ctx context.Context) (v int8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBillingType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBillingType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillingType: %w", err)
	}
	return oldValue.BillingType, nil
}

// AddBillingType adds i to the "billing_type" field.
func (m *UsageLogMutation) AddBillingType(i int8) {
	if m.addbilling_type != nil {
		*m.addbilling_type += i
	} else {
		m.addbilling_type = &i
	}
}

// AddedBillingType returns the value that was added to the "billing_type" field in this mutation.
func (m *UsageLogMutation) AddedBillingType() (r int8, exists bool) {
	v := m.addbilling_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetBillingType resets all changes to the "billing_type" field.
func (m *UsageLogMutation) ResetBillingType() {
	m.billing_type = nil
	m.addbilling_type = nil
}

// SetStream sets the "stream" field.
func (m *UsageLogMutation) SetStream(b bool) {
	m.stream = &b
}

// Stream returns the value of the "stream" field in the mutation.
func (m *UsageLogMutation) Stream() (r bool, exists bool) {
	v := m.stream
	if v == nil {
		return
	}
	return *v, true
}

// OldStream returns the old "stream" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldStream(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStream is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStream requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStream: %w", err)
	}
	return oldValue.Stream, nil
}

// ResetStream resets all changes to the "stream" field.
func (m *UsageLogMutation) ResetStream() {
	m.stream = nil
}

// SetDurationMs sets the "duration_ms" field.
func (m *UsageLogMutation) SetDurationMs(i int) {
	m.duration_ms = &i
	m.addduration_ms = nil
}

// DurationMs returns the value of the "duration_ms" field in the mutation.
func (m *UsageLogMutation) DurationMs() (r int, exists bool) {
	v := m.duration_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldDurationMs returns the old "duration_ms" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldDurationMs(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDurationMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDurationMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDurationMs: %w", err)
	}
	return oldValue.DurationMs, nil
}

// AddDurationMs adds i to the "duration_ms" field.
func (m *UsageLogMutation) AddDurationMs(i int) {
	if m.addduration_ms != nil {
		*m.addduration_ms += i
	} else {
		m.addduration_ms = &i
	}
}

// AddedDurationMs returns the value that was added to the "duration_ms" field in this mutation.
func (m *UsageLogMutation) AddedDurationMs() (r int, exists bool) {
	v := m.addduration_ms
	if v == nil {
		return
	}
	return *v, true
}

// ClearDurationMs clears the value of the "duration_ms" field.
func (m *UsageLogMutation) ClearDurationMs() {
	m.duration_ms = nil
	m.addduration_ms = nil
	m.clearedFields[usagelog.FieldDurationMs] = struct{}{}
}

// DurationMsCleared returns if the "duration_ms" field was cleared in this mutation.
func (m *UsageLogMutation) DurationMsCleared() bool {
	_, ok := m.clearedFields[usagelog.FieldDurationMs]
	return ok
}

// ResetDurationMs resets all changes to the "duration_ms" field.
func (m *UsageLogMutation) ResetDurationMs() {
	m.duration_ms = nil
	m.addduration_ms = nil
	delete(m.clearedFields, usagelog.FieldDurationMs)
}

// SetFirstTokenMs sets the "first_token_ms" field.
func (m *UsageLogMutation) SetFirstTokenMs(i int) {
	m.first_token_ms = &i
	m.addfirst_token_ms = nil
}

// FirstTokenMs returns the value of the "first_token_ms" field in the mutation.
func (m *UsageLogMutation) FirstTokenMs() (r int, exists bool) {
	v := m.first_token_ms
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstTokenMs returns the old "first_token_ms" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldFirstTokenMs(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstTokenMs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstTokenMs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstTokenMs: %w", err)
	}
	return oldValue.FirstTokenMs, nil
}

// AddFirstTokenMs adds i to the "first_token_ms" field.
func (m *UsageLogMutation) AddFirstTokenMs(i int) {
	if m.addfirst_token_ms != nil {
		*m.addfirst_token_ms += i
	} else {
		m.addfirst_token_ms = &i
	}
}

// AddedFirstTokenMs returns the value that was added to the "first_token_ms" field in this mutation.
func (m *UsageLogMutation) AddedFirstTokenMs() (r int, exists bool) {
	v := m.addfirst_token_ms
	if v == nil {
		return
	}
	return *v, true
}

// ClearFirstTokenMs clears the value of the "first_token_ms" field.
func (m *UsageLogMutation) ClearFirstTokenMs() {
	m.first_token_ms = nil
	m.addfirst_token_ms = nil
	m.clearedFields[usagelog.FieldFirstTokenMs] = struct{}{}
}

// FirstTokenMsCleared returns if the "first_token_ms" field was cleared in this mutation.
func (m *UsageLogMutation) FirstTokenMsCleared() bool {
	_, ok := m.clearedFields[usagelog.FieldFirstTokenMs]
	return ok
}

// ResetFirstTokenMs resets all changes to the "first_token_ms" field.
func (m *UsageLogMutation) ResetFirstTokenMs() {
	m.first_token_ms = nil
	m.addfirst_token_ms = nil
	delete(m.clearedFields, usagelog.FieldFirstTokenMs)
}

// SetUserAgent sets the "user_agent" field.
func (m *UsageLogMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *UsageLogMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldUserAgent(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *UsageLogMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[usagelog.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *UsageLogMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[usagelog.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *UsageLogMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, usagelog.FieldUserAgent)
}

// SetIPAddress sets the "ip_address" field.
func (m *UsageLogMutation) SetIPAddress(s string) {
	m.ip_address = &s
}

// IPAddress returns the value of the "ip_address" field in the mutation.
func (m *UsageLogMutation) IPAddress() (r string, exists bool) {
	v := m.ip_address
	if v == nil {
		return
	}
	return *v, true
}

// OldIPAddress returns the old "ip_address" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldIPAddress(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIPAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIPAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIPAddress: %w", err)
	}
	return oldValue.IPAddress, nil
}

// ClearIPAddress clears the value of the "ip_address" field.
func (m *UsageLogMutation) ClearIPAddress() {
	m.ip_address = nil
	m.clearedFields[usagelog.FieldIPAddress] = struct{}{}
}

// IPAddressCleared returns if the "ip_address" field was cleared in this mutation.
func (m *UsageLogMutation) IPAddressCleared() bool {
	_, ok := m.clearedFields[usagelog.FieldIPAddress]
	return ok
}

// ResetIPAddress resets all changes to the "ip_address" field.
func (m *UsageLogMutation) ResetIPAddress() {
	m.ip_address = nil
	delete(m.clearedFields, usagelog.FieldIPAddress)
}

// SetImageCount sets the "image_count" field.
func (m *UsageLogMutation) SetImageCount(i int) {
	m.image_count = &i
	m.addimage_count = nil
}

// ImageCount returns the value of the "image_count" field in the mutation.
func (m *UsageLogMutation) ImageCount() (r int, exists bool) {
	v := m.image_count
	if v == nil {
		return
	}
	return *v, true
}

// OldImageCount returns the old "image_count" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldImageCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImageCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImageCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImageCount: %w", err)
	}
	return oldValue.ImageCount, nil
}

// AddImageCount adds i to the "image_count" field.
func (m *UsageLogMutation) AddImageCount(i int) {
	if m.addimage_count != nil {
		*m.addimage_count += i
	} else {
		m.addimage_count = &i
	}
}

// AddedImageCount returns the value that was added to the "image_count" field in this mutation.
func (m *UsageLogMutation) AddedImageCount() (r int, exists bool) {
	v := m.addimage_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetImageCount resets all changes to the "image_count" field.
func (m *UsageLogMutation) ResetImageCount() {
	m.image_count = nil
	m.addimage_count = nil
}

// SetImageSize sets the "image_size" field.
func (m *UsageLogMutation) SetImageSize(s string) {
	m.image_size = &s
}

// ImageSize returns the value of the "image_size" field in the mutation.
func (m *UsageLogMutation) ImageSize() (r string, exists bool) {
	v := m.image_size
	if v == nil {
		return
	}
	return *v, true
}

// OldImageSize returns the old "image_size" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldImageSize(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImageSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImageSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImageSize: %w", err)
	}
	return oldValue.ImageSize, nil
}

// ClearImageSize clears the value of the "image_size" field.
func (m *UsageLogMutation) ClearImageSize() {
	m.image_size = nil
	m.clearedFields[usagelog.FieldImageSize] = struct{}{}
}

// ImageSizeCleared returns if the "image_size" field was cleared in this mutation.
func (m *UsageLogMutation) ImageSizeCleared() bool {
	_, ok := m.clearedFields[usagelog.FieldImageSize]
	return ok
}

// ResetImageSize resets all changes to the "image_size" field.
func (m *UsageLogMutation) ResetImageSize() {
	m.image_size = nil
	delete(m.clearedFields, usagelog.FieldImageSize)
}

// SetCreatedAt sets the "created_at" field.
func (m *UsageLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UsageLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UsageLog entity.
// If the UsageLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UsageLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UsageLogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *UsageLogMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[usagelog.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UsageLogMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UsageLogMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UsageLogMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearAPIKey clears the "api_key" edge to the APIKey entity.
func (m *UsageLogMutation) ClearAPIKey() {
	m.clearedapi_key = true
	m.clearedFields[usagelog.FieldAPIKeyID] = struct{}{}
}

// APIKeyCleared reports if the "api_key" edge to the APIKey entity was cleared.
func (m *UsageLogMutation) APIKeyCleared() bool {
	return m.clearedapi_key
}

// APIKeyIDs returns the "api_key" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// APIKeyID instead. It exists only for internal usage by the builders.
func (m *UsageLogMutation) APIKeyIDs() (ids []int64) {
	if id := m.api_key; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAPIKey resets all changes to the "api_key" edge.
func (m *UsageLogMutation) ResetAPIKey() {
	m.api_key = nil
	m.clearedapi_key = false
}

// ClearAccount clears the "account" edge to the Account entity.
func (m *UsageLogMutation) ClearAccount() {
	m.clearedaccount = true
	m.clearedFields[usagelog.FieldAccountID] = struct{}{}
}

// AccountCleared reports if the "account" edge to the Account entity was cleared.
func (m *UsageLogMutation) AccountCleared() bool {
	return m.clearedaccount
}

// AccountIDs returns the "account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountID instead. It exists only for internal usage by the builders.
func (m *UsageLogMutation) AccountIDs() (ids []int64) {
	if id := m.account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccount resets all changes to the "account" edge.
func (m *UsageLogMutation) ResetAccount() {
	m.account = nil
	m.clearedaccount = false
}

// ClearGroup clears the "group" edge to the Group entity.
func (m *UsageLogMutation) ClearGroup() {
	m.clearedgroup = true
	m.clearedFields[usagelog.FieldGroupID] = struct{}{}
}

// GroupCleared reports if the "group" edge to the Group entity was cleared.
func (m *UsageLogMutation) GroupCleared() bool {
	return m.GroupIDCleared() || m.clearedgroup
}

// GroupIDs returns the "group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupID instead. It exists only for internal usage by the builders.
func (m *UsageLogMutation) GroupIDs() (ids []int64) {
	if id := m.group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroup resets all changes to the "group" edge.
func (m *UsageLogMutation) ResetGroup() {
	m.group = nil
	m.clearedgroup = false
}

// ClearSubscription clears the "subscription" edge to the UserSubscription entity.
func (m *UsageLogMutation) ClearSubscription() {
	m.clearedsubscription = true
	m.clearedFields[usagelog.FieldSubscriptionID] = struct{}{}
}

// SubscriptionCleared reports if the "subscription" edge to the UserSubscription entity was cleared.
func (m *UsageLogMutation) SubscriptionCleared() bool {
	return m.SubscriptionIDCleared() || m.clearedsubscription
}

// SubscriptionIDs returns the "subscription" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubscriptionID instead. It exists only for internal usage by the builders.
func (m *UsageLogMutation) SubscriptionIDs() (ids []int64) {
	if id := m.subscription; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubscription resets all changes to the "subscription" edge.
func (m *UsageLogMutation) ResetSubscription() {
	m.subscription = nil
	m.clearedsubscription = false
}

// Where appends a list predicates to the UsageLogMutation builder.
func (m *UsageLogMutation) Where(ps ...predicate.UsageLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UsageLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UsageLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UsageLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UsageLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UsageLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UsageLog).
func (m *UsageLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UsageLogMutation) Fields() []string {
	fields := make([]string, 0, 30)
	if m.user != nil {
		fields = append(fields, usagelog.FieldUserID)
	}
	if m.api_key != nil {
		fields = append(fields, usagelog.FieldAPIKeyID)
	}
	if m.account != nil {
		fields = append(fields, usagelog.FieldAccountID)
	}
	if m.request_id != nil {
		fields = append(fields, usagelog.FieldRequestID)
	}
	if m.model != nil {
		fields = append(fields, usagelog.FieldModel)
	}
	if m.group != nil {
		fields = append(fields, usagelog.FieldGroupID)
	}
	if m.subscription != nil {
		fields = append(fields, usagelog.FieldSubscriptionID)
	}
	if m.input_tokens != nil {
		fields = append(fields, usagelog.FieldInputTokens)
	}
	if m.output_tokens != nil {
		fields = append(fields, usagelog.FieldOutputTokens)
	}
	if m.cache_creation_tokens != nil {
		fields = append(fields, usagelog.FieldCacheCreationTokens)
	}
	if m.cache_read_tokens != nil {
		fields = append(fields, usagelog.FieldCacheReadTokens)
	}
	if m.cache_creation_5m_tokens != nil {
		fields = append(fields, usagelog.FieldCacheCreation5mTokens)
	}
	if m.cache_creation_1h_tokens != nil {
		fields = append(fields, usagelog.FieldCacheCreation1hTokens)
	}
	if m.input_cost != nil {
		fields = append(fields, usagelog.FieldInputCost)
	}
	if m.output_cost != nil {
		fields = append(fields, usagelog.FieldOutputCost)
	}
	if m.cache_creation_cost != nil {
		fields = append(fields, usagelog.FieldCacheCreationCost)
	}
	if m.cache_read_cost != nil {
		fields = append(fields, usagelog.FieldCacheReadCost)
	}
	if m.total_cost != nil {
		fields = append(fields, usagelog.FieldTotalCost)
	}
	if m.actual_cost != nil {
		fields = append(fields, usagelog.FieldActualCost)
	}
	if m.rate_multiplier != nil {
		fields = append(fields, usagelog.FieldRateMultiplier)
	}
	if m.account_rate_multiplier != nil {
		fields = append(fields, usagelog.FieldAccountRateMultiplier)
	}
	if m.billing_type != nil {
		fields = append(fields, usagelog.FieldBillingType)
	}
	if m.stream != nil {
		fields = append(fields, usagelog.FieldStream)
	}
	if m.duration_ms != nil {
		fields = append(fields, usagelog.FieldDurationMs)
	}
	if m.first_token_ms != nil {
		fields = append(fields, usagelog.FieldFirstTokenMs)
	}
	if m.user_agent != nil {
		fields = append(fields, usagelog.FieldUserAgent)
	}
	if m.ip_address != nil {
		fields = append(fields, usagelog.FieldIPAddress)
	}
	if m.image_count != nil {
		fields = append(fields, usagelog.FieldImageCount)
	}
	if m.image_size != nil {
		fields = append(fields, usagelog.FieldImageSize)
	}
	if m.created_at != nil {
		fields = append(fields, usagelog.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UsageLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usagelog.FieldUserID:
		return m.UserID()
	case usagelog.FieldAPIKeyID:
		return m.APIKeyID()
	case usagelog.FieldAccountID:
		return m.AccountID()
	case usagelog.FieldRequestID:
		return m.RequestID()
	case usagelog.FieldModel:
		return m.Model()
	case usagelog.FieldGroupID:
		return m.GroupID()
	case usagelog.FieldSubscriptionID:
		return m.SubscriptionID()
	case usagelog.FieldInputTokens:
		return m.InputTokens()
	case usagelog.FieldOutputTokens:
		return m.OutputTokens()
	case usagelog.FieldCacheCreationTokens:
		return m.CacheCreationTokens()
	case usagelog.FieldCacheReadTokens:
		return m.CacheReadTokens()
	case usagelog.FieldCacheCreation5mTokens:
		return m.CacheCreation5mTokens()
	case usagelog.FieldCacheCreation1hTokens:
		return m.CacheCreation1hTokens()
	case usagelog.FieldInputCost:
		return m.InputCost()
	case usagelog.FieldOutputCost:
		return m.OutputCost()
	case usagelog.FieldCacheCreationCost:
		return m.CacheCreationCost()
	case usagelog.FieldCacheReadCost:
		return m.CacheReadCost()
	case usagelog.FieldTotalCost:
		return m.TotalCost()
	case usagelog.FieldActualCost:
		return m.ActualCost()
	case usagelog.FieldRateMultiplier:
		return m.RateMultiplier()
	case usagelog.FieldAccountRateMultiplier:
		return m.AccountRateMultiplier()
	case usagelog.FieldBillingType:
		return m.BillingType()
	case usagelog.FieldStream:
		return m.Stream()
	case usagelog.FieldDurationMs:
		return m.DurationMs()
	case usagelog.FieldFirstTokenMs:
		return m.FirstTokenMs()
	case usagelog.FieldUserAgent:
		return m.UserAgent()
	case usagelog.FieldIPAddress:
		return m.IPAddress()
	case usagelog.FieldImageCount:
		return m.ImageCount()
	case usagelog.FieldImageSize:
		return m.ImageSize()
	case usagelog.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UsageLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usagelog.FieldUserID:
		return m.OldUserID(ctx)
	case usagelog.FieldAPIKeyID:
		return m.OldAPIKeyID(ctx)
	case usagelog.FieldAccountID:
		return m.OldAccountID(ctx)
	case usagelog.FieldRequestID:
		return m.OldRequestID(ctx)
	case usagelog.FieldModel:
		return m.OldModel(ctx)
	case usagelog.FieldGroupID:
		return m.OldGroupID(ctx)
	case usagelog.FieldSubscriptionID:
		return m.OldSubscriptionID(ctx)
	case usagelog.FieldInputTokens:
		return m.OldInputTokens(ctx)
	case usagelog.FieldOutputTokens:
		return m.OldOutputTokens(ctx)
	case usagelog.FieldCacheCreationTokens:
		return m.OldCacheCreationTokens(ctx)
	case usagelog.FieldCacheReadTokens:
		return m.OldCacheReadTokens(ctx)
	case usagelog.FieldCacheCreation5mTokens:
		return m.OldCacheCreation5mTokens(ctx)
	case usagelog.FieldCacheCreation1hTokens:
		return m.OldCacheCreation1hTokens(ctx)
	case usagelog.FieldInputCost:
		return m.OldInputCost(ctx)
	case usagelog.FieldOutputCost:
		return m.OldOutputCost(ctx)
	case usagelog.FieldCacheCreationCost:
		return m.OldCacheCreationCost(ctx)
	case usagelog.FieldCacheReadCost:
		return m.OldCacheReadCost(ctx)
	case usagelog.FieldTotalCost:
		return m.OldTotalCost(ctx)
	case usagelog.FieldActualCost:
		return m.OldActualCost(ctx)
	case usagelog.FieldRateMultiplier:
		return m.OldRateMultiplier(ctx)
	case usagelog.FieldAccountRateMultiplier:
		return m.OldAccountRateMultiplier(ctx)
	case usagelog.FieldBillingType:
		return m.OldBillingType(ctx)
	case usagelog.FieldStream:
		return m.OldStream(ctx)
	case usagelog.FieldDurationMs:
		return m.OldDurationMs(ctx)
	case usagelog.FieldFirstTokenMs:
		return m.OldFirstTokenMs(ctx)
	case usagelog.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case usagelog.FieldIPAddress:
		return m.OldIPAddress(ctx)
	case usagelog.FieldImageCount:
		return m.OldImageCount(ctx)
	case usagelog.FieldImageSize:
		return m.OldImageSize(ctx)
	case usagelog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UsageLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UsageLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usagelog.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case usagelog.FieldAPIKeyID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIKeyID(v)
		return nil
	case usagelog.FieldAccountID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case usagelog.FieldRequestID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestID(v)
		return nil
	case usagelog.FieldModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	case usagelog.FieldGroupID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupID(v)
		return nil
	case usagelog.FieldSubscriptionID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscriptionID(v)
		return nil
	case usagelog.FieldInputTokens:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInputTokens(v)
		return nil
	case usagelog.FieldOutputTokens:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutputTokens(v)
		return nil
	case usagelog.FieldCacheCreationTokens:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCacheCreationTokens(v)
		return nil
	case usagelog.FieldCacheReadTokens:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCacheReadTokens(v)
		return nil
	case usagelog.FieldCacheCreation5mTokens:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCacheCreation5mTokens(v)
		return nil
	case usagelog.FieldCacheCreation1hTokens:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCacheCreation1hTokens(v)
		return nil
	case usagelog.FieldInputCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInputCost(v)
		return nil
	case usagelog.FieldOutputCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutputCost(v)
		return nil
	case usagelog.FieldCacheCreationCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCacheCreationCost(v)
		return nil
	case usagelog.FieldCacheReadCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCacheReadCost(v)
		return nil
	case usagelog.FieldTotalCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalCost(v)
		return nil
	case usagelog.FieldActualCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActualCost(v)
		return nil
	case usagelog.FieldRateMultiplier:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRateMultiplier(v)
		return nil
	case usagelog.FieldAccountRateMultiplier:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountRateMultiplier(v)
		return nil
	case usagelog.FieldBillingType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillingType(v)
		return nil
	case usagelog.FieldStream:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStream(v)
		return nil
	case usagelog.FieldDurationMs:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDurationMs(v)
		return nil
	case usagelog.FieldFirstTokenMs:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstTokenMs(v)
		return nil
	case usagelog.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case usagelog.FieldIPAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIPAddress(v)
		return nil
	case usagelog.FieldImageCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImageCount(v)
		return nil
	case usagelog.FieldImageSize:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImageSize(v)
		return nil
	case usagelog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UsageLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UsageLogMutation) AddedFields() []string {
	var fields []string
	if m.addinput_tokens != nil {
		fields = append(fields, usagelog.FieldInputTokens)
	}
	if m.addoutput_tokens != nil {
		fields = append(fields, usagelog.FieldOutputTokens)
	}
	if m.addcache_creation_tokens != nil {
		fields = append(fields, usagelog.FieldCacheCreationTokens)
	}
	if m.addcache_read_tokens != nil {
		fields = append(fields, usagelog.FieldCacheReadTokens)
	}
	if m.addcache_creation_5m_tokens != nil {
		fields = append(fields, usagelog.FieldCacheCreation5mTokens)
	}
	if m.addcache_creation_1h_tokens != nil {
		fields = append(fields, usagelog.FieldCacheCreation1hTokens)
	}
	if m.addinput_cost != nil {
		fields = append(fields, usagelog.FieldInputCost)
	}
	if m.addoutput_cost != nil {
		fields = append(fields, usagelog.FieldOutputCost)
	}
	if m.addcache_creation_cost != nil {
		fields = append(fields, usagelog.FieldCacheCreationCost)
	}
	if m.addcache_read_cost != nil {
		fields = append(fields, usagelog.FieldCacheReadCost)
	}
	if m.addtotal_cost != nil {
		fields = append(fields, usagelog.FieldTotalCost)
	}
	if m.addactual_cost != nil {
		fields = append(fields, usagelog.FieldActualCost)
	}
	if m.addrate_multiplier != nil {
		fields = append(fields, usagelog.FieldRateMultiplier)
	}
	if m.addaccount_rate_multiplier != nil {
		fields = append(fields, usagelog.FieldAccountRateMultiplier)
	}
	if m.addbilling_type != nil {
		fields = append(fields, usagelog.FieldBillingType)
	}
	if m.addduration_ms != nil {
		fields = append(fields, usagelog.FieldDurationMs)
	}
	if m.addfirst_token_ms != nil {
		fields = append(fields, usagelog.FieldFirstTokenMs)
	}
	if m.addimage_count != nil {
		fields = append(fields, usagelog.FieldImageCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UsageLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case usagelog.FieldInputTokens:
		return m.AddedInputTokens()
	case usagelog.FieldOutputTokens:
		return m.AddedOutputTokens()
	case usagelog.FieldCacheCreationTokens:
		return m.AddedCacheCreationTokens()
	case usagelog.FieldCacheReadTokens:
		return m.AddedCacheReadTokens()
	case usagelog.FieldCacheCreation5mTokens:
		return m.AddedCacheCreation5mTokens()
	case usagelog.FieldCacheCreation1hTokens:
		return m.AddedCacheCreation1hTokens()
	case usagelog.FieldInputCost:
		return m.AddedInputCost()
	case usagelog.FieldOutputCost:
		return m.AddedOutputCost()
	case usagelog.FieldCacheCreationCost:
		return m.AddedCacheCreationCost()
	case usagelog.FieldCacheReadCost:
		return m.AddedCacheReadCost()
	case usagelog.FieldTotalCost:
		return m.AddedTotalCost()
	case usagelog.FieldActualCost:
		return m.AddedActualCost()
	case usagelog.FieldRateMultiplier:
		return m.AddedRateMultiplier()
	case usagelog.FieldAccountRateMultiplier:
		return m.AddedAccountRateMultiplier()
	case usagelog.FieldBillingType:
		return m.AddedBillingType()
	case usagelog.FieldDurationMs:
		return m.AddedDurationMs()
	case usagelog.FieldFirstTokenMs:
		return m.AddedFirstTokenMs()
	case usagelog.FieldImageCount:
		return m.AddedImageCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UsageLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case usagelog.FieldInputTokens:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInputTokens(v)
		return nil
	case usagelog.FieldOutputTokens:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOutputTokens(v)
		return nil
	case usagelog.FieldCacheCreationTokens:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCacheCreationTokens(v)
		return nil
	case usagelog.FieldCacheReadTokens:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCacheReadTokens(v)
		return nil
	case usagelog.FieldCacheCreation5mTokens:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCacheCreation5mTokens(v)
		return nil
	case usagelog.FieldCacheCreation1hTokens:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCacheCreation1hTokens(v)
		return nil
	case usagelog.FieldInputCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInputCost(v)
		return nil
	case usagelog.FieldOutputCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOutputCost(v)
		return nil
	case usagelog.FieldCacheCreationCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCacheCreationCost(v)
		return nil
	case usagelog.FieldCacheReadCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCacheReadCost(v)
		return nil
	case usagelog.FieldTotalCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalCost(v)
		return nil
	case usagelog.FieldActualCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddActualCost(v)
		return nil
	case usagelog.FieldRateMultiplier:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRateMultiplier(v)
		return nil
	case usagelog.FieldAccountRateMultiplier:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAccountRateMultiplier(v)
		return nil
	case usagelog.FieldBillingType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBillingType(v)
		return nil
	case usagelog.FieldDurationMs:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDurationMs(v)
		return nil
	case usagelog.FieldFirstTokenMs:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFirstTokenMs(v)
		return nil
	case usagelog.FieldImageCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddImageCount(v)
		return nil
	}
	return fmt.Errorf("unknown UsageLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UsageLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(usagelog.FieldGroupID) {
		fields = append(fields, usagelog.FieldGroupID)
	}
	if m.FieldCleared(usagelog.FieldSubscriptionID) {
		fields = append(fields, usagelog.FieldSubscriptionID)
	}
	if m.FieldCleared(usagelog.FieldAccountRateMultiplier) {
		fields = append(fields, usagelog.FieldAccountRateMultiplier)
	}
	if m.FieldCleared(usagelog.FieldDurationMs) {
		fields = append(fields, usagelog.FieldDurationMs)
	}
	if m.FieldCleared(usagelog.FieldFirstTokenMs) {
		fields = append(fields, usagelog.FieldFirstTokenMs)
	}
	if m.FieldCleared(usagelog.FieldUserAgent) {
		fields = append(fields, usagelog.FieldUserAgent)
	}
	if m.FieldCleared(usagelog.FieldIPAddress) {
		fields = append(fields, usagelog.FieldIPAddress)
	}
	if m.FieldCleared(usagelog.FieldImageSize) {
		fields = append(fields, usagelog.FieldImageSize)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UsageLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UsageLogMutation) ClearField(name string) error {
	switch name {
	case usagelog.FieldGroupID:
		m.ClearGroupID()
		return nil
	case usagelog.FieldSubscriptionID:
		m.ClearSubscriptionID()
		return nil
	case usagelog.FieldAccountRateMultiplier:
		m.ClearAccountRateMultiplier()
		return nil
	case usagelog.FieldDurationMs:
		m.ClearDurationMs()
		return nil
	case usagelog.FieldFirstTokenMs:
		m.ClearFirstTokenMs()
		return nil
	case usagelog.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case usagelog.FieldIPAddress:
		m.ClearIPAddress()
		return nil
	case usagelog.FieldImageSize:
		m.ClearImageSize()
		return nil
	}
	return fmt.Errorf("unknown UsageLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UsageLogMutation) ResetField(name string) error {
	switch name {
	case usagelog.FieldUserID:
		m.ResetUserID()
		return nil
	case usagelog.FieldAPIKeyID:
		m.ResetAPIKeyID()
		return nil
	case usagelog.FieldAccountID:
		m.ResetAccountID()
		return nil
	case usagelog.FieldRequestID:
		m.ResetRequestID()
		return nil
	case usagelog.FieldModel:
		m.ResetModel()
		return nil
	case usagelog.FieldGroupID:
		m.ResetGroupID()
		return nil
	case usagelog.FieldSubscriptionID:
		m.ResetSubscriptionID()
		return nil
	case usagelog.FieldInputTokens:
		m.ResetInputTokens()
		return nil
	case usagelog.FieldOutputTokens:
		m.ResetOutputTokens()
		return nil
	case usagelog.FieldCacheCreationTokens:
		m.ResetCacheCreationTokens()
		return nil
	case usagelog.FieldCacheReadTokens:
		m.ResetCacheReadTokens()
		return nil
	case usagelog.FieldCacheCreation5mTokens:
		m.ResetCacheCreation5mTokens()
		return nil
	case usagelog.FieldCacheCreation1hTokens:
		m.ResetCacheCreation1hTokens()
		return nil
	case usagelog.FieldInputCost:
		m.ResetInputCost()
		return nil
	case usagelog.FieldOutputCost:
		m.ResetOutputCost()
		return nil
	case usagelog.FieldCacheCreationCost:
		m.ResetCacheCreationCost()
		return nil
	case usagelog.FieldCacheReadCost:
		m.ResetCacheReadCost()
		return nil
	case usagelog.FieldTotalCost:
		m.ResetTotalCost()
		return nil
	case usagelog.FieldActualCost:
		m.ResetActualCost()
		return nil
	case usagelog.FieldRateMultiplier:
		m.ResetRateMultiplier()
		return nil
	case usagelog.FieldAccountRateMultiplier:
		m.ResetAccountRateMultiplier()
		return nil
	case usagelog.FieldBillingType:
		m.ResetBillingType()
		return nil
	case usagelog.FieldStream:
		m.ResetStream()
		return nil
	case usagelog.FieldDurationMs:
		m.ResetDurationMs()
		return nil
	case usagelog.FieldFirstTokenMs:
		m.ResetFirstTokenMs()
		return nil
	case usagelog.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case usagelog.FieldIPAddress:
		m.ResetIPAddress()
		return nil
	case usagelog.FieldImageCount:
		m.ResetImageCount()
		return nil
	case usagelog.FieldImageSize:
		m.ResetImageSize()
		return nil
	case usagelog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown UsageLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UsageLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.user != nil {
		edges = append(edges, usagelog.EdgeUser)
	}
	if m.api_key != nil {
		edges = append(edges, usagelog.EdgeAPIKey)
	}
	if m.account != nil {
		edges = append(edges, usagelog.EdgeAccount)
	}
	if m.group != nil {
		edges = append(edges, usagelog.EdgeGroup)
	}
	if m.subscription != nil {
		edges = append(edges, usagelog.EdgeSubscription)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UsageLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usagelog.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case usagelog.EdgeAPIKey:
		if id := m.api_key; id != nil {
			return []ent.Value{*id}
		}
	case usagelog.EdgeAccount:
		if id := m.account; id != nil {
			return []ent.Value{*id}
		}
	case usagelog.EdgeGroup:
		if id := m.group; id != nil {
			return []ent.Value{*id}
		}
	case usagelog.EdgeSubscription:
		if id := m.subscription; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UsageLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UsageLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UsageLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.cleareduser {
		edges = append(edges, usagelog.EdgeUser)
	}
	if m.clearedapi_key {
		edges = append(edges, usagelog.EdgeAPIKey)
	}
	if m.clearedaccount {
		edges = append(edges, usagelog.EdgeAccount)
	}
	if m.clearedgroup {
		edges = append(edges, usagelog.EdgeGroup)
	}
	if m.clearedsubscription {
		edges = append(edges, usagelog.EdgeSubscription)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UsageLogMutation) EdgeCleared(name string) bool {
	switch name {
	case usagelog.EdgeUser:
		return m.cleareduser
	case usagelog.EdgeAPIKey:
		return m.clearedapi_key
	case usagelog.EdgeAccount:
		return m.clearedaccount
	case usagelog.EdgeGroup:
		return m.clearedgroup
	case usagelog.EdgeSubscription:
		return m.clearedsubscription
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UsageLogMutation) ClearEdge(name string) error {
	switch name {
	case usagelog.EdgeUser:
		m.ClearUser()
		return nil
	case usagelog.EdgeAPIKey:
		m.ClearAPIKey()
		return nil
	case usagelog.EdgeAccount:
		m.ClearAccount()
		return nil
	case usagelog.EdgeGroup:
		m.ClearGroup()
		return nil
	case usagelog.EdgeSubscription:
		m.ClearSubscription()
		return nil
	}
	return fmt.Errorf("unknown UsageLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UsageLogMutation) ResetEdge(name string) error {
	switch name {
	case usagelog.EdgeUser:
		m.ResetUser()
		return nil
	case usagelog.EdgeAPIKey:
		m.ResetAPIKey()
		return nil
	case usagelog.EdgeAccount:
		m.ResetAccount()
		return nil
	case usagelog.EdgeGroup:
		m.ResetGroup()
		return nil
	case usagelog.EdgeSubscription:
		m.ResetSubscription()
		return nil
	}
	return fmt.Errorf("unknown UsageLog edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                              Op
	typ                             string
	id                              *int64
	created_at                      *time.Time
	updated_at                      *time.Time
	deleted_at                      *time.Time
	email                           *string
	password_hash                   *string
	role                            *string
	balance                         *float64
	addbalance                      *float64
	concurrency                     *int
	addconcurrency                  *int
	status                          *string
	username                        *string
	notes                           *string
	referral_code                   *string
	referred_by                     *int64
	addreferred_by                  *int64
	referral_rewarded               *bool
	totp_secret_encrypted           *string
	totp_enabled                    *bool
	totp_enabled_at                 *time.Time
	token_version                   *int64
	addtoken_version                *int64
	role_version                    *int64
	addrole_version                 *int64
	clearedFields                   map[string]struct{}
	api_keys                        map[int64]struct{}
	removedapi_keys                 map[int64]struct{}
	clearedapi_keys                 bool
	redeem_codes                    map[int64]struct{}
	removedredeem_codes             map[int64]struct{}
	clearedredeem_codes             bool
	subscriptions                   map[int64]struct{}
	removedsubscriptions            map[int64]struct{}
	clearedsubscriptions            bool
	assigned_subscriptions          map[int64]struct{}
	removedassigned_subscriptions   map[int64]struct{}
	clearedassigned_subscriptions   bool
	announcement_reads              map[int64]struct{}
	removedannouncement_reads       map[int64]struct{}
	clearedannouncement_reads       bool
	allowed_groups                  map[int64]struct{}
	removedallowed_groups           map[int64]struct{}
	clearedallowed_groups           bool
	usage_logs                      map[int64]struct{}
	removedusage_logs               map[int64]struct{}
	clearedusage_logs               bool
	attribute_values                map[int64]struct{}
	removedattribute_values         map[int64]struct{}
	clearedattribute_values         bool
	promo_code_usages               map[int64]struct{}
	removedpromo_code_usages        map[int64]struct{}
	clearedpromo_code_usages        bool
	orders                          map[int64]struct{}
	removedorders                   map[int64]struct{}
	clearedorders                   bool
	recharge_orders                 map[int64]struct{}
	removedrecharge_orders          map[int64]struct{}
	clearedrecharge_orders          bool
	referral_rewards_given          map[int64]struct{}
	removedreferral_rewards_given   map[int64]struct{}
	clearedreferral_rewards_given   bool
	referral_reward_received        map[int64]struct{}
	removedreferral_reward_received map[int64]struct{}
	clearedreferral_reward_received bool
	sub_users                       map[int64]struct{}
	removedsub_users                map[int64]struct{}
	clearedsub_users                bool
	parent                          *int64
	clearedparent                   bool
	reseller_domains                map[int64]struct{}
	removedreseller_domains         map[int64]struct{}
	clearedreseller_domains         bool
	done                            bool
	oldValue                        func(context.Context) (*User, error)
	predicates                      []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int64) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[user.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, user.FieldDeletedAt)
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPasswordHash sets the "password_hash" field.
func (m *UserMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *UserMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *UserMutation) ResetPasswordHash() {
	m.password_hash = nil
}

// SetRole sets the "role" field.
func (m *UserMutation) SetRole(s string) {
	m.role = &s
}

// Role returns the value of the "role" field in the mutation.
func (m *UserMutation) Role() (r string, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRole(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *UserMutation) ResetRole() {
	m.role = nil
}

// SetBalance sets the "balance" field.
func (m *UserMutation) SetBalance(f float64) {
	m.balance = &f
	m.addbalance = nil
}

// Balance returns the value of the "balance" field in the mutation.
func (m *UserMutation) Balance() (r float64, exists bool) {
	v := m.balance
	if v == nil {
		return
	}
	return *v, true
}

// OldBalance returns the old "balance" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldBalance(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalance: %w", err)
	}
	return oldValue.Balance, nil
}

// AddBalance adds f to the "balance" field.
func (m *UserMutation) AddBalance(f float64) {
	if m.addbalance != nil {
		*m.addbalance += f
	} else {
		m.addbalance = &f
	}
}

// AddedBalance returns the value that was added to the "balance" field in this mutation.
func (m *UserMutation) AddedBalance() (r float64, exists bool) {
	v := m.addbalance
	if v == nil {
		return
	}
	return *v, true
}

// ResetBalance resets all changes to the "balance" field.
func (m *UserMutation) ResetBalance() {
	m.balance = nil
	m.addbalance = nil
}

// SetConcurrency sets the "concurrency" field.
func (m *UserMutation) SetConcurrency(i int) {
	m.concurrency = &i
	m.addconcurrency = nil
}

// Concurrency returns the value of the "concurrency" field in the mutation.
func (m *UserMutation) Concurrency() (r int, exists bool) {
	v := m.concurrency
	if v == nil {
		return
	}
	return *v, true
}

// OldConcurrency returns the old "concurrency" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldConcurrency(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConcurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConcurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConcurrency: %w", err)
	}
	return oldValue.Concurrency, nil
}

// AddConcurrency adds i to the "concurrency" field.
func (m *UserMutation) AddConcurrency(i int) {
	if m.addconcurrency != nil {
		*m.addconcurrency += i
	} else {
		m.addconcurrency = &i
	}
}

// AddedConcurrency returns the value that was added to the "concurrency" field in this mutation.
func (m *UserMutation) AddedConcurrency() (r int, exists bool) {
	v := m.addconcurrency
	if v == nil {
		return
	}
	return *v, true
}

// ResetConcurrency resets all changes to the "concurrency" field.
func (m *UserMutation) ResetConcurrency() {
	m.concurrency = nil
	m.addconcurrency = nil
}

// SetStatus sets the "status" field.
func (m *UserMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *UserMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *UserMutation) ResetStatus() {
	m.status = nil
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetNotes sets the "notes" field.
func (m *UserMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *UserMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ResetNotes resets all changes to the "notes" field.
func (m *UserMutation) ResetNotes() {
	m.notes = nil
}

// SetReferralCode sets the "referral_code" field.
func (m *UserMutation) SetReferralCode(s string) {
	m.referral_code = &s
}

// ReferralCode returns the value of the "referral_code" field in the mutation.
func (m *UserMutation) ReferralCode() (r string, exists bool) {
	v := m.referral_code
	if v == nil {
		return
	}
	return *v, true
}

// OldReferralCode returns the old "referral_code" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldReferralCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferralCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferralCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferralCode: %w", err)
	}
	return oldValue.ReferralCode, nil
}

// ClearReferralCode clears the value of the "referral_code" field.
func (m *UserMutation) ClearReferralCode() {
	m.referral_code = nil
	m.clearedFields[user.FieldReferralCode] = struct{}{}
}

// ReferralCodeCleared returns if the "referral_code" field was cleared in this mutation.
func (m *UserMutation) ReferralCodeCleared() bool {
	_, ok := m.clearedFields[user.FieldReferralCode]
	return ok
}

// ResetReferralCode resets all changes to the "referral_code" field.
func (m *UserMutation) ResetReferralCode() {
	m.referral_code = nil
	delete(m.clearedFields, user.FieldReferralCode)
}

// SetReferredBy sets the "referred_by" field.
func (m *UserMutation) SetReferredBy(i int64) {
	m.referred_by = &i
	m.addreferred_by = nil
}

// ReferredBy returns the value of the "referred_by" field in the mutation.
func (m *UserMutation) ReferredBy() (r int64, exists bool) {
	v := m.referred_by
	if v == nil {
		return
	}
	return *v, true
}

// OldReferredBy returns the old "referred_by" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldReferredBy(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferredBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferredBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferredBy: %w", err)
	}
	return oldValue.ReferredBy, nil
}

// AddReferredBy adds i to the "referred_by" field.
func (m *UserMutation) AddReferredBy(i int64) {
	if m.addreferred_by != nil {
		*m.addreferred_by += i
	} else {
		m.addreferred_by = &i
	}
}

// AddedReferredBy returns the value that was added to the "referred_by" field in this mutation.
func (m *UserMutation) AddedReferredBy() (r int64, exists bool) {
	v := m.addreferred_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearReferredBy clears the value of the "referred_by" field.
func (m *UserMutation) ClearReferredBy() {
	m.referred_by = nil
	m.addreferred_by = nil
	m.clearedFields[user.FieldReferredBy] = struct{}{}
}

// ReferredByCleared returns if the "referred_by" field was cleared in this mutation.
func (m *UserMutation) ReferredByCleared() bool {
	_, ok := m.clearedFields[user.FieldReferredBy]
	return ok
}

// ResetReferredBy resets all changes to the "referred_by" field.
func (m *UserMutation) ResetReferredBy() {
	m.referred_by = nil
	m.addreferred_by = nil
	delete(m.clearedFields, user.FieldReferredBy)
}

// SetReferralRewarded sets the "referral_rewarded" field.
func (m *UserMutation) SetReferralRewarded(b bool) {
	m.referral_rewarded = &b
}

// ReferralRewarded returns the value of the "referral_rewarded" field in the mutation.
func (m *UserMutation) ReferralRewarded() (r bool, exists bool) {
	v := m.referral_rewarded
	if v == nil {
		return
	}
	return *v, true
}

// OldReferralRewarded returns the old "referral_rewarded" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldReferralRewarded(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferralRewarded is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferralRewarded requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferralRewarded: %w", err)
	}
	return oldValue.ReferralRewarded, nil
}

// ResetReferralRewarded resets all changes to the "referral_rewarded" field.
func (m *UserMutation) ResetReferralRewarded() {
	m.referral_rewarded = nil
}

// SetTotpSecretEncrypted sets the "totp_secret_encrypted" field.
func (m *UserMutation) SetTotpSecretEncrypted(s string) {
	m.totp_secret_encrypted = &s
}

// TotpSecretEncrypted returns the value of the "totp_secret_encrypted" field in the mutation.
func (m *UserMutation) TotpSecretEncrypted() (r string, exists bool) {
	v := m.totp_secret_encrypted
	if v == nil {
		return
	}
	return *v, true
}

// OldTotpSecretEncrypted returns the old "totp_secret_encrypted" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldTotpSecretEncrypted(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotpSecretEncrypted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotpSecretEncrypted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotpSecretEncrypted: %w", err)
	}
	return oldValue.TotpSecretEncrypted, nil
}

// ClearTotpSecretEncrypted clears the value of the "totp_secret_encrypted" field.
func (m *UserMutation) ClearTotpSecretEncrypted() {
	m.totp_secret_encrypted = nil
	m.clearedFields[user.FieldTotpSecretEncrypted] = struct{}{}
}

// TotpSecretEncryptedCleared returns if the "totp_secret_encrypted" field was cleared in this mutation.
func (m *UserMutation) TotpSecretEncryptedCleared() bool {
	_, ok := m.clearedFields[user.FieldTotpSecretEncrypted]
	return ok
}

// ResetTotpSecretEncrypted resets all changes to the "totp_secret_encrypted" field.
func (m *UserMutation) ResetTotpSecretEncrypted() {
	m.totp_secret_encrypted = nil
	delete(m.clearedFields, user.FieldTotpSecretEncrypted)
}

// SetTotpEnabled sets the "totp_enabled" field.
func (m *UserMutation) SetTotpEnabled(b bool) {
	m.totp_enabled = &b
}

// TotpEnabled returns the value of the "totp_enabled" field in the mutation.
func (m *UserMutation) TotpEnabled() (r bool, exists bool) {
	v := m.totp_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldTotpEnabled returns the old "totp_enabled" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldTotpEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotpEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotpEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotpEnabled: %w", err)
	}
	return oldValue.TotpEnabled, nil
}

// ResetTotpEnabled resets all changes to the "totp_enabled" field.
func (m *UserMutation) ResetTotpEnabled() {
	m.totp_enabled = nil
}

// SetTotpEnabledAt sets the "totp_enabled_at" field.
func (m *UserMutation) SetTotpEnabledAt(t time.Time) {
	m.totp_enabled_at = &t
}

// TotpEnabledAt returns the value of the "totp_enabled_at" field in the mutation.
func (m *UserMutation) TotpEnabledAt() (r time.Time, exists bool) {
	v := m.totp_enabled_at
	if v == nil {
		return
	}
	return *v, true
}

// OldTotpEnabledAt returns the old "totp_enabled_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldTotpEnabledAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotpEnabledAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotpEnabledAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotpEnabledAt: %w", err)
	}
	return oldValue.TotpEnabledAt, nil
}

// ClearTotpEnabledAt clears the value of the "totp_enabled_at" field.
func (m *UserMutation) ClearTotpEnabledAt() {
	m.totp_enabled_at = nil
	m.clearedFields[user.FieldTotpEnabledAt] = struct{}{}
}

// TotpEnabledAtCleared returns if the "totp_enabled_at" field was cleared in this mutation.
func (m *UserMutation) TotpEnabledAtCleared() bool {
	_, ok := m.clearedFields[user.FieldTotpEnabledAt]
	return ok
}

// ResetTotpEnabledAt resets all changes to the "totp_enabled_at" field.
func (m *UserMutation) ResetTotpEnabledAt() {
	m.totp_enabled_at = nil
	delete(m.clearedFields, user.FieldTotpEnabledAt)
}

// SetParentID sets the "parent_id" field.
func (m *UserMutation) SetParentID(i int64) {
	m.parent = &i
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *UserMutation) ParentID() (r int64, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldParentID(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *UserMutation) ClearParentID() {
	m.parent = nil
	m.clearedFields[user.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *UserMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[user.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *UserMutation) ResetParentID() {
	m.parent = nil
	delete(m.clearedFields, user.FieldParentID)
}

// SetTokenVersion sets the "token_version" field.
func (m *UserMutation) SetTokenVersion(i int64) {
	m.token_version = &i
	m.addtoken_version = nil
}

// TokenVersion returns the value of the "token_version" field in the mutation.
func (m *UserMutation) TokenVersion() (r int64, exists bool) {
	v := m.token_version
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenVersion returns the old "token_version" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldTokenVersion(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenVersion: %w", err)
	}
	return oldValue.TokenVersion, nil
}

// AddTokenVersion adds i to the "token_version" field.
func (m *UserMutation) AddTokenVersion(i int64) {
	if m.addtoken_version != nil {
		*m.addtoken_version += i
	} else {
		m.addtoken_version = &i
	}
}

// AddedTokenVersion returns the value that was added to the "token_version" field in this mutation.
func (m *UserMutation) AddedTokenVersion() (r int64, exists bool) {
	v := m.addtoken_version
	if v == nil {
		return
	}
	return *v, true
}

// ResetTokenVersion resets all changes to the "token_version" field.
func (m *UserMutation) ResetTokenVersion() {
	m.token_version = nil
	m.addtoken_version = nil
}

// SetRoleVersion sets the "role_version" field.
func (m *UserMutation) SetRoleVersion(i int64) {
	m.role_version = &i
	m.addrole_version = nil
}

// RoleVersion returns the value of the "role_version" field in the mutation.
func (m *UserMutation) RoleVersion() (r int64, exists bool) {
	v := m.role_version
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleVersion returns the old "role_version" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRoleVersion(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleVersion: %w", err)
	}
	return oldValue.RoleVersion, nil
}

// AddRoleVersion adds i to the "role_version" field.
func (m *UserMutation) AddRoleVersion(i int64) {
	if m.addrole_version != nil {
		*m.addrole_version += i
	} else {
		m.addrole_version = &i
	}
}

// AddedRoleVersion returns the value that was added to the "role_version" field in this mutation.
func (m *UserMutation) AddedRoleVersion() (r int64, exists bool) {
	v := m.addrole_version
	if v == nil {
		return
	}
	return *v, true
}

// ResetRoleVersion resets all changes to the "role_version" field.
func (m *UserMutation) ResetRoleVersion() {
	m.role_version = nil
	m.addrole_version = nil
}

// AddAPIKeyIDs adds the "api_keys" edge to the APIKey entity by ids.
func (m *UserMutation) AddAPIKeyIDs(ids ...int64) {
	if m.api_keys == nil {
		m.api_keys = make(map[int64]struct{})
	}
	for i := range ids {
		m.api_keys[ids[i]] = struct{}{}
	}
}

// ClearAPIKeys clears the "api_keys" edge to the APIKey entity.
func (m *UserMutation) ClearAPIKeys() {
	m.clearedapi_keys = true
}

// APIKeysCleared reports if the "api_keys" edge to the APIKey entity was cleared.
func (m *UserMutation) APIKeysCleared() bool {
	return m.clearedapi_keys
}

// RemoveAPIKeyIDs removes the "api_keys" edge to the APIKey entity by IDs.
func (m *UserMutation) RemoveAPIKeyIDs(ids ...int64) {
	if m.removedapi_keys == nil {
		m.removedapi_keys = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.api_keys, ids[i])
		m.removedapi_keys[ids[i]] = struct{}{}
	}
}

// RemovedAPIKeys returns the removed IDs of the "api_keys" edge to the APIKey entity.
func (m *UserMutation) RemovedAPIKeysIDs() (ids []int64) {
	for id := range m.removedapi_keys {
		ids = append(ids, id)
	}
	return
}

// APIKeysIDs returns the "api_keys" edge IDs in the mutation.
func (m *UserMutation) APIKeysIDs() (ids []int64) {
	for id := range m.api_keys {
		ids = append(ids, id)
	}
	return
}

// ResetAPIKeys resets all changes to the "api_keys" edge.
func (m *UserMutation) ResetAPIKeys() {
	m.api_keys = nil
	m.clearedapi_keys = false
	m.removedapi_keys = nil
}

// AddRedeemCodeIDs adds the "redeem_codes" edge to the RedeemCode entity by ids.
func (m *UserMutation) AddRedeemCodeIDs(ids ...int64) {
	if m.redeem_codes == nil {
		m.redeem_codes = make(map[int64]struct{})
	}
	for i := range ids {
		m.redeem_codes[ids[i]] = struct{}{}
	}
}

// ClearRedeemCodes clears the "redeem_codes" edge to the RedeemCode entity.
func (m *UserMutation) ClearRedeemCodes() {
	m.clearedredeem_codes = true
}

// RedeemCodesCleared reports if the "redeem_codes" edge to the RedeemCode entity was cleared.
func (m *UserMutation) RedeemCodesCleared() bool {
	return m.clearedredeem_codes
}

// RemoveRedeemCodeIDs removes the "redeem_codes" edge to the RedeemCode entity by IDs.
func (m *UserMutation) RemoveRedeemCodeIDs(ids ...int64) {
	if m.removedredeem_codes == nil {
		m.removedredeem_codes = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.redeem_codes, ids[i])
		m.removedredeem_codes[ids[i]] = struct{}{}
	}
}

// RemovedRedeemCodes returns the removed IDs of the "redeem_codes" edge to the RedeemCode entity.
func (m *UserMutation) RemovedRedeemCodesIDs() (ids []int64) {
	for id := range m.removedredeem_codes {
		ids = append(ids, id)
	}
	return
}

// RedeemCodesIDs returns the "redeem_codes" edge IDs in the mutation.
func (m *UserMutation) RedeemCodesIDs() (ids []int64) {
	for id := range m.redeem_codes {
		ids = append(ids, id)
	}
	return
}

// ResetRedeemCodes resets all changes to the "redeem_codes" edge.
func (m *UserMutation) ResetRedeemCodes() {
	m.redeem_codes = nil
	m.clearedredeem_codes = false
	m.removedredeem_codes = nil
}

// AddSubscriptionIDs adds the "subscriptions" edge to the UserSubscription entity by ids.
func (m *UserMutation) AddSubscriptionIDs(ids ...int64) {
	if m.subscriptions == nil {
		m.subscriptions = make(map[int64]struct{})
	}
	for i := range ids {
		m.subscriptions[ids[i]] = struct{}{}
	}
}

// ClearSubscriptions clears the "subscriptions" edge to the UserSubscription entity.
func (m *UserMutation) ClearSubscriptions() {
	m.clearedsubscriptions = true
}

// SubscriptionsCleared reports if the "subscriptions" edge to the UserSubscription entity was cleared.
func (m *UserMutation) SubscriptionsCleared() bool {
	return m.clearedsubscriptions
}

// RemoveSubscriptionIDs removes the "subscriptions" edge to the UserSubscription entity by IDs.
func (m *UserMutation) RemoveSubscriptionIDs(ids ...int64) {
	if m.removedsubscriptions == nil {
		m.removedsubscriptions = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.subscriptions, ids[i])
		m.removedsubscriptions[ids[i]] = struct{}{}
	}
}

// RemovedSubscriptions returns the removed IDs of the "subscriptions" edge to the UserSubscription entity.
func (m *UserMutation) RemovedSubscriptionsIDs() (ids []int64) {
	for id := range m.removedsubscriptions {
		ids = append(ids, id)
	}
	return
}

// SubscriptionsIDs returns the "subscriptions" edge IDs in the mutation.
func (m *UserMutation) SubscriptionsIDs() (ids []int64) {
	for id := range m.subscriptions {
		ids = append(ids, id)
	}
	return
}

// ResetSubscriptions resets all changes to the "subscriptions" edge.
func (m *UserMutation) ResetSubscriptions() {
	m.subscriptions = nil
	m.clearedsubscriptions = false
	m.removedsubscriptions = nil
}

// AddAssignedSubscriptionIDs adds the "assigned_subscriptions" edge to the UserSubscription entity by ids.
func (m *UserMutation) AddAssignedSubscriptionIDs(ids ...int64) {
	if m.assigned_subscriptions == nil {
		m.assigned_subscriptions = make(map[int64]struct{})
	}
	for i := range ids {
		m.assigned_subscriptions[ids[i]] = struct{}{}
	}
}

// ClearAssignedSubscriptions clears the "assigned_subscriptions" edge to the UserSubscription entity.
func (m *UserMutation) ClearAssignedSubscriptions() {
	m.clearedassigned_subscriptions = true
}

// AssignedSubscriptionsCleared reports if the "assigned_subscriptions" edge to the UserSubscription entity was cleared.
func (m *UserMutation) AssignedSubscriptionsCleared() bool {
	return m.clearedassigned_subscriptions
}

// RemoveAssignedSubscriptionIDs removes the "assigned_subscriptions" edge to the UserSubscription entity by IDs.
func (m *UserMutation) RemoveAssignedSubscriptionIDs(ids ...int64) {
	if m.removedassigned_subscriptions == nil {
		m.removedassigned_subscriptions = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.assigned_subscriptions, ids[i])
		m.removedassigned_subscriptions[ids[i]] = struct{}{}
	}
}

// RemovedAssignedSubscriptions returns the removed IDs of the "assigned_subscriptions" edge to the UserSubscription entity.
func (m *UserMutation) RemovedAssignedSubscriptionsIDs() (ids []int64) {
	for id := range m.removedassigned_subscriptions {
		ids = append(ids, id)
	}
	return
}

// AssignedSubscriptionsIDs returns the "assigned_subscriptions" edge IDs in the mutation.
func (m *UserMutation) AssignedSubscriptionsIDs() (ids []int64) {
	for id := range m.assigned_subscriptions {
		ids = append(ids, id)
	}
	return
}

// ResetAssignedSubscriptions resets all changes to the "assigned_subscriptions" edge.
func (m *UserMutation) ResetAssignedSubscriptions() {
	m.assigned_subscriptions = nil
	m.clearedassigned_subscriptions = false
	m.removedassigned_subscriptions = nil
}

// AddAnnouncementReadIDs adds the "announcement_reads" edge to the AnnouncementRead entity by ids.
func (m *UserMutation) AddAnnouncementReadIDs(ids ...int64) {
	if m.announcement_reads == nil {
		m.announcement_reads = make(map[int64]struct{})
	}
	for i := range ids {
		m.announcement_reads[ids[i]] = struct{}{}
	}
}

// ClearAnnouncementReads clears the "announcement_reads" edge to the AnnouncementRead entity.
func (m *UserMutation) ClearAnnouncementReads() {
	m.clearedannouncement_reads = true
}

// AnnouncementReadsCleared reports if the "announcement_reads" edge to the AnnouncementRead entity was cleared.
func (m *UserMutation) AnnouncementReadsCleared() bool {
	return m.clearedannouncement_reads
}

// RemoveAnnouncementReadIDs removes the "announcement_reads" edge to the AnnouncementRead entity by IDs.
func (m *UserMutation) RemoveAnnouncementReadIDs(ids ...int64) {
	if m.removedannouncement_reads == nil {
		m.removedannouncement_reads = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.announcement_reads, ids[i])
		m.removedannouncement_reads[ids[i]] = struct{}{}
	}
}

// RemovedAnnouncementReads returns the removed IDs of the "announcement_reads" edge to the AnnouncementRead entity.
func (m *UserMutation) RemovedAnnouncementReadsIDs() (ids []int64) {
	for id := range m.removedannouncement_reads {
		ids = append(ids, id)
	}
	return
}

// AnnouncementReadsIDs returns the "announcement_reads" edge IDs in the mutation.
func (m *UserMutation) AnnouncementReadsIDs() (ids []int64) {
	for id := range m.announcement_reads {
		ids = append(ids, id)
	}
	return
}

// ResetAnnouncementReads resets all changes to the "announcement_reads" edge.
func (m *UserMutation) ResetAnnouncementReads() {
	m.announcement_reads = nil
	m.clearedannouncement_reads = false
	m.removedannouncement_reads = nil
}

// AddAllowedGroupIDs adds the "allowed_groups" edge to the Group entity by ids.
func (m *UserMutation) AddAllowedGroupIDs(ids ...int64) {
	if m.allowed_groups == nil {
		m.allowed_groups = make(map[int64]struct{})
	}
	for i := range ids {
		m.allowed_groups[ids[i]] = struct{}{}
	}
}

// ClearAllowedGroups clears the "allowed_groups" edge to the Group entity.
func (m *UserMutation) ClearAllowedGroups() {
	m.clearedallowed_groups = true
}

// AllowedGroupsCleared reports if the "allowed_groups" edge to the Group entity was cleared.
func (m *UserMutation) AllowedGroupsCleared() bool {
	return m.clearedallowed_groups
}

// RemoveAllowedGroupIDs removes the "allowed_groups" edge to the Group entity by IDs.
func (m *UserMutation) RemoveAllowedGroupIDs(ids ...int64) {
	if m.removedallowed_groups == nil {
		m.removedallowed_groups = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.allowed_groups, ids[i])
		m.removedallowed_groups[ids[i]] = struct{}{}
	}
}

// RemovedAllowedGroups returns the removed IDs of the "allowed_groups" edge to the Group entity.
func (m *UserMutation) RemovedAllowedGroupsIDs() (ids []int64) {
	for id := range m.removedallowed_groups {
		ids = append(ids, id)
	}
	return
}

// AllowedGroupsIDs returns the "allowed_groups" edge IDs in the mutation.
func (m *UserMutation) AllowedGroupsIDs() (ids []int64) {
	for id := range m.allowed_groups {
		ids = append(ids, id)
	}
	return
}

// ResetAllowedGroups resets all changes to the "allowed_groups" edge.
func (m *UserMutation) ResetAllowedGroups() {
	m.allowed_groups = nil
	m.clearedallowed_groups = false
	m.removedallowed_groups = nil
}

// AddUsageLogIDs adds the "usage_logs" edge to the UsageLog entity by ids.
func (m *UserMutation) AddUsageLogIDs(ids ...int64) {
	if m.usage_logs == nil {
		m.usage_logs = make(map[int64]struct{})
	}
	for i := range ids {
		m.usage_logs[ids[i]] = struct{}{}
	}
}

// ClearUsageLogs clears the "usage_logs" edge to the UsageLog entity.
func (m *UserMutation) ClearUsageLogs() {
	m.clearedusage_logs = true
}

// UsageLogsCleared reports if the "usage_logs" edge to the UsageLog entity was cleared.
func (m *UserMutation) UsageLogsCleared() bool {
	return m.clearedusage_logs
}

// RemoveUsageLogIDs removes the "usage_logs" edge to the UsageLog entity by IDs.
func (m *UserMutation) RemoveUsageLogIDs(ids ...int64) {
	if m.removedusage_logs == nil {
		m.removedusage_logs = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.usage_logs, ids[i])
		m.removedusage_logs[ids[i]] = struct{}{}
	}
}

// RemovedUsageLogs returns the removed IDs of the "usage_logs" edge to the UsageLog entity.
func (m *UserMutation) RemovedUsageLogsIDs() (ids []int64) {
	for id := range m.removedusage_logs {
		ids = append(ids, id)
	}
	return
}

// UsageLogsIDs returns the "usage_logs" edge IDs in the mutation.
func (m *UserMutation) UsageLogsIDs() (ids []int64) {
	for id := range m.usage_logs {
		ids = append(ids, id)
	}
	return
}

// ResetUsageLogs resets all changes to the "usage_logs" edge.
func (m *UserMutation) ResetUsageLogs() {
	m.usage_logs = nil
	m.clearedusage_logs = false
	m.removedusage_logs = nil
}

// AddAttributeValueIDs adds the "attribute_values" edge to the UserAttributeValue entity by ids.
func (m *UserMutation) AddAttributeValueIDs(ids ...int64) {
	if m.attribute_values == nil {
		m.attribute_values = make(map[int64]struct{})
	}
	for i := range ids {
		m.attribute_values[ids[i]] = struct{}{}
	}
}

// ClearAttributeValues clears the "attribute_values" edge to the UserAttributeValue entity.
func (m *UserMutation) ClearAttributeValues() {
	m.clearedattribute_values = true
}

// AttributeValuesCleared reports if the "attribute_values" edge to the UserAttributeValue entity was cleared.
func (m *UserMutation) AttributeValuesCleared() bool {
	return m.clearedattribute_values
}

// RemoveAttributeValueIDs removes the "attribute_values" edge to the UserAttributeValue entity by IDs.
func (m *UserMutation) RemoveAttributeValueIDs(ids ...int64) {
	if m.removedattribute_values == nil {
		m.removedattribute_values = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.attribute_values, ids[i])
		m.removedattribute_values[ids[i]] = struct{}{}
	}
}

// RemovedAttributeValues returns the removed IDs of the "attribute_values" edge to the UserAttributeValue entity.
func (m *UserMutation) RemovedAttributeValuesIDs() (ids []int64) {
	for id := range m.removedattribute_values {
		ids = append(ids, id)
	}
	return
}

// AttributeValuesIDs returns the "attribute_values" edge IDs in the mutation.
func (m *UserMutation) AttributeValuesIDs() (ids []int64) {
	for id := range m.attribute_values {
		ids = append(ids, id)
	}
	return
}

// ResetAttributeValues resets all changes to the "attribute_values" edge.
func (m *UserMutation) ResetAttributeValues() {
	m.attribute_values = nil
	m.clearedattribute_values = false
	m.removedattribute_values = nil
}

// AddPromoCodeUsageIDs adds the "promo_code_usages" edge to the PromoCodeUsage entity by ids.
func (m *UserMutation) AddPromoCodeUsageIDs(ids ...int64) {
	if m.promo_code_usages == nil {
		m.promo_code_usages = make(map[int64]struct{})
	}
	for i := range ids {
		m.promo_code_usages[ids[i]] = struct{}{}
	}
}

// ClearPromoCodeUsages clears the "promo_code_usages" edge to the PromoCodeUsage entity.
func (m *UserMutation) ClearPromoCodeUsages() {
	m.clearedpromo_code_usages = true
}

// PromoCodeUsagesCleared reports if the "promo_code_usages" edge to the PromoCodeUsage entity was cleared.
func (m *UserMutation) PromoCodeUsagesCleared() bool {
	return m.clearedpromo_code_usages
}

// RemovePromoCodeUsageIDs removes the "promo_code_usages" edge to the PromoCodeUsage entity by IDs.
func (m *UserMutation) RemovePromoCodeUsageIDs(ids ...int64) {
	if m.removedpromo_code_usages == nil {
		m.removedpromo_code_usages = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.promo_code_usages, ids[i])
		m.removedpromo_code_usages[ids[i]] = struct{}{}
	}
}

// RemovedPromoCodeUsages returns the removed IDs of the "promo_code_usages" edge to the PromoCodeUsage entity.
func (m *UserMutation) RemovedPromoCodeUsagesIDs() (ids []int64) {
	for id := range m.removedpromo_code_usages {
		ids = append(ids, id)
	}
	return
}

// PromoCodeUsagesIDs returns the "promo_code_usages" edge IDs in the mutation.
func (m *UserMutation) PromoCodeUsagesIDs() (ids []int64) {
	for id := range m.promo_code_usages {
		ids = append(ids, id)
	}
	return
}

// ResetPromoCodeUsages resets all changes to the "promo_code_usages" edge.
func (m *UserMutation) ResetPromoCodeUsages() {
	m.promo_code_usages = nil
	m.clearedpromo_code_usages = false
	m.removedpromo_code_usages = nil
}

// AddOrderIDs adds the "orders" edge to the Order entity by ids.
func (m *UserMutation) AddOrderIDs(ids ...int64) {
	if m.orders == nil {
		m.orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.orders[ids[i]] = struct{}{}
	}
}

// ClearOrders clears the "orders" edge to the Order entity.
func (m *UserMutation) ClearOrders() {
	m.clearedorders = true
}

// OrdersCleared reports if the "orders" edge to the Order entity was cleared.
func (m *UserMutation) OrdersCleared() bool {
	return m.clearedorders
}

// RemoveOrderIDs removes the "orders" edge to the Order entity by IDs.
func (m *UserMutation) RemoveOrderIDs(ids ...int64) {
	if m.removedorders == nil {
		m.removedorders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.orders, ids[i])
		m.removedorders[ids[i]] = struct{}{}
	}
}

// RemovedOrders returns the removed IDs of the "orders" edge to the Order entity.
func (m *UserMutation) RemovedOrdersIDs() (ids []int64) {
	for id := range m.removedorders {
		ids = append(ids, id)
	}
	return
}

// OrdersIDs returns the "orders" edge IDs in the mutation.
func (m *UserMutation) OrdersIDs() (ids []int64) {
	for id := range m.orders {
		ids = append(ids, id)
	}
	return
}

// ResetOrders resets all changes to the "orders" edge.
func (m *UserMutation) ResetOrders() {
	m.orders = nil
	m.clearedorders = false
	m.removedorders = nil
}

// AddRechargeOrderIDs adds the "recharge_orders" edge to the RechargeOrder entity by ids.
func (m *UserMutation) AddRechargeOrderIDs(ids ...int64) {
	if m.recharge_orders == nil {
		m.recharge_orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.recharge_orders[ids[i]] = struct{}{}
	}
}

// ClearRechargeOrders clears the "recharge_orders" edge to the RechargeOrder entity.
func (m *UserMutation) ClearRechargeOrders() {
	m.clearedrecharge_orders = true
}

// RechargeOrdersCleared reports if the "recharge_orders" edge to the RechargeOrder entity was cleared.
func (m *UserMutation) RechargeOrdersCleared() bool {
	return m.clearedrecharge_orders
}

// RemoveRechargeOrderIDs removes the "recharge_orders" edge to the RechargeOrder entity by IDs.
func (m *UserMutation) RemoveRechargeOrderIDs(ids ...int64) {
	if m.removedrecharge_orders == nil {
		m.removedrecharge_orders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.recharge_orders, ids[i])
		m.removedrecharge_orders[ids[i]] = struct{}{}
	}
}

// RemovedRechargeOrders returns the removed IDs of the "recharge_orders" edge to the RechargeOrder entity.
func (m *UserMutation) RemovedRechargeOrdersIDs() (ids []int64) {
	for id := range m.removedrecharge_orders {
		ids = append(ids, id)
	}
	return
}

// RechargeOrdersIDs returns the "recharge_orders" edge IDs in the mutation.
func (m *UserMutation) RechargeOrdersIDs() (ids []int64) {
	for id := range m.recharge_orders {
		ids = append(ids, id)
	}
	return
}

// ResetRechargeOrders resets all changes to the "recharge_orders" edge.
func (m *UserMutation) ResetRechargeOrders() {
	m.recharge_orders = nil
	m.clearedrecharge_orders = false
	m.removedrecharge_orders = nil
}

// AddReferralRewardsGivenIDs adds the "referral_rewards_given" edge to the ReferralReward entity by ids.
func (m *UserMutation) AddReferralRewardsGivenIDs(ids ...int64) {
	if m.referral_rewards_given == nil {
		m.referral_rewards_given = make(map[int64]struct{})
	}
	for i := range ids {
		m.referral_rewards_given[ids[i]] = struct{}{}
	}
}

// ClearReferralRewardsGiven clears the "referral_rewards_given" edge to the ReferralReward entity.
func (m *UserMutation) ClearReferralRewardsGiven() {
	m.clearedreferral_rewards_given = true
}

// ReferralRewardsGivenCleared reports if the "referral_rewards_given" edge to the ReferralReward entity was cleared.
func (m *UserMutation) ReferralRewardsGivenCleared() bool {
	return m.clearedreferral_rewards_given
}

// RemoveReferralRewardsGivenIDs removes the "referral_rewards_given" edge to the ReferralReward entity by IDs.
func (m *UserMutation) RemoveReferralRewardsGivenIDs(ids ...int64) {
	if m.removedreferral_rewards_given == nil {
		m.removedreferral_rewards_given = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.referral_rewards_given, ids[i])
		m.removedreferral_rewards_given[ids[i]] = struct{}{}
	}
}

// RemovedReferralRewardsGiven returns the removed IDs of the "referral_rewards_given" edge to the ReferralReward entity.
func (m *UserMutation) RemovedReferralRewardsGivenIDs() (ids []int64) {
	for id := range m.removedreferral_rewards_given {
		ids = append(ids, id)
	}
	return
}

// ReferralRewardsGivenIDs returns the "referral_rewards_given" edge IDs in the mutation.
func (m *UserMutation) ReferralRewardsGivenIDs() (ids []int64) {
	for id := range m.referral_rewards_given {
		ids = append(ids, id)
	}
	return
}

// ResetReferralRewardsGiven resets all changes to the "referral_rewards_given" edge.
func (m *UserMutation) ResetReferralRewardsGiven() {
	m.referral_rewards_given = nil
	m.clearedreferral_rewards_given = false
	m.removedreferral_rewards_given = nil
}

// AddReferralRewardReceivedIDs adds the "referral_reward_received" edge to the ReferralReward entity by ids.
func (m *UserMutation) AddReferralRewardReceivedIDs(ids ...int64) {
	if m.referral_reward_received == nil {
		m.referral_reward_received = make(map[int64]struct{})
	}
	for i := range ids {
		m.referral_reward_received[ids[i]] = struct{}{}
	}
}

// ClearReferralRewardReceived clears the "referral_reward_received" edge to the ReferralReward entity.
func (m *UserMutation) ClearReferralRewardReceived() {
	m.clearedreferral_reward_received = true
}

// ReferralRewardReceivedCleared reports if the "referral_reward_received" edge to the ReferralReward entity was cleared.
func (m *UserMutation) ReferralRewardReceivedCleared() bool {
	return m.clearedreferral_reward_received
}

// RemoveReferralRewardReceivedIDs removes the "referral_reward_received" edge to the ReferralReward entity by IDs.
func (m *UserMutation) RemoveReferralRewardReceivedIDs(ids ...int64) {
	if m.removedreferral_reward_received == nil {
		m.removedreferral_reward_received = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.referral_reward_received, ids[i])
		m.removedreferral_reward_received[ids[i]] = struct{}{}
	}
}

// RemovedReferralRewardReceived returns the removed IDs of the "referral_reward_received" edge to the ReferralReward entity.
func (m *UserMutation) RemovedReferralRewardReceivedIDs() (ids []int64) {
	for id := range m.removedreferral_reward_received {
		ids = append(ids, id)
	}
	return
}

// ReferralRewardReceivedIDs returns the "referral_reward_received" edge IDs in the mutation.
func (m *UserMutation) ReferralRewardReceivedIDs() (ids []int64) {
	for id := range m.referral_reward_received {
		ids = append(ids, id)
	}
	return
}

// ResetReferralRewardReceived resets all changes to the "referral_reward_received" edge.
func (m *UserMutation) ResetReferralRewardReceived() {
	m.referral_reward_received = nil
	m.clearedreferral_reward_received = false
	m.removedreferral_reward_received = nil
}

// AddSubUserIDs adds the "sub_users" edge to the User entity by ids.
func (m *UserMutation) AddSubUserIDs(ids ...int64) {
	if m.sub_users == nil {
		m.sub_users = make(map[int64]struct{})
	}
	for i := range ids {
		m.sub_users[ids[i]] = struct{}{}
	}
}

// ClearSubUsers clears the "sub_users" edge to the User entity.
func (m *UserMutation) ClearSubUsers() {
	m.clearedsub_users = true
}

// SubUsersCleared reports if the "sub_users" edge to the User entity was cleared.
func (m *UserMutation) SubUsersCleared() bool {
	return m.clearedsub_users
}

// RemoveSubUserIDs removes the "sub_users" edge to the User entity by IDs.
func (m *UserMutation) RemoveSubUserIDs(ids ...int64) {
	if m.removedsub_users == nil {
		m.removedsub_users = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.sub_users, ids[i])
		m.removedsub_users[ids[i]] = struct{}{}
	}
}

// RemovedSubUsers returns the removed IDs of the "sub_users" edge to the User entity.
func (m *UserMutation) RemovedSubUsersIDs() (ids []int64) {
	for id := range m.removedsub_users {
		ids = append(ids, id)
	}
	return
}

// SubUsersIDs returns the "sub_users" edge IDs in the mutation.
func (m *UserMutation) SubUsersIDs() (ids []int64) {
	for id := range m.sub_users {
		ids = append(ids, id)
	}
	return
}

// ResetSubUsers resets all changes to the "sub_users" edge.
func (m *UserMutation) ResetSubUsers() {
	m.sub_users = nil
	m.clearedsub_users = false
	m.removedsub_users = nil
}

// ClearParent clears the "parent" edge to the User entity.
func (m *UserMutation) ClearParent() {
	m.clearedparent = true
	m.clearedFields[user.FieldParentID] = struct{}{}
}

// ParentCleared reports if the "parent" edge to the User entity was cleared.
func (m *UserMutation) ParentCleared() bool {
	return m.ParentIDCleared() || m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *UserMutation) ParentIDs() (ids []int64) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *UserMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddResellerDomainIDs adds the "reseller_domains" edge to the ResellerDomain entity by ids.
func (m *UserMutation) AddResellerDomainIDs(ids ...int64) {
	if m.reseller_domains == nil {
		m.reseller_domains = make(map[int64]struct{})
	}
	for i := range ids {
		m.reseller_domains[ids[i]] = struct{}{}
	}
}

// ClearResellerDomains clears the "reseller_domains" edge to the ResellerDomain entity.
func (m *UserMutation) ClearResellerDomains() {
	m.clearedreseller_domains = true
}

// ResellerDomainsCleared reports if the "reseller_domains" edge to the ResellerDomain entity was cleared.
func (m *UserMutation) ResellerDomainsCleared() bool {
	return m.clearedreseller_domains
}

// RemoveResellerDomainIDs removes the "reseller_domains" edge to the ResellerDomain entity by IDs.
func (m *UserMutation) RemoveResellerDomainIDs(ids ...int64) {
	if m.removedreseller_domains == nil {
		m.removedreseller_domains = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.reseller_domains, ids[i])
		m.removedreseller_domains[ids[i]] = struct{}{}
	}
}

// RemovedResellerDomains returns the removed IDs of the "reseller_domains" edge to the ResellerDomain entity.
func (m *UserMutation) RemovedResellerDomainsIDs() (ids []int64) {
	for id := range m.removedreseller_domains {
		ids = append(ids, id)
	}
	return
}

// ResellerDomainsIDs returns the "reseller_domains" edge IDs in the mutation.
func (m *UserMutation) ResellerDomainsIDs() (ids []int64) {
	for id := range m.reseller_domains {
		ids = append(ids, id)
	}
	return
}

// ResetResellerDomains resets all changes to the "reseller_domains" edge.
func (m *UserMutation) ResetResellerDomains() {
	m.reseller_domains = nil
	m.clearedreseller_domains = false
	m.removedreseller_domains = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password_hash != nil {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.role != nil {
		fields = append(fields, user.FieldRole)
	}
	if m.balance != nil {
		fields = append(fields, user.FieldBalance)
	}
	if m.concurrency != nil {
		fields = append(fields, user.FieldConcurrency)
	}
	if m.status != nil {
		fields = append(fields, user.FieldStatus)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.notes != nil {
		fields = append(fields, user.FieldNotes)
	}
	if m.referral_code != nil {
		fields = append(fields, user.FieldReferralCode)
	}
	if m.referred_by != nil {
		fields = append(fields, user.FieldReferredBy)
	}
	if m.referral_rewarded != nil {
		fields = append(fields, user.FieldReferralRewarded)
	}
	if m.totp_secret_encrypted != nil {
		fields = append(fields, user.FieldTotpSecretEncrypted)
	}
	if m.totp_enabled != nil {
		fields = append(fields, user.FieldTotpEnabled)
	}
	if m.totp_enabled_at != nil {
		fields = append(fields, user.FieldTotpEnabledAt)
	}
	if m.parent != nil {
		fields = append(fields, user.FieldParentID)
	}
	if m.token_version != nil {
		fields = append(fields, user.FieldTokenVersion)
	}
	if m.role_version != nil {
		fields = append(fields, user.FieldRoleVersion)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldDeletedAt:
		return m.DeletedAt()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPasswordHash:
		return m.PasswordHash()
	case user.FieldRole:
		return m.Role()
	case user.FieldBalance:
		return m.Balance()
	case user.FieldConcurrency:
		return m.Concurrency()
	case user.FieldStatus:
		return m.Status()
	case user.FieldUsername:
		return m.Username()
	case user.FieldNotes:
		return m.Notes()
	case user.FieldReferralCode:
		return m.ReferralCode()
	case user.FieldReferredBy:
		return m.ReferredBy()
	case user.FieldReferralRewarded:
		return m.ReferralRewarded()
	case user.FieldTotpSecretEncrypted:
		return m.TotpSecretEncrypted()
	case user.FieldTotpEnabled:
		return m.TotpEnabled()
	case user.FieldTotpEnabledAt:
		return m.TotpEnabledAt()
	case user.FieldParentID:
		return m.ParentID()
	case user.FieldTokenVersion:
		return m.TokenVersion()
	case user.FieldRoleVersion:
		return m.RoleVersion()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case user.FieldRole:
		return m.OldRole(ctx)
	case user.FieldBalance:
		return m.OldBalance(ctx)
	case user.FieldConcurrency:
		return m.OldConcurrency(ctx)
	case user.FieldStatus:
		return m.OldStatus(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldNotes:
		return m.OldNotes(ctx)
	case user.FieldReferralCode:
		return m.OldReferralCode(ctx)
	case user.FieldReferredBy:
		return m.OldReferredBy(ctx)
	case user.FieldReferralRewarded:
		return m.OldReferralRewarded(ctx)
	case user.FieldTotpSecretEncrypted:
		return m.OldTotpSecretEncrypted(ctx)
	case user.FieldTotpEnabled:
		return m.OldTotpEnabled(ctx)
	case user.FieldTotpEnabledAt:
		return m.OldTotpEnabledAt(ctx)
	case user.FieldParentID:
		return m.OldParentID(ctx)
	case user.FieldTokenVersion:
		return m.OldTokenVersion(ctx)
	case user.FieldRoleVersion:
		return m.OldRoleVersion(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case user.FieldRole:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case user.FieldBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalance(v)
		return nil
	case user.FieldConcurrency:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConcurrency(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	case user.FieldReferralCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferralCode(v)
		return nil
	case user.FieldReferredBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferredBy(v)
		return nil
	case user.FieldReferralRewarded:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferralRewarded(v)
		return nil
	case user.FieldTotpSecretEncrypted:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotpSecretEncrypted(v)
		return nil
	case user.FieldTotpEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotpEnabled(v)
		return nil
	case user.FieldTotpEnabledAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotpEnabledAt(v)
		return nil
	case user.FieldParentID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case user.FieldTokenVersion:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenVersion(v)
		return nil
	case user.FieldRoleVersion:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleVersion(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addbalance != nil {
		fields = append(fields, user.FieldBalance)
	}
	if m.addconcurrency != nil {
		fields = append(fields, user.FieldConcurrency)
	}
	if m.addreferred_by != nil {
		fields = append(fields, user.FieldReferredBy)
	}
	if m.addtoken_version != nil {
		fields = append(fields, user.FieldTokenVersion)
	}
	if m.addrole_version != nil {
		fields = append(fields, user.FieldRoleVersion)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldBalance:
		return m.AddedBalance()
	case user.FieldConcurrency:
		return m.AddedConcurrency()
	case user.FieldReferredBy:
		return m.AddedReferredBy()
	case user.FieldTokenVersion:
		return m.AddedTokenVersion()
	case user.FieldRoleVersion:
		return m.AddedRoleVersion()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBalance(v)
		return nil
	case user.FieldConcurrency:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddConcurrency(v)
		return nil
	case user.FieldReferredBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReferredBy(v)
		return nil
	case user.FieldTokenVersion:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTokenVersion(v)
		return nil
	case user.FieldRoleVersion:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRoleVersion(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldDeletedAt) {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.FieldCleared(user.FieldReferralCode) {
		fields = append(fields, user.FieldReferralCode)
	}
	if m.FieldCleared(user.FieldReferredBy) {
		fields = append(fields, user.FieldReferredBy)
	}
	if m.FieldCleared(user.FieldTotpSecretEncrypted) {
		fields = append(fields, user.FieldTotpSecretEncrypted)
	}
	if m.FieldCleared(user.FieldTotpEnabledAt) {
		fields = append(fields, user.FieldTotpEnabledAt)
	}
	if m.FieldCleared(user.FieldParentID) {
		fields = append(fields, user.FieldParentID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case user.FieldReferralCode:
		m.ClearReferralCode()
		return nil
	case user.FieldReferredBy:
		m.ClearReferredBy()
		return nil
	case user.FieldTotpSecretEncrypted:
		m.ClearTotpSecretEncrypted()
		return nil
	case user.FieldTotpEnabledAt:
		m.ClearTotpEnabledAt()
		return nil
	case user.FieldParentID:
		m.ClearParentID()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case user.FieldRole:
		m.ResetRole()
		return nil
	case user.FieldBalance:
		m.ResetBalance()
		return nil
	case user.FieldConcurrency:
		m.ResetConcurrency()
		return nil
	case user.FieldStatus:
		m.ResetStatus()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldNotes:
		m.ResetNotes()
		return nil
	case user.FieldReferralCode:
		m.ResetReferralCode()
		return nil
	case user.FieldReferredBy:
		m.ResetReferredBy()
		return nil
	case user.FieldReferralRewarded:
		m.ResetReferralRewarded()
		return nil
	case user.FieldTotpSecretEncrypted:
		m.ResetTotpSecretEncrypted()
		return nil
	case user.FieldTotpEnabled:
		m.ResetTotpEnabled()
		return nil
	case user.FieldTotpEnabledAt:
		m.ResetTotpEnabledAt()
		return nil
	case user.FieldParentID:
		m.ResetParentID()
		return nil
	case user.FieldTokenVersion:
		m.ResetTokenVersion()
		return nil
	case user.FieldRoleVersion:
		m.ResetRoleVersion()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 16)
	if m.api_keys != nil {
		edges = append(edges, user.EdgeAPIKeys)
	}
	if m.redeem_codes != nil {
		edges = append(edges, user.EdgeRedeemCodes)
	}
	if m.subscriptions != nil {
		edges = append(edges, user.EdgeSubscriptions)
	}
	if m.assigned_subscriptions != nil {
		edges = append(edges, user.EdgeAssignedSubscriptions)
	}
	if m.announcement_reads != nil {
		edges = append(edges, user.EdgeAnnouncementReads)
	}
	if m.allowed_groups != nil {
		edges = append(edges, user.EdgeAllowedGroups)
	}
	if m.usage_logs != nil {
		edges = append(edges, user.EdgeUsageLogs)
	}
	if m.attribute_values != nil {
		edges = append(edges, user.EdgeAttributeValues)
	}
	if m.promo_code_usages != nil {
		edges = append(edges, user.EdgePromoCodeUsages)
	}
	if m.orders != nil {
		edges = append(edges, user.EdgeOrders)
	}
	if m.recharge_orders != nil {
		edges = append(edges, user.EdgeRechargeOrders)
	}
	if m.referral_rewards_given != nil {
		edges = append(edges, user.EdgeReferralRewardsGiven)
	}
	if m.referral_reward_received != nil {
		edges = append(edges, user.EdgeReferralRewardReceived)
	}
	if m.sub_users != nil {
		edges = append(edges, user.EdgeSubUsers)
	}
	if m.parent != nil {
		edges = append(edges, user.EdgeParent)
	}
	if m.reseller_domains != nil {
		edges = append(edges, user.EdgeResellerDomains)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeAPIKeys:
		ids := make([]ent.Value, 0, len(m.api_keys))
		for id := range m.api_keys {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRedeemCodes:
		ids := make([]ent.Value, 0, len(m.redeem_codes))
		for id := range m.redeem_codes {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSubscriptions:
		ids := make([]ent.Value, 0, len(m.subscriptions))
		for id := range m.subscriptions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAssignedSubscriptions:
		ids := make([]ent.Value, 0, len(m.assigned_subscriptions))
		for id := range m.assigned_subscriptions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAnnouncementReads:
		ids := make([]ent.Value, 0, len(m.announcement_reads))
		for id := range m.announcement_reads {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAllowedGroups:
		ids := make([]ent.Value, 0, len(m.allowed_groups))
		for id := range m.allowed_groups {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUsageLogs:
		ids := make([]ent.Value, 0, len(m.usage_logs))
		for id := range m.usage_logs {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAttributeValues:
		ids := make([]ent.Value, 0, len(m.attribute_values))
		for id := range m.attribute_values {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePromoCodeUsages:
		ids := make([]ent.Value, 0, len(m.promo_code_usages))
		for id := range m.promo_code_usages {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.orders))
		for id := range m.orders {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRechargeOrders:
		ids := make([]ent.Value, 0, len(m.recharge_orders))
		for id := range m.recharge_orders {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeReferralRewardsGiven:
		ids := make([]ent.Value, 0, len(m.referral_rewards_given))
		for id := range m.referral_rewards_given {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeReferralRewardReceived:
		ids := make([]ent.Value, 0, len(m.referral_reward_received))
		for id := range m.referral_reward_received {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSubUsers:
		ids := make([]ent.Value, 0, len(m.sub_users))
		for id := range m.sub_users {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeResellerDomains:
		ids := make([]ent.Value, 0, len(m.reseller_domains))
		for id := range m.reseller_domains {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 16)
	if m.removedapi_keys != nil {
		edges = append(edges, user.EdgeAPIKeys)
	}
	if m.removedredeem_codes != nil {
		edges = append(edges, user.EdgeRedeemCodes)
	}
	if m.removedsubscriptions != nil {
		edges = append(edges, user.EdgeSubscriptions)
	}
	if m.removedassigned_subscriptions != nil {
		edges = append(edges, user.EdgeAssignedSubscriptions)
	}
	if m.removedannouncement_reads != nil {
		edges = append(edges, user.EdgeAnnouncementReads)
	}
	if m.removedallowed_groups != nil {
		edges = append(edges, user.EdgeAllowedGroups)
	}
	if m.removedusage_logs != nil {
		edges = append(edges, user.EdgeUsageLogs)
	}
	if m.removedattribute_values != nil {
		edges = append(edges, user.EdgeAttributeValues)
	}
	if m.removedpromo_code_usages != nil {
		edges = append(edges, user.EdgePromoCodeUsages)
	}
	if m.removedorders != nil {
		edges = append(edges, user.EdgeOrders)
	}
	if m.removedrecharge_orders != nil {
		edges = append(edges, user.EdgeRechargeOrders)
	}
	if m.removedreferral_rewards_given != nil {
		edges = append(edges, user.EdgeReferralRewardsGiven)
	}
	if m.removedreferral_reward_received != nil {
		edges = append(edges, user.EdgeReferralRewardReceived)
	}
	if m.removedsub_users != nil {
		edges = append(edges, user.EdgeSubUsers)
	}
	if m.removedreseller_domains != nil {
		edges = append(edges, user.EdgeResellerDomains)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeAPIKeys:
		ids := make([]ent.Value, 0, len(m.removedapi_keys))
		for id := range m.removedapi_keys {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRedeemCodes:
		ids := make([]ent.Value, 0, len(m.removedredeem_codes))
		for id := range m.removedredeem_codes {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSubscriptions:
		ids := make([]ent.Value, 0, len(m.removedsubscriptions))
		for id := range m.removedsubscriptions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAssignedSubscriptions:
		ids := make([]ent.Value, 0, len(m.removedassigned_subscriptions))
		for id := range m.removedassigned_subscriptions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAnnouncementReads:
		ids := make([]ent.Value, 0, len(m.removedannouncement_reads))
		for id := range m.removedannouncement_reads {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAllowedGroups:
		ids := make([]ent.Value, 0, len(m.removedallowed_groups))
		for id := range m.removedallowed_groups {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUsageLogs:
		ids := make([]ent.Value, 0, len(m.removedusage_logs))
		for id := range m.removedusage_logs {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAttributeValues:
		ids := make([]ent.Value, 0, len(m.removedattribute_values))
		for id := range m.removedattribute_values {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePromoCodeUsages:
		ids := make([]ent.Value, 0, len(m.removedpromo_code_usages))
		for id := range m.removedpromo_code_usages {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.removedorders))
		for id := range m.removedorders {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRechargeOrders:
		ids := make([]ent.Value, 0, len(m.removedrecharge_orders))
		for id := range m.removedrecharge_orders {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeReferralRewardsGiven:
		ids := make([]ent.Value, 0, len(m.removedreferral_rewards_given))
		for id := range m.removedreferral_rewards_given {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeReferralRewardReceived:
		ids := make([]ent.Value, 0, len(m.removedreferral_reward_received))
		for id := range m.removedreferral_reward_received {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSubUsers:
		ids := make([]ent.Value, 0, len(m.removedsub_users))
		for id := range m.removedsub_users {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeResellerDomains:
		ids := make([]ent.Value, 0, len(m.removedreseller_domains))
		for id := range m.removedreseller_domains {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 16)
	if m.clearedapi_keys {
		edges = append(edges, user.EdgeAPIKeys)
	}
	if m.clearedredeem_codes {
		edges = append(edges, user.EdgeRedeemCodes)
	}
	if m.clearedsubscriptions {
		edges = append(edges, user.EdgeSubscriptions)
	}
	if m.clearedassigned_subscriptions {
		edges = append(edges, user.EdgeAssignedSubscriptions)
	}
	if m.clearedannouncement_reads {
		edges = append(edges, user.EdgeAnnouncementReads)
	}
	if m.clearedallowed_groups {
		edges = append(edges, user.EdgeAllowedGroups)
	}
	if m.clearedusage_logs {
		edges = append(edges, user.EdgeUsageLogs)
	}
	if m.clearedattribute_values {
		edges = append(edges, user.EdgeAttributeValues)
	}
	if m.clearedpromo_code_usages {
		edges = append(edges, user.EdgePromoCodeUsages)
	}
	if m.clearedorders {
		edges = append(edges, user.EdgeOrders)
	}
	if m.clearedrecharge_orders {
		edges = append(edges, user.EdgeRechargeOrders)
	}
	if m.clearedreferral_rewards_given {
		edges = append(edges, user.EdgeReferralRewardsGiven)
	}
	if m.clearedreferral_reward_received {
		edges = append(edges, user.EdgeReferralRewardReceived)
	}
	if m.clearedsub_users {
		edges = append(edges, user.EdgeSubUsers)
	}
	if m.clearedparent {
		edges = append(edges, user.EdgeParent)
	}
	if m.clearedreseller_domains {
		edges = append(edges, user.EdgeResellerDomains)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeAPIKeys:
		return m.clearedapi_keys
	case user.EdgeRedeemCodes:
		return m.clearedredeem_codes
	case user.EdgeSubscriptions:
		return m.clearedsubscriptions
	case user.EdgeAssignedSubscriptions:
		return m.clearedassigned_subscriptions
	case user.EdgeAnnouncementReads:
		return m.clearedannouncement_reads
	case user.EdgeAllowedGroups:
		return m.clearedallowed_groups
	case user.EdgeUsageLogs:
		return m.clearedusage_logs
	case user.EdgeAttributeValues:
		return m.clearedattribute_values
	case user.EdgePromoCodeUsages:
		return m.clearedpromo_code_usages
	case user.EdgeOrders:
		return m.clearedorders
	case user.EdgeRechargeOrders:
		return m.clearedrecharge_orders
	case user.EdgeReferralRewardsGiven:
		return m.clearedreferral_rewards_given
	case user.EdgeReferralRewardReceived:
		return m.clearedreferral_reward_received
	case user.EdgeSubUsers:
		return m.clearedsub_users
	case user.EdgeParent:
		return m.clearedparent
	case user.EdgeResellerDomains:
		return m.clearedreseller_domains
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeAPIKeys:
		m.ResetAPIKeys()
		return nil
	case user.EdgeRedeemCodes:
		m.ResetRedeemCodes()
		return nil
	case user.EdgeSubscriptions:
		m.ResetSubscriptions()
		return nil
	case user.EdgeAssignedSubscriptions:
		m.ResetAssignedSubscriptions()
		return nil
	case user.EdgeAnnouncementReads:
		m.ResetAnnouncementReads()
		return nil
	case user.EdgeAllowedGroups:
		m.ResetAllowedGroups()
		return nil
	case user.EdgeUsageLogs:
		m.ResetUsageLogs()
		return nil
	case user.EdgeAttributeValues:
		m.ResetAttributeValues()
		return nil
	case user.EdgePromoCodeUsages:
		m.ResetPromoCodeUsages()
		return nil
	case user.EdgeOrders:
		m.ResetOrders()
		return nil
	case user.EdgeRechargeOrders:
		m.ResetRechargeOrders()
		return nil
	case user.EdgeReferralRewardsGiven:
		m.ResetReferralRewardsGiven()
		return nil
	case user.EdgeReferralRewardReceived:
		m.ResetReferralRewardReceived()
		return nil
	case user.EdgeSubUsers:
		m.ResetSubUsers()
		return nil
	case user.EdgeParent:
		m.ResetParent()
		return nil
	case user.EdgeResellerDomains:
		m.ResetResellerDomains()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserAllowedGroupMutation represents an operation that mutates the UserAllowedGroup nodes in the graph.
type UserAllowedGroupMutation struct {
	config
	op            Op
	typ           string
	created_at    *time.Time
	clearedFields map[string]struct{}
	user          *int64
	cleareduser   bool
	group         *int64
	clearedgroup  bool
	done          bool
	oldValue      func(context.Context) (*UserAllowedGroup, error)
	predicates    []predicate.UserAllowedGroup
}

var _ ent.Mutation = (*UserAllowedGroupMutation)(nil)

// userallowedgroupOption allows management of the mutation configuration using functional options.
type userallowedgroupOption func(*UserAllowedGroupMutation)

// newUserAllowedGroupMutation creates new mutation for the UserAllowedGroup entity.
func newUserAllowedGroupMutation(c config, op Op, opts ...userallowedgroupOption) *UserAllowedGroupMutation {
	m := &UserAllowedGroupMutation{
		config:        c,
		op:            op,
		typ:           TypeUserAllowedGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserAllowedGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserAllowedGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetUserID sets the "user_id" field.
func (m *UserAllowedGroupMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserAllowedGroupMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserAllowedGroupMutation) ResetUserID() {
	m.user = nil
}

// SetGroupID sets the "group_id" field.
func (m *UserAllowedGroupMutation) SetGroupID(i int64) {
	m.group = &i
}

// GroupID returns the value of the "group_id" field in the mutation.
func (m *UserAllowedGroupMutation) GroupID() (r int64, exists bool) {
	v := m.group
	if v == nil {
		return
	}
	return *v, true
}

// ResetGroupID resets all changes to the "group_id" field.
func (m *UserAllowedGroupMutation) ResetGroupID() {
	m.group = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserAllowedGroupMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserAllowedGroupMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserAllowedGroupMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserAllowedGroupMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[userallowedgroup.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserAllowedGroupMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserAllowedGroupMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserAllowedGroupMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearGroup clears the "group" edge to the Group entity.
func (m *UserAllowedGroupMutation) ClearGroup() {
	m.clearedgroup = true
	m.clearedFields[userallowedgroup.FieldGroupID] = struct{}{}
}

// GroupCleared reports if the "group" edge to the Group entity was cleared.
func (m *UserAllowedGroupMutation) GroupCleared() bool {
	return m.clearedgroup
}

// GroupIDs returns the "group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupID instead. It exists only for internal usage by the builders.
func (m *UserAllowedGroupMutation) GroupIDs() (ids []int64) {
	if id := m.group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroup resets all changes to the "group" edge.
func (m *UserAllowedGroupMutation) ResetGroup() {
	m.group = nil
	m.clearedgroup = false
}

// Where appends a list predicates to the UserAllowedGroupMutation builder.
func (m *UserAllowedGroupMutation) Where(ps ...predicate.UserAllowedGroup) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserAllowedGroupMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserAllowedGroupMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserAllowedGroup, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserAllowedGroupMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserAllowedGroupMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserAllowedGroup).
func (m *UserAllowedGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserAllowedGroupMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.user != nil {
		fields = append(fields, userallowedgroup.FieldUserID)
	}
	if m.group != nil {
		fields = append(fields, userallowedgroup.FieldGroupID)
	}
	if m.created_at != nil {
		fields = append(fields, userallowedgroup.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserAllowedGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userallowedgroup.FieldUserID:
		return m.UserID()
	case userallowedgroup.FieldGroupID:
		return m.GroupID()
	case userallowedgroup.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserAllowedGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, errors.New("edge schema UserAllowedGroup does not support getting old values")
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserAllowedGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userallowedgroup.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userallowedgroup.FieldGroupID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupID(v)
		return nil
	case userallowedgroup.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserAllowedGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserAllowedGroupMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserAllowedGroupMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserAllowedGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserAllowedGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserAllowedGroupMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserAllowedGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserAllowedGroupMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserAllowedGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserAllowedGroupMutation) ResetField(name string) error {
	switch name {
	case userallowedgroup.FieldUserID:
		m.ResetUserID()
		return nil
	case userallowedgroup.FieldGroupID:
		m.ResetGroupID()
		return nil
	case userallowedgroup.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown UserAllowedGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserAllowedGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, userallowedgroup.EdgeUser)
	}
	if m.group != nil {
		edges = append(edges, userallowedgroup.EdgeGroup)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserAllowedGroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userallowedgroup.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case userallowedgroup.EdgeGroup:
		if id := m.group; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserAllowedGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserAllowedGroupMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserAllowedGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, userallowedgroup.EdgeUser)
	}
	if m.clearedgroup {
		edges = append(edges, userallowedgroup.EdgeGroup)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserAllowedGroupMutation) EdgeCleared(name string) bool {
	switch name {
	case userallowedgroup.EdgeUser:
		return m.cleareduser
	case userallowedgroup.EdgeGroup:
		return m.clearedgroup
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserAllowedGroupMutation) ClearEdge(name string) error {
	switch name {
	case userallowedgroup.EdgeUser:
		m.ClearUser()
		return nil
	case userallowedgroup.EdgeGroup:
		m.ClearGroup()
		return nil
	}
	return fmt.Errorf("unknown UserAllowedGroup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserAllowedGroupMutation) ResetEdge(name string) error {
	switch name {
	case userallowedgroup.EdgeUser:
		m.ResetUser()
		return nil
	case userallowedgroup.EdgeGroup:
		m.ResetGroup()
		return nil
	}
	return fmt.Errorf("unknown UserAllowedGroup edge %s", name)
}

// UserAttributeDefinitionMutation represents an operation that mutates the UserAttributeDefinition nodes in the graph.
type UserAttributeDefinitionMutation struct {
	config
	op               Op
	typ              string
	id               *int64
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	key              *string
	name             *string
	description      *string
	_type            *string
	options          *[]map[string]interface{}
	appendoptions    []map[string]interface{}
	required         *bool
	validation       *map[string]interface{}
	placeholder      *string
	display_order    *int
	adddisplay_order *int
	enabled          *bool
	clearedFields    map[string]struct{}
	values           map[int64]struct{}
	removedvalues    map[int64]struct{}
	clearedvalues    bool
	done             bool
	oldValue         func(context.Context) (*UserAttributeDefinition, error)
	predicates       []predicate.UserAttributeDefinition
}

var _ ent.Mutation = (*UserAttributeDefinitionMutation)(nil)

// userattributedefinitionOption allows management of the mutation configuration using functional options.
type userattributedefinitionOption func(*UserAttributeDefinitionMutation)

// newUserAttributeDefinitionMutation creates new mutation for the UserAttributeDefinition entity.
func newUserAttributeDefinitionMutation(c config, op Op, opts ...userattributedefinitionOption) *UserAttributeDefinitionMutation {
	m := &UserAttributeDefinitionMutation{
		config:        c,
		op:            op,
		typ:           TypeUserAttributeDefinition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserAttributeDefinitionID sets the ID field of the mutation.
func withUserAttributeDefinitionID(id int64) userattributedefinitionOption {
	return func(m *UserAttributeDefinitionMutation) {
		var (
			err   error
			once  sync.Once
			value *UserAttributeDefinition
		)
		m.oldValue = func(ctx context.Context) (*UserAttributeDefinition, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserAttributeDefinition.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserAttributeDefinition sets the old UserAttributeDefinition of the mutation.
func withUserAttributeDefinition(node *UserAttributeDefinition) userattributedefinitionOption {
	return func(m *UserAttributeDefinitionMutation) {
		m.oldValue = func(context.Context) (*UserAttributeDefinition, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserAttributeDefinitionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserAttributeDefinitionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserAttributeDefinitionMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserAttributeDefinitionMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserAttributeDefinition.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserAttributeDefinitionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserAttributeDefinitionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserAttributeDefinition entity.
// If the UserAttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAttributeDefinitionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserAttributeDefinitionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserAttributeDefinitionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserAttributeDefinitionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserAttributeDefinition entity.
// If the UserAttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAttributeDefinitionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserAttributeDefinitionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserAttributeDefinitionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserAttributeDefinitionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the UserAttributeDefinition entity.
// If the UserAttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAttributeDefinitionMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserAttributeDefinitionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[userattributedefinition.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserAttributeDefinitionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[userattributedefinition.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserAttributeDefinitionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, userattributedefinition.FieldDeletedAt)
}

// SetKey sets the "key" field.
func (m *UserAttributeDefinitionMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *UserAttributeDefinitionMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the UserAttributeDefinition entity.
// If the UserAttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAttributeDefinitionMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *UserAttributeDefinitionMutation) ResetKey() {
	m.key = nil
}

// SetName sets the "name" field.
func (m *UserAttributeDefinitionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserAttributeDefinitionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the UserAttributeDefinition entity.
// If the UserAttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAttributeDefinitionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserAttributeDefinitionMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *UserAttributeDefinitionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *UserAttributeDefinitionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the UserAttributeDefinition entity.
// If the UserAttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAttributeDefinitionMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *UserAttributeDefinitionMutation) ResetDescription() {
	m.description = nil
}

// SetType sets the "type" field.
func (m *UserAttributeDefinitionMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *UserAttributeDefinitionMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the UserAttributeDefinition entity.
// If the UserAttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAttributeDefinitionMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *UserAttributeDefinitionMutation) ResetType() {
	m._type = nil
}

// SetOptions sets the "options" field.
func (m *UserAttributeDefinitionMutation) SetOptions(value []map[string]interface{}) {
	m.options = &value
	m.appendoptions = nil
}

// Options returns the value of the "options" field in the mutation.
func (m *UserAttributeDefinitionMutation) Options() (r []map[string]interface{}, exists bool) {
	v := m.options
	if v == nil {
		return
	}
	return *v, true
}

// OldOptions returns the old "options" field's value of the UserAttributeDefinition entity.
// If the UserAttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAttributeDefinitionMutation) OldOptions(ctx context.Context) (v []map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOptions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOptions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOptions: %w", err)
	}
	return oldValue.Options, nil
}

// AppendOptions adds value to the "options" field.
func (m *UserAttributeDefinitionMutation) AppendOptions(value []map[string]interface{}) {
	m.appendoptions = append(m.appendoptions, value...)
}

// AppendedOptions returns the list of values that were appended to the "options" field in this mutation.
func (m *UserAttributeDefinitionMutation) AppendedOptions() ([]map[string]interface{}, bool) {
	if len(m.appendoptions) == 0 {
		return nil, false
	}
	return m.appendoptions, true
}

// ResetOptions resets all changes to the "options" field.
func (m *UserAttributeDefinitionMutation) ResetOptions() {
	m.options = nil
	m.appendoptions = nil
}

// SetRequired sets the "required" field.
func (m *UserAttributeDefinitionMutation) SetRequired(b bool) {
	m.required = &b
}

// Required returns the value of the "required" field in the mutation.
func (m *UserAttributeDefinitionMutation) Required() (r bool, exists bool) {
	v := m.required
	if v == nil {
		return
	}
	return *v, true
}

// OldRequired returns the old "required" field's value of the UserAttributeDefinition entity.
// If the UserAttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAttributeDefinitionMutation) OldRequired(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequired: %w", err)
	}
	return oldValue.Required, nil
}

// ResetRequired resets all changes to the "required" field.
func (m *UserAttributeDefinitionMutation) ResetRequired() {
	m.required = nil
}

// SetValidation sets the "validation" field.
func (m *UserAttributeDefinitionMutation) SetValidation(value map[string]interface{}) {
	m.validation = &value
}

// Validation returns the value of the "validation" field in the mutation.
func (m *UserAttributeDefinitionMutation) Validation() (r map[string]interface{}, exists bool) {
	v := m.validation
	if v == nil {
		return
	}
	return *v, true
}

// OldValidation returns the old "validation" field's value of the UserAttributeDefinition entity.
// If the UserAttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAttributeDefinitionMutation) OldValidation(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValidation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValidation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValidation: %w", err)
	}
	return oldValue.Validation, nil
}

// ResetValidation resets all changes to the "validation" field.
func (m *UserAttributeDefinitionMutation) ResetValidation() {
	m.validation = nil
}

// SetPlaceholder sets the "placeholder" field.
func (m *UserAttributeDefinitionMutation) SetPlaceholder(s string) {
	m.placeholder = &s
}

// Placeholder returns the value of the "placeholder" field in the mutation.
func (m *UserAttributeDefinitionMutation) Placeholder() (r string, exists bool) {
	v := m.placeholder
	if v == nil {
		return
	}
	return *v, true
}

// OldPlaceholder returns the old "placeholder" field's value of the UserAttributeDefinition entity.
// If the UserAttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAttributeDefinitionMutation) OldPlaceholder(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlaceholder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlaceholder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlaceholder: %w", err)
	}
	return oldValue.Placeholder, nil
}

// ResetPlaceholder resets all changes to the "placeholder" field.
func (m *UserAttributeDefinitionMutation) ResetPlaceholder() {
	m.placeholder = nil
}

// SetDisplayOrder sets the "display_order" field.
func (m *UserAttributeDefinitionMutation) SetDisplayOrder(i int) {
	m.display_order = &i
	m.adddisplay_order = nil
}

// DisplayOrder returns the value of the "display_order" field in the mutation.
func (m *UserAttributeDefinitionMutation) DisplayOrder() (r int, exists bool) {
	v := m.display_order
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayOrder returns the old "display_order" field's value of the UserAttributeDefinition entity.
// If the UserAttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAttributeDefinitionMutation) OldDisplayOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayOrder: %w", err)
	}
	return oldValue.DisplayOrder, nil
}

// AddDisplayOrder adds i to the "display_order" field.
func (m *UserAttributeDefinitionMutation) AddDisplayOrder(i int) {
	if m.adddisplay_order != nil {
		*m.adddisplay_order += i
	} else {
		m.adddisplay_order = &i
	}
}

// AddedDisplayOrder returns the value that was added to the "display_order" field in this mutation.
func (m *UserAttributeDefinitionMutation) AddedDisplayOrder() (r int, exists bool) {
	v := m.adddisplay_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetDisplayOrder resets all changes to the "display_order" field.
func (m *UserAttributeDefinitionMutation) ResetDisplayOrder() {
	m.display_order = nil
	m.adddisplay_order = nil
}

// SetEnabled sets the "enabled" field.
func (m *UserAttributeDefinitionMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *UserAttributeDefinitionMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the UserAttributeDefinition entity.
// If the UserAttributeDefinition object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAttributeDefinitionMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *UserAttributeDefinitionMutation) ResetEnabled() {
	m.enabled = nil
}

// AddValueIDs adds the "values" edge to the UserAttributeValue entity by ids.
func (m *UserAttributeDefinitionMutation) AddValueIDs(ids ...int64) {
	if m.values == nil {
		m.values = make(map[int64]struct{})
	}
	for i := range ids {
		m.values[ids[i]] = struct{}{}
	}
}

// ClearValues clears the "values" edge to the UserAttributeValue entity.
func (m *UserAttributeDefinitionMutation) ClearValues() {
	m.clearedvalues = true
}

// ValuesCleared reports if the "values" edge to the UserAttributeValue entity was cleared.
func (m *UserAttributeDefinitionMutation) ValuesCleared() bool {
	return m.clearedvalues
}

// RemoveValueIDs removes the "values" edge to the UserAttributeValue entity by IDs.
func (m *UserAttributeDefinitionMutation) RemoveValueIDs(ids ...int64) {
	if m.removedvalues == nil {
		m.removedvalues = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.values, ids[i])
		m.removedvalues[ids[i]] = struct{}{}
	}
}

// RemovedValues returns the removed IDs of the "values" edge to the UserAttributeValue entity.
func (m *UserAttributeDefinitionMutation) RemovedValuesIDs() (ids []int64) {
	for id := range m.removedvalues {
		ids = append(ids, id)
	}
	return
}

// ValuesIDs returns the "values" edge IDs in the mutation.
func (m *UserAttributeDefinitionMutation) ValuesIDs() (ids []int64) {
	for id := range m.values {
		ids = append(ids, id)
	}
	return
}

// ResetValues resets all changes to the "values" edge.
func (m *UserAttributeDefinitionMutation) ResetValues() {
	m.values = nil
	m.clearedvalues = false
	m.removedvalues = nil
}

// Where appends a list predicates to the UserAttributeDefinitionMutation builder.
func (m *UserAttributeDefinitionMutation) Where(ps ...predicate.UserAttributeDefinition) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserAttributeDefinitionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserAttributeDefinitionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserAttributeDefinition, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserAttributeDefinitionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserAttributeDefinitionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserAttributeDefinition).
func (m *UserAttributeDefinitionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserAttributeDefinitionMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, userattributedefinition.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userattributedefinition.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, userattributedefinition.FieldDeletedAt)
	}
	if m.key != nil {
		fields = append(fields, userattributedefinition.FieldKey)
	}
	if m.name != nil {
		fields = append(fields, userattributedefinition.FieldName)
	}
	if m.description != nil {
		fields = append(fields, userattributedefinition.FieldDescription)
	}
	if m._type != nil {
		fields = append(fields, userattributedefinition.FieldType)
	}
	if m.options != nil {
		fields = append(fields, userattributedefinition.FieldOptions)
	}
	if m.required != nil {
		fields = append(fields, userattributedefinition.FieldRequired)
	}
	if m.validation != nil {
		fields = append(fields, userattributedefinition.FieldValidation)
	}
	if m.placeholder != nil {
		fields = append(fields, userattributedefinition.FieldPlaceholder)
	}
	if m.display_order != nil {
		fields = append(fields, userattributedefinition.FieldDisplayOrder)
	}
	if m.enabled != nil {
		fields = append(fields, userattributedefinition.FieldEnabled)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserAttributeDefinitionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userattributedefinition.FieldCreatedAt:
		return m.CreatedAt()
	case userattributedefinition.FieldUpdatedAt:
		return m.UpdatedAt()
	case userattributedefinition.FieldDeletedAt:
		return m.DeletedAt()
	case userattributedefinition.FieldKey:
		return m.Key()
	case userattributedefinition.FieldName:
		return m.Name()
	case userattributedefinition.FieldDescription:
		return m.Description()
	case userattributedefinition.FieldType:
		return m.GetType()
	case userattributedefinition.FieldOptions:
		return m.Options()
	case userattributedefinition.FieldRequired:
		return m.Required()
	case userattributedefinition.FieldValidation:
		return m.Validation()
	case userattributedefinition.FieldPlaceholder:
		return m.Placeholder()
	case userattributedefinition.FieldDisplayOrder:
		return m.DisplayOrder()
	case userattributedefinition.FieldEnabled:
		return m.Enabled()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserAttributeDefinitionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userattributedefinition.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userattributedefinition.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userattributedefinition.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case userattributedefinition.FieldKey:
		return m.OldKey(ctx)
	case userattributedefinition.FieldName:
		return m.OldName(ctx)
	case userattributedefinition.FieldDescription:
		return m.OldDescription(ctx)
	case userattributedefinition.FieldType:
		return m.OldType(ctx)
	case userattributedefinition.FieldOptions:
		return m.OldOptions(ctx)
	case userattributedefinition.FieldRequired:
		return m.OldRequired(ctx)
	case userattributedefinition.FieldValidation:
		return m.OldValidation(ctx)
	case userattributedefinition.FieldPlaceholder:
		return m.OldPlaceholder(ctx)
	case userattributedefinition.FieldDisplayOrder:
		return m.OldDisplayOrder(ctx)
	case userattributedefinition.FieldEnabled:
		return m.OldEnabled(ctx)
	}
	return nil, fmt.Errorf("unknown UserAttributeDefinition field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserAttributeDefinitionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userattributedefinition.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userattributedefinition.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userattributedefinition.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case userattributedefinition.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case userattributedefinition.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case userattributedefinition.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case userattributedefinition.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case userattributedefinition.FieldOptions:
		v, ok := value.([]map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOptions(v)
		return nil
	case userattributedefinition.FieldRequired:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequired(v)
		return nil
	case userattributedefinition.FieldValidation:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValidation(v)
		return nil
	case userattributedefinition.FieldPlaceholder:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlaceholder(v)
		return nil
	case userattributedefinition.FieldDisplayOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayOrder(v)
		return nil
	case userattributedefinition.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	}
	return fmt.Errorf("unknown UserAttributeDefinition field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserAttributeDefinitionMutation) AddedFields() []string {
	var fields []string
	if m.adddisplay_order != nil {
		fields = append(fields, userattributedefinition.FieldDisplayOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserAttributeDefinitionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userattributedefinition.FieldDisplayOrder:
		return m.AddedDisplayOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserAttributeDefinitionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userattributedefinition.FieldDisplayOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDisplayOrder(v)
		return nil
	}
	return fmt.Errorf("unknown UserAttributeDefinition numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserAttributeDefinitionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userattributedefinition.FieldDeletedAt) {
		fields = append(fields, userattributedefinition.FieldDeletedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserAttributeDefinitionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserAttributeDefinitionMutation) ClearField(name string) error {
	switch name {
	case userattributedefinition.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	}
	return fmt.Errorf("unknown UserAttributeDefinition nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserAttributeDefinitionMutation) ResetField(name string) error {
	switch name {
	case userattributedefinition.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userattributedefinition.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userattributedefinition.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case userattributedefinition.FieldKey:
		m.ResetKey()
		return nil
	case userattributedefinition.FieldName:
		m.ResetName()
		return nil
	case userattributedefinition.FieldDescription:
		m.ResetDescription()
		return nil
	case userattributedefinition.FieldType:
		m.ResetType()
		return nil
	case userattributedefinition.FieldOptions:
		m.ResetOptions()
		return nil
	case userattributedefinition.FieldRequired:
		m.ResetRequired()
		return nil
	case userattributedefinition.FieldValidation:
		m.ResetValidation()
		return nil
	case userattributedefinition.FieldPlaceholder:
		m.ResetPlaceholder()
		return nil
	case userattributedefinition.FieldDisplayOrder:
		m.ResetDisplayOrder()
		return nil
	case userattributedefinition.FieldEnabled:
		m.ResetEnabled()
		return nil
	}
	return fmt.Errorf("unknown UserAttributeDefinition field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserAttributeDefinitionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.values != nil {
		edges = append(edges, userattributedefinition.EdgeValues)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserAttributeDefinitionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userattributedefinition.EdgeValues:
		ids := make([]ent.Value, 0, len(m.values))
		for id := range m.values {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserAttributeDefinitionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedvalues != nil {
		edges = append(edges, userattributedefinition.EdgeValues)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserAttributeDefinitionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case userattributedefinition.EdgeValues:
		ids := make([]ent.Value, 0, len(m.removedvalues))
		for id := range m.removedvalues {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserAttributeDefinitionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedvalues {
		edges = append(edges, userattributedefinition.EdgeValues)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserAttributeDefinitionMutation) EdgeCleared(name string) bool {
	switch name {
	case userattributedefinition.EdgeValues:
		return m.clearedvalues
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserAttributeDefinitionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown UserAttributeDefinition unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserAttributeDefinitionMutation) ResetEdge(name string) error {
	switch name {
	case userattributedefinition.EdgeValues:
		m.ResetValues()
		return nil
	}
	return fmt.Errorf("unknown UserAttributeDefinition edge %s", name)
}

// UserAttributeValueMutation represents an operation that mutates the UserAttributeValue nodes in the graph.
type UserAttributeValueMutation struct {
	config
	op                Op
	typ               string
	id                *int64
	created_at        *time.Time
	updated_at        *time.Time
	value             *string
	clearedFields     map[string]struct{}
	user              *int64
	cleareduser       bool
	definition        *int64
	cleareddefinition bool
	done              bool
	oldValue          func(context.Context) (*UserAttributeValue, error)
	predicates        []predicate.UserAttributeValue
}

var _ ent.Mutation = (*UserAttributeValueMutation)(nil)

// userattributevalueOption allows management of the mutation configuration using functional options.
type userattributevalueOption func(*UserAttributeValueMutation)

// newUserAttributeValueMutation creates new mutation for the UserAttributeValue entity.
func newUserAttributeValueMutation(c config, op Op, opts ...userattributevalueOption) *UserAttributeValueMutation {
	m := &UserAttributeValueMutation{
		config:        c,
		op:            op,
		typ:           TypeUserAttributeValue,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserAttributeValueID sets the ID field of the mutation.
func withUserAttributeValueID(id int64) userattributevalueOption {
	return func(m *UserAttributeValueMutation) {
		var (
			err   error
			once  sync.Once
			value *UserAttributeValue
		)
		m.oldValue = func(ctx context.Context) (*UserAttributeValue, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserAttributeValue.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserAttributeValue sets the old UserAttributeValue of the mutation.
func withUserAttributeValue(node *UserAttributeValue) userattributevalueOption {
	return func(m *UserAttributeValueMutation) {
		m.oldValue = func(context.Context) (*UserAttributeValue, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserAttributeValueMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserAttributeValueMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserAttributeValueMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserAttributeValueMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserAttributeValue.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserAttributeValueMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserAttributeValueMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserAttributeValue entity.
// If the UserAttributeValue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAttributeValueMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserAttributeValueMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserAttributeValueMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserAttributeValueMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserAttributeValue entity.
// If the UserAttributeValue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAttributeValueMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserAttributeValueMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user_id" field.
func (m *UserAttributeValueMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserAttributeValueMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserAttributeValue entity.
// If the UserAttributeValue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAttributeValueMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserAttributeValueMutation) ResetUserID() {
	m.user = nil
}

// SetAttributeID sets the "attribute_id" field.
func (m *UserAttributeValueMutation) SetAttributeID(i int64) {
	m.definition = &i
}

// AttributeID returns the value of the "attribute_id" field in the mutation.
func (m *UserAttributeValueMutation) AttributeID() (r int64, exists bool) {
	v := m.definition
	if v == nil {
		return
	}
	return *v, true
}

// OldAttributeID returns the old "attribute_id" field's value of the UserAttributeValue entity.
// If the UserAttributeValue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAttributeValueMutation) OldAttributeID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttributeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttributeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttributeID: %w", err)
	}
	return oldValue.AttributeID, nil
}

// ResetAttributeID resets all changes to the "attribute_id" field.
func (m *UserAttributeValueMutation) ResetAttributeID() {
	m.definition = nil
}

// SetValue sets the "value" field.
func (m *UserAttributeValueMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *UserAttributeValueMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the UserAttributeValue entity.
// If the UserAttributeValue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAttributeValueMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *UserAttributeValueMutation) ResetValue() {
	m.value = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserAttributeValueMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[userattributevalue.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserAttributeValueMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserAttributeValueMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserAttributeValueMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetDefinitionID sets the "definition" edge to the UserAttributeDefinition entity by id.
func (m *UserAttributeValueMutation) SetDefinitionID(id int64) {
	m.definition = &id
}

// ClearDefinition clears the "definition" edge to the UserAttributeDefinition entity.
func (m *UserAttributeValueMutation) ClearDefinition() {
	m.cleareddefinition = true
	m.clearedFields[userattributevalue.FieldAttributeID] = struct{}{}
}

// DefinitionCleared reports if the "definition" edge to the UserAttributeDefinition entity was cleared.
func (m *UserAttributeValueMutation) DefinitionCleared() bool {
	return m.cleareddefinition
}

// DefinitionID returns the "definition" edge ID in the mutation.
func (m *UserAttributeValueMutation) DefinitionID() (id int64, exists bool) {
	if m.definition != nil {
		return *m.definition, true
	}
	return
}

// DefinitionIDs returns the "definition" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DefinitionID instead. It exists only for internal usage by the builders.
func (m *UserAttributeValueMutation) DefinitionIDs() (ids []int64) {
	if id := m.definition; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDefinition resets all changes to the "definition" edge.
func (m *UserAttributeValueMutation) ResetDefinition() {
	m.definition = nil
	m.cleareddefinition = false
}

// Where appends a list predicates to the UserAttributeValueMutation builder.
func (m *UserAttributeValueMutation) Where(ps ...predicate.UserAttributeValue) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserAttributeValueMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserAttributeValueMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserAttributeValue, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserAttributeValueMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserAttributeValueMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserAttributeValue).
func (m *UserAttributeValueMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserAttributeValueMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, userattributevalue.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userattributevalue.FieldUpdatedAt)
	}
	if m.user != nil {
		fields = append(fields, userattributevalue.FieldUserID)
	}
	if m.definition != nil {
		fields = append(fields, userattributevalue.FieldAttributeID)
	}
	if m.value != nil {
		fields = append(fields, userattributevalue.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserAttributeValueMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userattributevalue.FieldCreatedAt:
		return m.CreatedAt()
	case userattributevalue.FieldUpdatedAt:
		return m.UpdatedAt()
	case userattributevalue.FieldUserID:
		return m.UserID()
	case userattributevalue.FieldAttributeID:
		return m.AttributeID()
	case userattributevalue.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserAttributeValueMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userattributevalue.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userattributevalue.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userattributevalue.FieldUserID:
		return m.OldUserID(ctx)
	case userattributevalue.FieldAttributeID:
		return m.OldAttributeID(ctx)
	case userattributevalue.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown UserAttributeValue field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserAttributeValueMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userattributevalue.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userattributevalue.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userattributevalue.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userattributevalue.FieldAttributeID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttributeID(v)
		return nil
	case userattributevalue.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown UserAttributeValue field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserAttributeValueMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserAttributeValueMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserAttributeValueMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserAttributeValue numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserAttributeValueMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserAttributeValueMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserAttributeValueMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserAttributeValue nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserAttributeValueMutation) ResetField(name string) error {
	switch name {
	case userattributevalue.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userattributevalue.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userattributevalue.FieldUserID:
		m.ResetUserID()
		return nil
	case userattributevalue.FieldAttributeID:
		m.ResetAttributeID()
		return nil
	case userattributevalue.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown UserAttributeValue field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserAttributeValueMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, userattributevalue.EdgeUser)
	}
	if m.definition != nil {
		edges = append(edges, userattributevalue.EdgeDefinition)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserAttributeValueMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userattributevalue.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case userattributevalue.EdgeDefinition:
		if id := m.definition; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserAttributeValueMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserAttributeValueMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserAttributeValueMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, userattributevalue.EdgeUser)
	}
	if m.cleareddefinition {
		edges = append(edges, userattributevalue.EdgeDefinition)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserAttributeValueMutation) EdgeCleared(name string) bool {
	switch name {
	case userattributevalue.EdgeUser:
		return m.cleareduser
	case userattributevalue.EdgeDefinition:
		return m.cleareddefinition
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserAttributeValueMutation) ClearEdge(name string) error {
	switch name {
	case userattributevalue.EdgeUser:
		m.ClearUser()
		return nil
	case userattributevalue.EdgeDefinition:
		m.ClearDefinition()
		return nil
	}
	return fmt.Errorf("unknown UserAttributeValue unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserAttributeValueMutation) ResetEdge(name string) error {
	switch name {
	case userattributevalue.EdgeUser:
		m.ResetUser()
		return nil
	case userattributevalue.EdgeDefinition:
		m.ResetDefinition()
		return nil
	}
	return fmt.Errorf("unknown UserAttributeValue edge %s", name)
}

// UserSubscriptionMutation represents an operation that mutates the UserSubscription nodes in the graph.
type UserSubscriptionMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int64
	created_at              *time.Time
	updated_at              *time.Time
	deleted_at              *time.Time
	starts_at               *time.Time
	expires_at              *time.Time
	status                  *string
	daily_window_start      *time.Time
	weekly_window_start     *time.Time
	monthly_window_start    *time.Time
	daily_usage_usd         *float64
	adddaily_usage_usd      *float64
	weekly_usage_usd        *float64
	addweekly_usage_usd     *float64
	monthly_usage_usd       *float64
	addmonthly_usage_usd    *float64
	assigned_at             *time.Time
	notes                   *string
	clearedFields           map[string]struct{}
	user                    *int64
	cleareduser             bool
	group                   *int64
	clearedgroup            bool
	assigned_by_user        *int64
	clearedassigned_by_user bool
	usage_logs              map[int64]struct{}
	removedusage_logs       map[int64]struct{}
	clearedusage_logs       bool
	orders                  map[int64]struct{}
	removedorders           map[int64]struct{}
	clearedorders           bool
	done                    bool
	oldValue                func(context.Context) (*UserSubscription, error)
	predicates              []predicate.UserSubscription
}

var _ ent.Mutation = (*UserSubscriptionMutation)(nil)

// usersubscriptionOption allows management of the mutation configuration using functional options.
type usersubscriptionOption func(*UserSubscriptionMutation)

// newUserSubscriptionMutation creates new mutation for the UserSubscription entity.
func newUserSubscriptionMutation(c config, op Op, opts ...usersubscriptionOption) *UserSubscriptionMutation {
	m := &UserSubscriptionMutation{
		config:        c,
		op:            op,
		typ:           TypeUserSubscription,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserSubscriptionID sets the ID field of the mutation.
func withUserSubscriptionID(id int64) usersubscriptionOption {
	return func(m *UserSubscriptionMutation) {
		var (
			err   error
			once  sync.Once
			value *UserSubscription
		)
		m.oldValue = func(ctx context.Context) (*UserSubscription, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserSubscription.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserSubscription sets the old UserSubscription of the mutation.
func withUserSubscription(node *UserSubscription) usersubscriptionOption {
	return func(m *UserSubscriptionMutation) {
		m.oldValue = func(context.Context) (*UserSubscription, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserSubscriptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserSubscriptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserSubscriptionMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserSubscriptionMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserSubscription.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserSubscriptionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserSubscriptionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserSubscriptionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserSubscriptionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserSubscriptionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserSubscriptionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserSubscriptionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserSubscriptionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserSubscriptionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[usersubscription.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserSubscriptionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[usersubscription.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserSubscriptionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, usersubscription.FieldDeletedAt)
}

// SetUserID sets the "user_id" field.
func (m *UserSubscriptionMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserSubscriptionMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserSubscriptionMutation) ResetUserID() {
	m.user = nil
}

// SetGroupID sets the "group_id" field.
func (m *UserSubscriptionMutation) SetGroupID(i int64) {
	m.group = &i
}

// GroupID returns the value of the "group_id" field in the mutation.
func (m *UserSubscriptionMutation) GroupID() (r int64, exists bool) {
	v := m.group
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupID returns the old "group_id" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldGroupID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupID: %w", err)
	}
	return oldValue.GroupID, nil
}

// ResetGroupID resets all changes to the "group_id" field.
func (m *UserSubscriptionMutation) ResetGroupID() {
	m.group = nil
}

// SetStartsAt sets the "starts_at" field.
func (m *UserSubscriptionMutation) SetStartsAt(t time.Time) {
	m.starts_at = &t
}

// StartsAt returns the value of the "starts_at" field in the mutation.
func (m *UserSubscriptionMutation) StartsAt() (r time.Time, exists bool) {
	v := m.starts_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartsAt returns the old "starts_at" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldStartsAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartsAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartsAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartsAt: %w", err)
	}
	return oldValue.StartsAt, nil
}

// ResetStartsAt resets all changes to the "starts_at" field.
func (m *UserSubscriptionMutation) ResetStartsAt() {
	m.starts_at = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *UserSubscriptionMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *UserSubscriptionMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *UserSubscriptionMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetStatus sets the "status" field.
func (m *UserSubscriptionMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *UserSubscriptionMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *UserSubscriptionMutation) ResetStatus() {
	m.status = nil
}

// SetDailyWindowStart sets the "daily_window_start" field.
func (m *UserSubscriptionMutation) SetDailyWindowStart(t time.Time) {
	m.daily_window_start = &t
}

// DailyWindowStart returns the value of the "daily_window_start" field in the mutation.
func (m *UserSubscriptionMutation) DailyWindowStart() (r time.Time, exists bool) {
	v := m.daily_window_start
	if v == nil {
		return
	}
	return *v, true
}

// OldDailyWindowStart returns the old "daily_window_start" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldDailyWindowStart(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDailyWindowStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDailyWindowStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDailyWindowStart: %w", err)
	}
	return oldValue.DailyWindowStart, nil
}

// ClearDailyWindowStart clears the value of the "daily_window_start" field.
func (m *UserSubscriptionMutation) ClearDailyWindowStart() {
	m.daily_window_start = nil
	m.clearedFields[usersubscription.FieldDailyWindowStart] = struct{}{}
}

// DailyWindowStartCleared returns if the "daily_window_start" field was cleared in this mutation.
func (m *UserSubscriptionMutation) DailyWindowStartCleared() bool {
	_, ok := m.clearedFields[usersubscription.FieldDailyWindowStart]
	return ok
}

// ResetDailyWindowStart resets all changes to the "daily_window_start" field.
func (m *UserSubscriptionMutation) ResetDailyWindowStart() {
	m.daily_window_start = nil
	delete(m.clearedFields, usersubscription.FieldDailyWindowStart)
}

// SetWeeklyWindowStart sets the "weekly_window_start" field.
func (m *UserSubscriptionMutation) SetWeeklyWindowStart(t time.Time) {
	m.weekly_window_start = &t
}

// WeeklyWindowStart returns the value of the "weekly_window_start" field in the mutation.
func (m *UserSubscriptionMutation) WeeklyWindowStart() (r time.Time, exists bool) {
	v := m.weekly_window_start
	if v == nil {
		return
	}
	return *v, true
}

// OldWeeklyWindowStart returns the old "weekly_window_start" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldWeeklyWindowStart(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeeklyWindowStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeeklyWindowStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeeklyWindowStart: %w", err)
	}
	return oldValue.WeeklyWindowStart, nil
}

// ClearWeeklyWindowStart clears the value of the "weekly_window_start" field.
func (m *UserSubscriptionMutation) ClearWeeklyWindowStart() {
	m.weekly_window_start = nil
	m.clearedFields[usersubscription.FieldWeeklyWindowStart] = struct{}{}
}

// WeeklyWindowStartCleared returns if the "weekly_window_start" field was cleared in this mutation.
func (m *UserSubscriptionMutation) WeeklyWindowStartCleared() bool {
	_, ok := m.clearedFields[usersubscription.FieldWeeklyWindowStart]
	return ok
}

// ResetWeeklyWindowStart resets all changes to the "weekly_window_start" field.
func (m *UserSubscriptionMutation) ResetWeeklyWindowStart() {
	m.weekly_window_start = nil
	delete(m.clearedFields, usersubscription.FieldWeeklyWindowStart)
}

// SetMonthlyWindowStart sets the "monthly_window_start" field.
func (m *UserSubscriptionMutation) SetMonthlyWindowStart(t time.Time) {
	m.monthly_window_start = &t
}

// MonthlyWindowStart returns the value of the "monthly_window_start" field in the mutation.
func (m *UserSubscriptionMutation) MonthlyWindowStart() (r time.Time, exists bool) {
	v := m.monthly_window_start
	if v == nil {
		return
	}
	return *v, true
}

// OldMonthlyWindowStart returns the old "monthly_window_start" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldMonthlyWindowStart(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMonthlyWindowStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMonthlyWindowStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMonthlyWindowStart: %w", err)
	}
	return oldValue.MonthlyWindowStart, nil
}

// ClearMonthlyWindowStart clears the value of the "monthly_window_start" field.
func (m *UserSubscriptionMutation) ClearMonthlyWindowStart() {
	m.monthly_window_start = nil
	m.clearedFields[usersubscription.FieldMonthlyWindowStart] = struct{}{}
}

// MonthlyWindowStartCleared returns if the "monthly_window_start" field was cleared in this mutation.
func (m *UserSubscriptionMutation) MonthlyWindowStartCleared() bool {
	_, ok := m.clearedFields[usersubscription.FieldMonthlyWindowStart]
	return ok
}

// ResetMonthlyWindowStart resets all changes to the "monthly_window_start" field.
func (m *UserSubscriptionMutation) ResetMonthlyWindowStart() {
	m.monthly_window_start = nil
	delete(m.clearedFields, usersubscription.FieldMonthlyWindowStart)
}

// SetDailyUsageUsd sets the "daily_usage_usd" field.
func (m *UserSubscriptionMutation) SetDailyUsageUsd(f float64) {
	m.daily_usage_usd = &f
	m.adddaily_usage_usd = nil
}

// DailyUsageUsd returns the value of the "daily_usage_usd" field in the mutation.
func (m *UserSubscriptionMutation) DailyUsageUsd() (r float64, exists bool) {
	v := m.daily_usage_usd
	if v == nil {
		return
	}
	return *v, true
}

// OldDailyUsageUsd returns the old "daily_usage_usd" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldDailyUsageUsd(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDailyUsageUsd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDailyUsageUsd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDailyUsageUsd: %w", err)
	}
	return oldValue.DailyUsageUsd, nil
}

// AddDailyUsageUsd adds f to the "daily_usage_usd" field.
func (m *UserSubscriptionMutation) AddDailyUsageUsd(f float64) {
	if m.adddaily_usage_usd != nil {
		*m.adddaily_usage_usd += f
	} else {
		m.adddaily_usage_usd = &f
	}
}

// AddedDailyUsageUsd returns the value that was added to the "daily_usage_usd" field in this mutation.
func (m *UserSubscriptionMutation) AddedDailyUsageUsd() (r float64, exists bool) {
	v := m.adddaily_usage_usd
	if v == nil {
		return
	}
	return *v, true
}

// ResetDailyUsageUsd resets all changes to the "daily_usage_usd" field.
func (m *UserSubscriptionMutation) ResetDailyUsageUsd() {
	m.daily_usage_usd = nil
	m.adddaily_usage_usd = nil
}

// SetWeeklyUsageUsd sets the "weekly_usage_usd" field.
func (m *UserSubscriptionMutation) SetWeeklyUsageUsd(f float64) {
	m.weekly_usage_usd = &f
	m.addweekly_usage_usd = nil
}

// WeeklyUsageUsd returns the value of the "weekly_usage_usd" field in the mutation.
func (m *UserSubscriptionMutation) WeeklyUsageUsd() (r float64, exists bool) {
	v := m.weekly_usage_usd
	if v == nil {
		return
	}
	return *v, true
}

// OldWeeklyUsageUsd returns the old "weekly_usage_usd" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldWeeklyUsageUsd(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeeklyUsageUsd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeeklyUsageUsd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeeklyUsageUsd: %w", err)
	}
	return oldValue.WeeklyUsageUsd, nil
}

// AddWeeklyUsageUsd adds f to the "weekly_usage_usd" field.
func (m *UserSubscriptionMutation) AddWeeklyUsageUsd(f float64) {
	if m.addweekly_usage_usd != nil {
		*m.addweekly_usage_usd += f
	} else {
		m.addweekly_usage_usd = &f
	}
}

// AddedWeeklyUsageUsd returns the value that was added to the "weekly_usage_usd" field in this mutation.
func (m *UserSubscriptionMutation) AddedWeeklyUsageUsd() (r float64, exists bool) {
	v := m.addweekly_usage_usd
	if v == nil {
		return
	}
	return *v, true
}

// ResetWeeklyUsageUsd resets all changes to the "weekly_usage_usd" field.
func (m *UserSubscriptionMutation) ResetWeeklyUsageUsd() {
	m.weekly_usage_usd = nil
	m.addweekly_usage_usd = nil
}

// SetMonthlyUsageUsd sets the "monthly_usage_usd" field.
func (m *UserSubscriptionMutation) SetMonthlyUsageUsd(f float64) {
	m.monthly_usage_usd = &f
	m.addmonthly_usage_usd = nil
}

// MonthlyUsageUsd returns the value of the "monthly_usage_usd" field in the mutation.
func (m *UserSubscriptionMutation) MonthlyUsageUsd() (r float64, exists bool) {
	v := m.monthly_usage_usd
	if v == nil {
		return
	}
	return *v, true
}

// OldMonthlyUsageUsd returns the old "monthly_usage_usd" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldMonthlyUsageUsd(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMonthlyUsageUsd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMonthlyUsageUsd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMonthlyUsageUsd: %w", err)
	}
	return oldValue.MonthlyUsageUsd, nil
}

// AddMonthlyUsageUsd adds f to the "monthly_usage_usd" field.
func (m *UserSubscriptionMutation) AddMonthlyUsageUsd(f float64) {
	if m.addmonthly_usage_usd != nil {
		*m.addmonthly_usage_usd += f
	} else {
		m.addmonthly_usage_usd = &f
	}
}

// AddedMonthlyUsageUsd returns the value that was added to the "monthly_usage_usd" field in this mutation.
func (m *UserSubscriptionMutation) AddedMonthlyUsageUsd() (r float64, exists bool) {
	v := m.addmonthly_usage_usd
	if v == nil {
		return
	}
	return *v, true
}

// ResetMonthlyUsageUsd resets all changes to the "monthly_usage_usd" field.
func (m *UserSubscriptionMutation) ResetMonthlyUsageUsd() {
	m.monthly_usage_usd = nil
	m.addmonthly_usage_usd = nil
}

// SetAssignedBy sets the "assigned_by" field.
func (m *UserSubscriptionMutation) SetAssignedBy(i int64) {
	m.assigned_by_user = &i
}

// AssignedBy returns the value of the "assigned_by" field in the mutation.
func (m *UserSubscriptionMutation) AssignedBy() (r int64, exists bool) {
	v := m.assigned_by_user
	if v == nil {
		return
	}
	return *v, true
}

// OldAssignedBy returns the old "assigned_by" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldAssignedBy(ctx context.Context) (v *int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssignedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssignedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssignedBy: %w", err)
	}
	return oldValue.AssignedBy, nil
}

// ClearAssignedBy clears the value of the "assigned_by" field.
func (m *UserSubscriptionMutation) ClearAssignedBy() {
	m.assigned_by_user = nil
	m.clearedFields[usersubscription.FieldAssignedBy] = struct{}{}
}

// AssignedByCleared returns if the "assigned_by" field was cleared in this mutation.
func (m *UserSubscriptionMutation) AssignedByCleared() bool {
	_, ok := m.clearedFields[usersubscription.FieldAssignedBy]
	return ok
}

// ResetAssignedBy resets all changes to the "assigned_by" field.
func (m *UserSubscriptionMutation) ResetAssignedBy() {
	m.assigned_by_user = nil
	delete(m.clearedFields, usersubscription.FieldAssignedBy)
}

// SetAssignedAt sets the "assigned_at" field.
func (m *UserSubscriptionMutation) SetAssignedAt(t time.Time) {
	m.assigned_at = &t
}

// AssignedAt returns the value of the "assigned_at" field in the mutation.
func (m *UserSubscriptionMutation) AssignedAt() (r time.Time, exists bool) {
	v := m.assigned_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAssignedAt returns the old "assigned_at" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldAssignedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssignedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssignedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssignedAt: %w", err)
	}
	return oldValue.AssignedAt, nil
}

// ResetAssignedAt resets all changes to the "assigned_at" field.
func (m *UserSubscriptionMutation) ResetAssignedAt() {
	m.assigned_at = nil
}

// SetNotes sets the "notes" field.
func (m *UserSubscriptionMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *UserSubscriptionMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldNotes(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *UserSubscriptionMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[usersubscription.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *UserSubscriptionMutation) NotesCleared() bool {
	_, ok := m.clearedFields[usersubscription.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *UserSubscriptionMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, usersubscription.FieldNotes)
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserSubscriptionMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[usersubscription.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserSubscriptionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserSubscriptionMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserSubscriptionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearGroup clears the "group" edge to the Group entity.
func (m *UserSubscriptionMutation) ClearGroup() {
	m.clearedgroup = true
	m.clearedFields[usersubscription.FieldGroupID] = struct{}{}
}

// GroupCleared reports if the "group" edge to the Group entity was cleared.
func (m *UserSubscriptionMutation) GroupCleared() bool {
	return m.clearedgroup
}

// GroupIDs returns the "group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupID instead. It exists only for internal usage by the builders.
func (m *UserSubscriptionMutation) GroupIDs() (ids []int64) {
	if id := m.group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroup resets all changes to the "group" edge.
func (m *UserSubscriptionMutation) ResetGroup() {
	m.group = nil
	m.clearedgroup = false
}

// SetAssignedByUserID sets the "assigned_by_user" edge to the User entity by id.
func (m *UserSubscriptionMutation) SetAssignedByUserID(id int64) {
	m.assigned_by_user = &id
}

// ClearAssignedByUser clears the "assigned_by_user" edge to the User entity.
func (m *UserSubscriptionMutation) ClearAssignedByUser() {
	m.clearedassigned_by_user = true
	m.clearedFields[usersubscription.FieldAssignedBy] = struct{}{}
}

// AssignedByUserCleared reports if the "assigned_by_user" edge to the User entity was cleared.
func (m *UserSubscriptionMutation) AssignedByUserCleared() bool {
	return m.AssignedByCleared() || m.clearedassigned_by_user
}

// AssignedByUserID returns the "assigned_by_user" edge ID in the mutation.
func (m *UserSubscriptionMutation) AssignedByUserID() (id int64, exists bool) {
	if m.assigned_by_user != nil {
		return *m.assigned_by_user, true
	}
	return
}

// AssignedByUserIDs returns the "assigned_by_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AssignedByUserID instead. It exists only for internal usage by the builders.
func (m *UserSubscriptionMutation) AssignedByUserIDs() (ids []int64) {
	if id := m.assigned_by_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAssignedByUser resets all changes to the "assigned_by_user" edge.
func (m *UserSubscriptionMutation) ResetAssignedByUser() {
	m.assigned_by_user = nil
	m.clearedassigned_by_user = false
}

// AddUsageLogIDs adds the "usage_logs" edge to the UsageLog entity by ids.
func (m *UserSubscriptionMutation) AddUsageLogIDs(ids ...int64) {
	if m.usage_logs == nil {
		m.usage_logs = make(map[int64]struct{})
	}
	for i := range ids {
		m.usage_logs[ids[i]] = struct{}{}
	}
}

// ClearUsageLogs clears the "usage_logs" edge to the UsageLog entity.
func (m *UserSubscriptionMutation) ClearUsageLogs() {
	m.clearedusage_logs = true
}

// UsageLogsCleared reports if the "usage_logs" edge to the UsageLog entity was cleared.
func (m *UserSubscriptionMutation) UsageLogsCleared() bool {
	return m.clearedusage_logs
}

// RemoveUsageLogIDs removes the "usage_logs" edge to the UsageLog entity by IDs.
func (m *UserSubscriptionMutation) RemoveUsageLogIDs(ids ...int64) {
	if m.removedusage_logs == nil {
		m.removedusage_logs = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.usage_logs, ids[i])
		m.removedusage_logs[ids[i]] = struct{}{}
	}
}

// RemovedUsageLogs returns the removed IDs of the "usage_logs" edge to the UsageLog entity.
func (m *UserSubscriptionMutation) RemovedUsageLogsIDs() (ids []int64) {
	for id := range m.removedusage_logs {
		ids = append(ids, id)
	}
	return
}

// UsageLogsIDs returns the "usage_logs" edge IDs in the mutation.
func (m *UserSubscriptionMutation) UsageLogsIDs() (ids []int64) {
	for id := range m.usage_logs {
		ids = append(ids, id)
	}
	return
}

// ResetUsageLogs resets all changes to the "usage_logs" edge.
func (m *UserSubscriptionMutation) ResetUsageLogs() {
	m.usage_logs = nil
	m.clearedusage_logs = false
	m.removedusage_logs = nil
}

// AddOrderIDs adds the "orders" edge to the Order entity by ids.
func (m *UserSubscriptionMutation) AddOrderIDs(ids ...int64) {
	if m.orders == nil {
		m.orders = make(map[int64]struct{})
	}
	for i := range ids {
		m.orders[ids[i]] = struct{}{}
	}
}

// ClearOrders clears the "orders" edge to the Order entity.
func (m *UserSubscriptionMutation) ClearOrders() {
	m.clearedorders = true
}

// OrdersCleared reports if the "orders" edge to the Order entity was cleared.
func (m *UserSubscriptionMutation) OrdersCleared() bool {
	return m.clearedorders
}

// RemoveOrderIDs removes the "orders" edge to the Order entity by IDs.
func (m *UserSubscriptionMutation) RemoveOrderIDs(ids ...int64) {
	if m.removedorders == nil {
		m.removedorders = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.orders, ids[i])
		m.removedorders[ids[i]] = struct{}{}
	}
}

// RemovedOrders returns the removed IDs of the "orders" edge to the Order entity.
func (m *UserSubscriptionMutation) RemovedOrdersIDs() (ids []int64) {
	for id := range m.removedorders {
		ids = append(ids, id)
	}
	return
}

// OrdersIDs returns the "orders" edge IDs in the mutation.
func (m *UserSubscriptionMutation) OrdersIDs() (ids []int64) {
	for id := range m.orders {
		ids = append(ids, id)
	}
	return
}

// ResetOrders resets all changes to the "orders" edge.
func (m *UserSubscriptionMutation) ResetOrders() {
	m.orders = nil
	m.clearedorders = false
	m.removedorders = nil
}

// Where appends a list predicates to the UserSubscriptionMutation builder.
func (m *UserSubscriptionMutation) Where(ps ...predicate.UserSubscription) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserSubscriptionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserSubscriptionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserSubscription, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserSubscriptionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserSubscriptionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserSubscription).
func (m *UserSubscriptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserSubscriptionMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.created_at != nil {
		fields = append(fields, usersubscription.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, usersubscription.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, usersubscription.FieldDeletedAt)
	}
	if m.user != nil {
		fields = append(fields, usersubscription.FieldUserID)
	}
	if m.group != nil {
		fields = append(fields, usersubscription.FieldGroupID)
	}
	if m.starts_at != nil {
		fields = append(fields, usersubscription.FieldStartsAt)
	}
	if m.expires_at != nil {
		fields = append(fields, usersubscription.FieldExpiresAt)
	}
	if m.status != nil {
		fields = append(fields, usersubscription.FieldStatus)
	}
	if m.daily_window_start != nil {
		fields = append(fields, usersubscription.FieldDailyWindowStart)
	}
	if m.weekly_window_start != nil {
		fields = append(fields, usersubscription.FieldWeeklyWindowStart)
	}
	if m.monthly_window_start != nil {
		fields = append(fields, usersubscription.FieldMonthlyWindowStart)
	}
	if m.daily_usage_usd != nil {
		fields = append(fields, usersubscription.FieldDailyUsageUsd)
	}
	if m.weekly_usage_usd != nil {
		fields = append(fields, usersubscription.FieldWeeklyUsageUsd)
	}
	if m.monthly_usage_usd != nil {
		fields = append(fields, usersubscription.FieldMonthlyUsageUsd)
	}
	if m.assigned_by_user != nil {
		fields = append(fields, usersubscription.FieldAssignedBy)
	}
	if m.assigned_at != nil {
		fields = append(fields, usersubscription.FieldAssignedAt)
	}
	if m.notes != nil {
		fields = append(fields, usersubscription.FieldNotes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserSubscriptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usersubscription.FieldCreatedAt:
		return m.CreatedAt()
	case usersubscription.FieldUpdatedAt:
		return m.UpdatedAt()
	case usersubscription.FieldDeletedAt:
		return m.DeletedAt()
	case usersubscription.FieldUserID:
		return m.UserID()
	case usersubscription.FieldGroupID:
		return m.GroupID()
	case usersubscription.FieldStartsAt:
		return m.StartsAt()
	case usersubscription.FieldExpiresAt:
		return m.ExpiresAt()
	case usersubscription.FieldStatus:
		return m.Status()
	case usersubscription.FieldDailyWindowStart:
		return m.DailyWindowStart()
	case usersubscription.FieldWeeklyWindowStart:
		return m.WeeklyWindowStart()
	case usersubscription.FieldMonthlyWindowStart:
		return m.MonthlyWindowStart()
	case usersubscription.FieldDailyUsageUsd:
		return m.DailyUsageUsd()
	case usersubscription.FieldWeeklyUsageUsd:
		return m.WeeklyUsageUsd()
	case usersubscription.FieldMonthlyUsageUsd:
		return m.MonthlyUsageUsd()
	case usersubscription.FieldAssignedBy:
		return m.AssignedBy()
	case usersubscription.FieldAssignedAt:
		return m.AssignedAt()
	case usersubscription.FieldNotes:
		return m.Notes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserSubscriptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usersubscription.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case usersubscription.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case usersubscription.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case usersubscription.FieldUserID:
		return m.OldUserID(ctx)
	case usersubscription.FieldGroupID:
		return m.OldGroupID(ctx)
	case usersubscription.FieldStartsAt:
		return m.OldStartsAt(ctx)
	case usersubscription.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case usersubscription.FieldStatus:
		return m.OldStatus(ctx)
	case usersubscription.FieldDailyWindowStart:
		return m.OldDailyWindowStart(ctx)
	case usersubscription.FieldWeeklyWindowStart:
		return m.OldWeeklyWindowStart(ctx)
	case usersubscription.FieldMonthlyWindowStart:
		return m.OldMonthlyWindowStart(ctx)
	case usersubscription.FieldDailyUsageUsd:
		return m.OldDailyUsageUsd(ctx)
	case usersubscription.FieldWeeklyUsageUsd:
		return m.OldWeeklyUsageUsd(ctx)
	case usersubscription.FieldMonthlyUsageUsd:
		return m.OldMonthlyUsageUsd(ctx)
	case usersubscription.FieldAssignedBy:
		return m.OldAssignedBy(ctx)
	case usersubscription.FieldAssignedAt:
		return m.OldAssignedAt(ctx)
	case usersubscription.FieldNotes:
		return m.OldNotes(ctx)
	}
	return nil, fmt.Errorf("unknown UserSubscription field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserSubscriptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usersubscription.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case usersubscription.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case usersubscription.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case usersubscription.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case usersubscription.FieldGroupID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupID(v)
		return nil
	case usersubscription.FieldStartsAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartsAt(v)
		return nil
	case usersubscription.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case usersubscription.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case usersubscription.FieldDailyWindowStart:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDailyWindowStart(v)
		return nil
	case usersubscription.FieldWeeklyWindowStart:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeeklyWindowStart(v)
		return nil
	case usersubscription.FieldMonthlyWindowStart:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMonthlyWindowStart(v)
		return nil
	case usersubscription.FieldDailyUsageUsd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDailyUsageUsd(v)
		return nil
	case usersubscription.FieldWeeklyUsageUsd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeeklyUsageUsd(v)
		return nil
	case usersubscription.FieldMonthlyUsageUsd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMonthlyUsageUsd(v)
		return nil
	case usersubscription.FieldAssignedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssignedBy(v)
		return nil
	case usersubscription.FieldAssignedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssignedAt(v)
		return nil
	case usersubscription.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	}
	return fmt.Errorf("unknown UserSubscription field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserSubscriptionMutation) AddedFields() []string {
	var fields []string
	if m.adddaily_usage_usd != nil {
		fields = append(fields, usersubscription.FieldDailyUsageUsd)
	}
	if m.addweekly_usage_usd != nil {
		fields = append(fields, usersubscription.FieldWeeklyUsageUsd)
	}
	if m.addmonthly_usage_usd != nil {
		fields = append(fields, usersubscription.FieldMonthlyUsageUsd)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserSubscriptionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case usersubscription.FieldDailyUsageUsd:
		return m.AddedDailyUsageUsd()
	case usersubscription.FieldWeeklyUsageUsd:
		return m.AddedWeeklyUsageUsd()
	case usersubscription.FieldMonthlyUsageUsd:
		return m.AddedMonthlyUsageUsd()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserSubscriptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case usersubscription.FieldDailyUsageUsd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDailyUsageUsd(v)
		return nil
	case usersubscription.FieldWeeklyUsageUsd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeeklyUsageUsd(v)
		return nil
	case usersubscription.FieldMonthlyUsageUsd:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMonthlyUsageUsd(v)
		return nil
	}
	return fmt.Errorf("unknown UserSubscription numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserSubscriptionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(usersubscription.FieldDeletedAt) {
		fields = append(fields, usersubscription.FieldDeletedAt)
	}
	if m.FieldCleared(usersubscription.FieldDailyWindowStart) {
		fields = append(fields, usersubscription.FieldDailyWindowStart)
	}
	if m.FieldCleared(usersubscription.FieldWeeklyWindowStart) {
		fields = append(fields, usersubscription.FieldWeeklyWindowStart)
	}
	if m.FieldCleared(usersubscription.FieldMonthlyWindowStart) {
		fields = append(fields, usersubscription.FieldMonthlyWindowStart)
	}
	if m.FieldCleared(usersubscription.FieldAssignedBy) {
		fields = append(fields, usersubscription.FieldAssignedBy)
	}
	if m.FieldCleared(usersubscription.FieldNotes) {
		fields = append(fields, usersubscription.FieldNotes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserSubscriptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserSubscriptionMutation) ClearField(name string) error {
	switch name {
	case usersubscription.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case usersubscription.FieldDailyWindowStart:
		m.ClearDailyWindowStart()
		return nil
	case usersubscription.FieldWeeklyWindowStart:
		m.ClearWeeklyWindowStart()
		return nil
	case usersubscription.FieldMonthlyWindowStart:
		m.ClearMonthlyWindowStart()
		return nil
	case usersubscription.FieldAssignedBy:
		m.ClearAssignedBy()
		return nil
	case usersubscription.FieldNotes:
		m.ClearNotes()
		return nil
	}
	return fmt.Errorf("unknown UserSubscription nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserSubscriptionMutation) ResetField(name string) error {
	switch name {
	case usersubscription.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case usersubscription.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case usersubscription.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case usersubscription.FieldUserID:
		m.ResetUserID()
		return nil
	case usersubscription.FieldGroupID:
		m.ResetGroupID()
		return nil
	case usersubscription.FieldStartsAt:
		m.ResetStartsAt()
		return nil
	case usersubscription.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case usersubscription.FieldStatus:
		m.ResetStatus()
		return nil
	case usersubscription.FieldDailyWindowStart:
		m.ResetDailyWindowStart()
		return nil
	case usersubscription.FieldWeeklyWindowStart:
		m.ResetWeeklyWindowStart()
		return nil
	case usersubscription.FieldMonthlyWindowStart:
		m.ResetMonthlyWindowStart()
		return nil
	case usersubscription.FieldDailyUsageUsd:
		m.ResetDailyUsageUsd()
		return nil
	case usersubscription.FieldWeeklyUsageUsd:
		m.ResetWeeklyUsageUsd()
		return nil
	case usersubscription.FieldMonthlyUsageUsd:
		m.ResetMonthlyUsageUsd()
		return nil
	case usersubscription.FieldAssignedBy:
		m.ResetAssignedBy()
		return nil
	case usersubscription.FieldAssignedAt:
		m.ResetAssignedAt()
		return nil
	case usersubscription.FieldNotes:
		m.ResetNotes()
		return nil
	}
	return fmt.Errorf("unknown UserSubscription field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserSubscriptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.user != nil {
		edges = append(edges, usersubscription.EdgeUser)
	}
	if m.group != nil {
		edges = append(edges, usersubscription.EdgeGroup)
	}
	if m.assigned_by_user != nil {
		edges = append(edges, usersubscription.EdgeAssignedByUser)
	}
	if m.usage_logs != nil {
		edges = append(edges, usersubscription.EdgeUsageLogs)
	}
	if m.orders != nil {
		edges = append(edges, usersubscription.EdgeOrders)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserSubscriptionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usersubscription.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case usersubscription.EdgeGroup:
		if id := m.group; id != nil {
			return []ent.Value{*id}
		}
	case usersubscription.EdgeAssignedByUser:
		if id := m.assigned_by_user; id != nil {
			return []ent.Value{*id}
		}
	case usersubscription.EdgeUsageLogs:
		ids := make([]ent.Value, 0, len(m.usage_logs))
		for id := range m.usage_logs {
			ids = append(ids, id)
		}
		return ids
	case usersubscription.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.orders))
		for id := range m.orders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserSubscriptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedusage_logs != nil {
		edges = append(edges, usersubscription.EdgeUsageLogs)
	}
	if m.removedorders != nil {
		edges = append(edges, usersubscription.EdgeOrders)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserSubscriptionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case usersubscription.EdgeUsageLogs:
		ids := make([]ent.Value, 0, len(m.removedusage_logs))
		for id := range m.removedusage_logs {
			ids = append(ids, id)
		}
		return ids
	case usersubscription.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.removedorders))
		for id := range m.removedorders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserSubscriptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.cleareduser {
		edges = append(edges, usersubscription.EdgeUser)
	}
	if m.clearedgroup {
		edges = append(edges, usersubscription.EdgeGroup)
	}
	if m.clearedassigned_by_user {
		edges = append(edges, usersubscription.EdgeAssignedByUser)
	}
	if m.clearedusage_logs {
		edges = append(edges, usersubscription.EdgeUsageLogs)
	}
	if m.clearedorders {
		edges = append(edges, usersubscription.EdgeOrders)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserSubscriptionMutation) EdgeCleared(name string) bool {
	switch name {
	case usersubscription.EdgeUser:
		return m.cleareduser
	case usersubscription.EdgeGroup:
		return m.clearedgroup
	case usersubscription.EdgeAssignedByUser:
		return m.clearedassigned_by_user
	case usersubscription.EdgeUsageLogs:
		return m.clearedusage_logs
	case usersubscription.EdgeOrders:
		return m.clearedorders
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserSubscriptionMutation) ClearEdge(name string) error {
	switch name {
	case usersubscription.EdgeUser:
		m.ClearUser()
		return nil
	case usersubscription.EdgeGroup:
		m.ClearGroup()
		return nil
	case usersubscription.EdgeAssignedByUser:
		m.ClearAssignedByUser()
		return nil
	}
	return fmt.Errorf("unknown UserSubscription unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserSubscriptionMutation) ResetEdge(name string) error {
	switch name {
	case usersubscription.EdgeUser:
		m.ResetUser()
		return nil
	case usersubscription.EdgeGroup:
		m.ResetGroup()
		return nil
	case usersubscription.EdgeAssignedByUser:
		m.ResetAssignedByUser()
		return nil
	case usersubscription.EdgeUsageLogs:
		m.ResetUsageLogs()
		return nil
	case usersubscription.EdgeOrders:
		m.ResetOrders()
		return nil
	}
	return fmt.Errorf("unknown UserSubscription edge %s", name)
}
